/* Generated from Java with JSweet 2.0.0-rc1 - http://www.jsweet.org */
namespace uml.util {
    /**
     * Creates an instance of the switch.
     * <!-- begin-user-doc -->
     * <!-- end-user-doc -->
     * @generated
     * @class
     * @extends org.eclipse.emf.ecore.util.EObjectValidator
     */
    export class UmlValidator extends org.eclipse.emf.ecore.util.EObjectValidator {
        /**
         * The cached model package
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static INSTANCE : UmlValidator; public static INSTANCE_$LI$() : UmlValidator { if(UmlValidator.INSTANCE == null) UmlValidator.INSTANCE = new UmlValidator(); return UmlValidator.INSTANCE; };

        /**
         * A constant for the {@link org.eclipse.emf.common.util.Diagnostic#getSource() source} of diagnostic {@link org.eclipse.emf.common.util.Diagnostic#getCode() codes} from this package.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @see org.eclipse.emf.common.util.Diagnostic#getSource()
         * @see org.eclipse.emf.common.util.Diagnostic#getCode()
         * @generated
         */
        public static DIAGNOSTIC_SOURCE : string = "uml";

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Maximum one parameter node' of 'Activity'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static ACTIVITY__MAXIMUM_ONE_PARAMETER_NODE : number = 1;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Maximum two parameter nodes' of 'Activity'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static ACTIVITY__MAXIMUM_TWO_PARAMETER_NODES : number = 2;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Most one behavior' of 'Behavior'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static BEHAVIOR__MOST_ONE_BEHAVIOR : number = 3;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Parameters match' of 'Behavior'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static BEHAVIOR__PARAMETERS_MATCH : number = 4;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Feature of context classifier' of 'Behavior'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static BEHAVIOR__FEATURE_OF_CONTEXT_CLASSIFIER : number = 5;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Passive class' of 'Class'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static CLASS__PASSIVE_CLASS : number = 6;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Class behavior' of 'Behaviored Classifier'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static BEHAVIORED_CLASSIFIER__CLASS_BEHAVIOR : number = 7;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Specialize type' of 'Classifier'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static CLASSIFIER__SPECIALIZE_TYPE : number = 8;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Maps to generalization set' of 'Classifier'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static CLASSIFIER__MAPS_TO_GENERALIZATION_SET : number = 9;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Non final parents' of 'Classifier'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static CLASSIFIER__NON_FINAL_PARENTS : number = 10;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'No cycles in generalization' of 'Classifier'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static CLASSIFIER__NO_CYCLES_IN_GENERALIZATION : number = 11;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Members distinguishable' of 'Namespace'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static NAMESPACE__MEMBERS_DISTINGUISHABLE : number = 12;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Cannot import self' of 'Namespace'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static NAMESPACE__CANNOT_IMPORT_SELF : number = 13;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Cannot import owned Members' of 'Namespace'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static NAMESPACE__CANNOT_IMPORT_OWNED_MEMBERS : number = 14;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Visibility needs ownership' of 'Named Element'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static NAMED_ELEMENT__VISIBILITY_NEEDS_OWNERSHIP : number = 15;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Has qualified name' of 'Named Element'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static NAMED_ELEMENT__HAS_QUALIFIED_NAME : number = 16;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Has no qualified name' of 'Named Element'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static NAMED_ELEMENT__HAS_NO_QUALIFIED_NAME : number = 17;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Has owner' of 'Element'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static ELEMENT__HAS_OWNER : number = 18;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Not own self' of 'Element'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static ELEMENT__NOT_OWN_SELF : number = 19;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Binary Associations Only' of 'Stereotype'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static STEREOTYPE__BINARY_ASSOCIATIONS_ONLY : number = 20;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Generalize' of 'Stereotype'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static STEREOTYPE__GENERALIZE : number = 21;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Name not clash' of 'Stereotype'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static STEREOTYPE__NAME_NOT_CLASH : number = 22;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Association End Ownership' of 'Stereotype'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static STEREOTYPE__ASSOCIATION_END_OWNERSHIP : number = 23;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Base property upper bound' of 'Stereotype'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static STEREOTYPE__BASE_PROPERTY_UPPER_BOUND : number = 24;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Base property multiplicity single extension' of 'Stereotype'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static STEREOTYPE__BASE_PROPERTY_MULTIPLICITY_SINGLE_EXTENSION : number = 25;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Base property multiplicity multiple extension' of 'Stereotype'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static STEREOTYPE__BASE_PROPERTY_MULTIPLICITY_MULTIPLE_EXTENSION : number = 26;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Metaclass reference not specialized' of 'Profile'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static PROFILE__METACLASS_REFERENCE_NOT_SPECIALIZED : number = 27;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'References same metamodel' of 'Profile'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static PROFILE__REFERENCES_SAME_METAMODEL : number = 28;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Elements public or private' of 'Package'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static PACKAGE__ELEMENTS_PUBLIC_OR_PRIVATE : number = 29;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Namespace needs visibility' of 'Packageable Element'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static PACKAGEABLE_ELEMENT__NAMESPACE_NEEDS_VISIBILITY : number = 30;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Must be compatible' of 'Template Parameter'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static TEMPLATE_PARAMETER__MUST_BE_COMPATIBLE : number = 31;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Own elements' of 'Template Signature'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static TEMPLATE_SIGNATURE__OWN_ELEMENTS : number = 32;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Unique parameters' of 'Template Signature'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static TEMPLATE_SIGNATURE__UNIQUE_PARAMETERS : number = 33;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Parameter substitution formal' of 'Template Binding'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static TEMPLATE_BINDING__PARAMETER_SUBSTITUTION_FORMAL : number = 34;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'One parameter substitution' of 'Template Binding'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static TEMPLATE_BINDING__ONE_PARAMETER_SUBSTITUTION : number = 35;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Must be compatible' of 'Template Parameter Substitution'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static TEMPLATE_PARAMETER_SUBSTITUTION__MUST_BE_COMPATIBLE : number = 36;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Specialized end number' of 'Association'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static ASSOCIATION__SPECIALIZED_END_NUMBER : number = 37;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Specialized end types' of 'Association'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static ASSOCIATION__SPECIALIZED_END_TYPES : number = 38;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Binary associations' of 'Association'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static ASSOCIATION__BINARY_ASSOCIATIONS : number = 39;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Association ends' of 'Association'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static ASSOCIATION__ASSOCIATION_ENDS : number = 40;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Ends must be typed' of 'Association'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static ASSOCIATION__ENDS_MUST_BE_TYPED : number = 41;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Subsetting context conforms' of 'Property'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static PROPERTY__SUBSETTING_CONTEXT_CONFORMS : number = 42;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Derived union is read only' of 'Property'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static PROPERTY__DERIVED_UNION_IS_READ_ONLY : number = 43;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Multiplicity of composite' of 'Property'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static PROPERTY__MULTIPLICITY_OF_COMPOSITE : number = 44;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Redefined property inherited' of 'Property'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static PROPERTY__REDEFINED_PROPERTY_INHERITED : number = 45;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Subsetting rules' of 'Property'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static PROPERTY__SUBSETTING_RULES : number = 46;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Binding to attribute' of 'Property'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static PROPERTY__BINDING_TO_ATTRIBUTE : number = 47;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Derived union is derived' of 'Property'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static PROPERTY__DERIVED_UNION_IS_DERIVED : number = 48;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Deployment target' of 'Property'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static PROPERTY__DEPLOYMENT_TARGET : number = 49;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Subsetted property names' of 'Property'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static PROPERTY__SUBSETTED_PROPERTY_NAMES : number = 50;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Type of opposite end' of 'Property'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static PROPERTY__TYPE_OF_OPPOSITE_END : number = 51;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Qualified is association end' of 'Property'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static PROPERTY__QUALIFIED_IS_ASSOCIATION_END : number = 52;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Role and part with port' of 'Connector End'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static CONNECTOR_END__ROLE_AND_PART_WITH_PORT : number = 53;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Part with port empty' of 'Connector End'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static CONNECTOR_END__PART_WITH_PORT_EMPTY : number = 54;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Multiplicity' of 'Connector End'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static CONNECTOR_END__MULTIPLICITY : number = 55;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Self part with port' of 'Connector End'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static CONNECTOR_END__SELF_PART_WITH_PORT : number = 56;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Upper ge lower' of 'Multiplicity Element'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static MULTIPLICITY_ELEMENT__UPPER_GE_LOWER : number = 57;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Lower ge 0' of 'Multiplicity Element'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static MULTIPLICITY_ELEMENT__LOWER_GE_0 : number = 58;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Value specification no side effects' of 'Multiplicity Element'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static MULTIPLICITY_ELEMENT__VALUE_SPECIFICATION_NO_SIDE_EFFECTS : number = 59;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Value specification constant' of 'Multiplicity Element'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static MULTIPLICITY_ELEMENT__VALUE_SPECIFICATION_CONSTANT : number = 60;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Lower is integer' of 'Multiplicity Element'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static MULTIPLICITY_ELEMENT__LOWER_IS_INTEGER : number = 61;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Upper is unlimited Natural' of 'Multiplicity Element'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static MULTIPLICITY_ELEMENT__UPPER_IS_UNLIMITED_NATURAL : number = 62;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Deployment target' of 'Deployment Specification'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static DEPLOYMENT_SPECIFICATION__DEPLOYMENT_TARGET : number = 63;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Deployed elements' of 'Deployment Specification'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static DEPLOYMENT_SPECIFICATION__DEPLOYED_ELEMENTS : number = 64;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Language body size' of 'Opaque Expression'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static OPAQUE_EXPRESSION__LANGUAGE_BODY_SIZE : number = 65;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'One return result parameter' of 'Opaque Expression'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static OPAQUE_EXPRESSION__ONE_RETURN_RESULT_PARAMETER : number = 66;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Only return result parameters' of 'Opaque Expression'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static OPAQUE_EXPRESSION__ONLY_RETURN_RESULT_PARAMETERS : number = 67;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'In and out' of 'Parameter'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static PARAMETER__IN_AND_OUT : number = 68;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Not exception' of 'Parameter'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static PARAMETER__NOT_EXCEPTION : number = 69;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Connector end' of 'Parameter'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static PARAMETER__CONNECTOR_END : number = 70;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Reentrant behaviors' of 'Parameter'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static PARAMETER__REENTRANT_BEHAVIORS : number = 71;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Stream and exception' of 'Parameter'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static PARAMETER__STREAM_AND_EXCEPTION : number = 72;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Object effect' of 'Parameter'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static PARAMETER__OBJECT_EFFECT : number = 73;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'At most one return' of 'Operation'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static OPERATION__AT_MOST_ONE_RETURN : number = 74;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Only body for query' of 'Operation'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static OPERATION__ONLY_BODY_FOR_QUERY : number = 75;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Abstract no method' of 'Behavioral Feature'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static BEHAVIORAL_FEATURE__ABSTRACT_NO_METHOD : number = 76;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Redefinition consistent' of 'Redefinable Element'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static REDEFINABLE_ELEMENT__REDEFINITION_CONSISTENT : number = 77;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Non leaf redefinition' of 'Redefinable Element'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static REDEFINABLE_ELEMENT__NON_LEAF_REDEFINITION : number = 78;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Redefinition context valid' of 'Redefinable Element'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static REDEFINABLE_ELEMENT__REDEFINITION_CONTEXT_VALID : number = 79;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Same parameterized entity' of 'Parameter Set'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static PARAMETER_SET__SAME_PARAMETERIZED_ENTITY : number = 80;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Input' of 'Parameter Set'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static PARAMETER_SET__INPUT : number = 81;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Two parameter sets' of 'Parameter Set'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static PARAMETER_SET__TWO_PARAMETER_SETS : number = 82;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Boolean value' of 'Constraint'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static CONSTRAINT__BOOLEAN_VALUE : number = 83;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'No side effects' of 'Constraint'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static CONSTRAINT__NO_SIDE_EFFECTS : number = 84;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Not apply to self' of 'Constraint'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static CONSTRAINT__NOT_APPLY_TO_SELF : number = 85;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Visibility' of 'Interface'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static INTERFACE__VISIBILITY : number = 86;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Same name as signal' of 'Reception'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static RECEPTION__SAME_NAME_AS_SIGNAL : number = 87;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Same structure as signal' of 'Reception'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static RECEPTION__SAME_STRUCTURE_AS_SIGNAL : number = 88;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Deep or shallow history' of 'Protocol State Machine'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static PROTOCOL_STATE_MACHINE__DEEP_OR_SHALLOW_HISTORY : number = 89;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Entry exit do' of 'Protocol State Machine'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static PROTOCOL_STATE_MACHINE__ENTRY_EXIT_DO : number = 90;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Protocol transitions' of 'Protocol State Machine'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static PROTOCOL_STATE_MACHINE__PROTOCOL_TRANSITIONS : number = 91;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Connection points' of 'State Machine'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static STATE_MACHINE__CONNECTION_POINTS : number = 92;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Classifier context' of 'State Machine'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static STATE_MACHINE__CLASSIFIER_CONTEXT : number = 93;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Method' of 'State Machine'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static STATE_MACHINE__METHOD : number = 94;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Context classifier' of 'State Machine'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static STATE_MACHINE__CONTEXT_CLASSIFIER : number = 95;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Transitions outgoing' of 'Pseudostate'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static PSEUDOSTATE__TRANSITIONS_OUTGOING : number = 96;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Choice vertex' of 'Pseudostate'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static PSEUDOSTATE__CHOICE_VERTEX : number = 97;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Outgoing from initial' of 'Pseudostate'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static PSEUDOSTATE__OUTGOING_FROM_INITIAL : number = 98;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Join vertex' of 'Pseudostate'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static PSEUDOSTATE__JOIN_VERTEX : number = 99;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Junction vertex' of 'Pseudostate'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static PSEUDOSTATE__JUNCTION_VERTEX : number = 100;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'History vertices' of 'Pseudostate'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static PSEUDOSTATE__HISTORY_VERTICES : number = 101;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Initial vertex' of 'Pseudostate'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static PSEUDOSTATE__INITIAL_VERTEX : number = 102;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Fork vertex' of 'Pseudostate'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static PSEUDOSTATE__FORK_VERTEX : number = 103;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Transitions incoming' of 'Pseudostate'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static PSEUDOSTATE__TRANSITIONS_INCOMING : number = 104;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Deep history vertex' of 'Region'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static REGION__DEEP_HISTORY_VERTEX : number = 105;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Shallow history vertex' of 'Region'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static REGION__SHALLOW_HISTORY_VERTEX : number = 106;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Owned' of 'Region'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static REGION__OWNED : number = 107;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Initial vertex' of 'Region'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static REGION__INITIAL_VERTEX : number = 108;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Entry or exit' of 'State'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static STATE__ENTRY_OR_EXIT : number = 109;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Submachine states' of 'State'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static STATE__SUBMACHINE_STATES : number = 110;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Composite states' of 'State'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static STATE__COMPOSITE_STATES : number = 111;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Destinations or sources of transitions' of 'State'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static STATE__DESTINATIONS_OR_SOURCES_OF_TRANSITIONS : number = 112;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Submachine or regions' of 'State'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static STATE__SUBMACHINE_OR_REGIONS : number = 113;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Exit pseudostates' of 'Connection Point Reference'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static CONNECTION_POINT_REFERENCE__EXIT_PSEUDOSTATES : number = 114;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Entry pseudostates' of 'Connection Point Reference'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static CONNECTION_POINT_REFERENCE__ENTRY_PSEUDOSTATES : number = 115;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Trigger with ports' of 'Trigger'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static TRIGGER__TRIGGER_WITH_PORTS : number = 116;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Port aggregation' of 'Port'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static PORT__PORT_AGGREGATION : number = 117;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Default value' of 'Port'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static PORT__DEFAULT_VALUE : number = 118;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Encapsulated owner' of 'Port'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static PORT__ENCAPSULATED_OWNER : number = 119;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'State is external' of 'Transition'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static TRANSITION__STATE_IS_EXTERNAL : number = 120;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Join segment guards' of 'Transition'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static TRANSITION__JOIN_SEGMENT_GUARDS : number = 121;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'State is internal' of 'Transition'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static TRANSITION__STATE_IS_INTERNAL : number = 122;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Outgoing pseudostates' of 'Transition'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static TRANSITION__OUTGOING_PSEUDOSTATES : number = 123;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Join segment state' of 'Transition'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static TRANSITION__JOIN_SEGMENT_STATE : number = 124;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Fork segment state' of 'Transition'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static TRANSITION__FORK_SEGMENT_STATE : number = 125;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'State is local' of 'Transition'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static TRANSITION__STATE_IS_LOCAL : number = 126;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Initial transition' of 'Transition'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static TRANSITION__INITIAL_TRANSITION : number = 127;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Fork segment guards' of 'Transition'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static TRANSITION__FORK_SEGMENT_GUARDS : number = 128;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Match default signature' of 'Operation Template Parameter'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static OPERATION_TEMPLATE_PARAMETER__MATCH_DEFAULT_SIGNATURE : number = 129;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Immutable' of 'Enumeration'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static ENUMERATION__IMMUTABLE : number = 130;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Deployment artifact' of 'Instance Specification'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static INSTANCE_SPECIFICATION__DEPLOYMENT_ARTIFACT : number = 131;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Structural feature' of 'Instance Specification'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static INSTANCE_SPECIFICATION__STRUCTURAL_FEATURE : number = 132;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Defining feature' of 'Instance Specification'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static INSTANCE_SPECIFICATION__DEFINING_FEATURE : number = 133;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Deployment target' of 'Instance Specification'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static INSTANCE_SPECIFICATION__DEPLOYMENT_TARGET : number = 134;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Imported element is public' of 'Element Import'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static ELEMENT_IMPORT__IMPORTED_ELEMENT_IS_PUBLIC : number = 135;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Visibility public or private' of 'Element Import'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static ELEMENT_IMPORT__VISIBILITY_PUBLIC_OR_PRIVATE : number = 136;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Public or private' of 'Package Import'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static PACKAGE_IMPORT__PUBLIC_OR_PRIVATE : number = 137;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Non owned end' of 'Extension'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static EXTENSION__NON_OWNED_END : number = 138;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Is binary' of 'Extension'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static EXTENSION__IS_BINARY : number = 139;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Multiplicity' of 'Extension End'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static EXTENSION_END__MULTIPLICITY : number = 140;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Aggregation' of 'Extension End'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static EXTENSION_END__AGGREGATION : number = 141;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Operands' of 'String Expression'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static STRING_EXPRESSION__OPERANDS : number = 142;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Subexpressions' of 'String Expression'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static STRING_EXPRESSION__SUBEXPRESSIONS : number = 143;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Client elements' of 'Collaboration Use'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static COLLABORATION_USE__CLIENT_ELEMENTS : number = 144;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Every role' of 'Collaboration Use'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static COLLABORATION_USE__EVERY_ROLE : number = 145;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Connectors' of 'Collaboration Use'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static COLLABORATION_USE__CONNECTORS : number = 146;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Types' of 'Connector'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static CONNECTOR__TYPES : number = 147;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Roles' of 'Connector'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static CONNECTOR__ROLES : number = 148;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Generalization same classifier' of 'Generalization Set'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static GENERALIZATION_SET__GENERALIZATION_SAME_CLASSIFIER : number = 149;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Maps to generalization set' of 'Generalization Set'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static GENERALIZATION_SET__MAPS_TO_GENERALIZATION_SET : number = 150;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Redefines parents' of 'Redefinable Template Signature'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static REDEFINABLE_TEMPLATE_SIGNATURE__REDEFINES_PARENTS : number = 151;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Binary associations' of 'Use Case'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static USE_CASE__BINARY_ASSOCIATIONS : number = 152;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'No association to use case' of 'Use Case'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static USE_CASE__NO_ASSOCIATION_TO_USE_CASE : number = 153;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Cannot include self' of 'Use Case'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static USE_CASE__CANNOT_INCLUDE_SELF : number = 154;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Must have name' of 'Use Case'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static USE_CASE__MUST_HAVE_NAME : number = 155;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Extension points' of 'Extend'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static EXTEND__EXTENSION_POINTS : number = 156;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Must have name' of 'Extension Point'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static EXTENSION_POINT__MUST_HAVE_NAME : number = 157;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Has constraining classifier' of 'Classifier Template Parameter'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static CLASSIFIER_TEMPLATE_PARAMETER__HAS_CONSTRAINING_CLASSIFIER : number = 158;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Parametered element no features' of 'Classifier Template Parameter'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static CLASSIFIER_TEMPLATE_PARAMETER__PARAMETERED_ELEMENT_NO_FEATURES : number = 159;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Matching abstract' of 'Classifier Template Parameter'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static CLASSIFIER_TEMPLATE_PARAMETER__MATCHING_ABSTRACT : number = 160;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Actual is classifier' of 'Classifier Template Parameter'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static CLASSIFIER_TEMPLATE_PARAMETER__ACTUAL_IS_CLASSIFIER : number = 161;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Constraining classifiers constrain args' of 'Classifier Template Parameter'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static CLASSIFIER_TEMPLATE_PARAMETER__CONSTRAINING_CLASSIFIERS_CONSTRAIN_ARGS : number = 162;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Constraining classifiers constrain parametered element' of 'Classifier Template Parameter'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static CLASSIFIER_TEMPLATE_PARAMETER__CONSTRAINING_CLASSIFIERS_CONSTRAIN_PARAMETERED_ELEMENT : number = 163;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Nodes and edges' of 'Activity Group'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static ACTIVITY_GROUP__NODES_AND_EDGES : number = 164;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Not contained' of 'Activity Group'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static ACTIVITY_GROUP__NOT_CONTAINED : number = 165;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Source and target' of 'Activity Edge'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static ACTIVITY_EDGE__SOURCE_AND_TARGET : number = 166;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Represents classifier' of 'Activity Partition'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static ACTIVITY_PARTITION__REPRESENTS_CLASSIFIER : number = 167;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Represents property and is contained' of 'Activity Partition'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static ACTIVITY_PARTITION__REPRESENTS_PROPERTY_AND_IS_CONTAINED : number = 168;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Represents property' of 'Activity Partition'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static ACTIVITY_PARTITION__REPRESENTS_PROPERTY : number = 169;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Dimension not contained' of 'Activity Partition'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static ACTIVITY_PARTITION__DIMENSION_NOT_CONTAINED : number = 170;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Interrupting edges' of 'Interruptible Activity Region'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static INTERRUPTIBLE_ACTIVITY_REGION__INTERRUPTING_EDGES : number = 171;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Output pin edges' of 'Structured Activity Node'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static STRUCTURED_ACTIVITY_NODE__OUTPUT_PIN_EDGES : number = 172;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Edges' of 'Structured Activity Node'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static STRUCTURED_ACTIVITY_NODE__EDGES : number = 173;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Input pin edges' of 'Structured Activity Node'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static STRUCTURED_ACTIVITY_NODE__INPUT_PIN_EDGES : number = 174;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Handler body edges' of 'Exception Handler'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static EXCEPTION_HANDLER__HANDLER_BODY_EDGES : number = 175;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Output pins' of 'Exception Handler'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static EXCEPTION_HANDLER__OUTPUT_PINS : number = 176;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'One input' of 'Exception Handler'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static EXCEPTION_HANDLER__ONE_INPUT : number = 177;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Edge source target' of 'Exception Handler'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static EXCEPTION_HANDLER__EDGE_SOURCE_TARGET : number = 178;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Handler body owner' of 'Exception Handler'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static EXCEPTION_HANDLER__HANDLER_BODY_OWNER : number = 179;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Exception input type' of 'Exception Handler'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static EXCEPTION_HANDLER__EXCEPTION_INPUT_TYPE : number = 180;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Input output parameter' of 'Object Node'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static OBJECT_NODE__INPUT_OUTPUT_PARAMETER : number = 181;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Selection behavior' of 'Object Node'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static OBJECT_NODE__SELECTION_BEHAVIOR : number = 182;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Object flow edges' of 'Object Node'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static OBJECT_NODE__OBJECT_FLOW_EDGES : number = 183;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Outgoing edges structured only' of 'Input Pin'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static INPUT_PIN__OUTGOING_EDGES_STRUCTURED_ONLY : number = 184;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Control pins' of 'Pin'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static PIN__CONTROL_PINS : number = 185;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Not unique' of 'Pin'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static PIN__NOT_UNIQUE : number = 186;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Incoming edges structured only' of 'Output Pin'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static OUTPUT_PIN__INCOMING_EDGES_STRUCTURED_ONLY : number = 187;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Multiplicity' of 'Value Specification Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static VALUE_SPECIFICATION_ACTION__MULTIPLICITY : number = 188;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Compatible type' of 'Value Specification Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static VALUE_SPECIFICATION_ACTION__COMPATIBLE_TYPE : number = 189;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Scope of variable' of 'Variable Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static VARIABLE_ACTION__SCOPE_OF_VARIABLE : number = 190;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Allow access' of 'Write Link Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static WRITE_LINK_ACTION__ALLOW_ACCESS : number = 191;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Same pins' of 'Link Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static LINK_ACTION__SAME_PINS : number = 192;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Same association' of 'Link Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static LINK_ACTION__SAME_ASSOCIATION : number = 193;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Not static' of 'Link Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static LINK_ACTION__NOT_STATIC : number = 194;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Same type' of 'Link End Data'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static LINK_END_DATA__SAME_TYPE : number = 195;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Multiplicity' of 'Link End Data'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static LINK_END_DATA__MULTIPLICITY : number = 196;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'End object input pin' of 'Link End Data'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static LINK_END_DATA__END_OBJECT_INPUT_PIN : number = 197;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Property is association end' of 'Link End Data'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static LINK_END_DATA__PROPERTY_IS_ASSOCIATION_END : number = 198;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Qualifiers' of 'Link End Data'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static LINK_END_DATA__QUALIFIERS : number = 199;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Multiplicity of qualifier' of 'Qualifier Value'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static QUALIFIER_VALUE__MULTIPLICITY_OF_QUALIFIER : number = 200;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Type of qualifier' of 'Qualifier Value'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static QUALIFIER_VALUE__TYPE_OF_QUALIFIER : number = 201;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Qualifier attribute' of 'Qualifier Value'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static QUALIFIER_VALUE__QUALIFIER_ATTRIBUTE : number = 202;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Multiplicity of result' of 'Write Structural Feature Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static WRITE_STRUCTURAL_FEATURE_ACTION__MULTIPLICITY_OF_RESULT : number = 203;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Type of value' of 'Write Structural Feature Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static WRITE_STRUCTURAL_FEATURE_ACTION__TYPE_OF_VALUE : number = 204;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Multiplicity of value' of 'Write Structural Feature Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static WRITE_STRUCTURAL_FEATURE_ACTION__MULTIPLICITY_OF_VALUE : number = 205;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Type of result' of 'Write Structural Feature Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static WRITE_STRUCTURAL_FEATURE_ACTION__TYPE_OF_RESULT : number = 206;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Multiplicity' of 'Structural Feature Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static STRUCTURAL_FEATURE_ACTION__MULTIPLICITY : number = 207;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Object type' of 'Structural Feature Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static STRUCTURAL_FEATURE_ACTION__OBJECT_TYPE : number = 208;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Visibility' of 'Structural Feature Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static STRUCTURAL_FEATURE_ACTION__VISIBILITY : number = 209;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Not static' of 'Structural Feature Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static STRUCTURAL_FEATURE_ACTION__NOT_STATIC : number = 210;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'One featuring classifier' of 'Structural Feature Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static STRUCTURAL_FEATURE_ACTION__ONE_FEATURING_CLASSIFIER : number = 211;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Value type' of 'Write Variable Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static WRITE_VARIABLE_ACTION__VALUE_TYPE : number = 212;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Multiplicity' of 'Write Variable Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static WRITE_VARIABLE_ACTION__MULTIPLICITY : number = 213;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Result pins' of 'Accept Call Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static ACCEPT_CALL_ACTION__RESULT_PINS : number = 214;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Trigger call event' of 'Accept Call Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static ACCEPT_CALL_ACTION__TRIGGER_CALL_EVENT : number = 215;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Unmarshall' of 'Accept Call Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static ACCEPT_CALL_ACTION__UNMARSHALL : number = 216;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'One output pin' of 'Accept Event Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static ACCEPT_EVENT_ACTION__ONE_OUTPUT_PIN : number = 217;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'No input pins' of 'Accept Event Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static ACCEPT_EVENT_ACTION__NO_INPUT_PINS : number = 218;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'No output pins' of 'Accept Event Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static ACCEPT_EVENT_ACTION__NO_OUTPUT_PINS : number = 219;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Unmarshall signal events' of 'Accept Event Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static ACCEPT_EVENT_ACTION__UNMARSHALL_SIGNAL_EVENTS : number = 220;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Conforming type' of 'Accept Event Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static ACCEPT_EVENT_ACTION__CONFORMING_TYPE : number = 221;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Input pin' of 'Action Input Pin'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static ACTION_INPUT_PIN__INPUT_PIN : number = 222;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'One output pin' of 'Action Input Pin'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static ACTION_INPUT_PIN__ONE_OUTPUT_PIN : number = 223;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'No control or object flow' of 'Action Input Pin'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static ACTION_INPUT_PIN__NO_CONTROL_OR_OBJECT_FLOW : number = 224;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Required value' of 'Add Structural Feature Value Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static ADD_STRUCTURAL_FEATURE_VALUE_ACTION__REQUIRED_VALUE : number = 225;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Insert At pin' of 'Add Structural Feature Value Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static ADD_STRUCTURAL_FEATURE_VALUE_ACTION__INSERT_AT_PIN : number = 226;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Required value' of 'Add Variable Value Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static ADD_VARIABLE_VALUE_ACTION__REQUIRED_VALUE : number = 227;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Insert At pin' of 'Add Variable Value Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static ADD_VARIABLE_VALUE_ACTION__INSERT_AT_PIN : number = 228;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Number of arguments' of 'Broadcast Signal Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static BROADCAST_SIGNAL_ACTION__NUMBER_OF_ARGUMENTS : number = 229;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Type ordering multiplicity' of 'Broadcast Signal Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static BROADCAST_SIGNAL_ACTION__TYPE_ORDERING_MULTIPLICITY : number = 230;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'No onport' of 'Broadcast Signal Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static BROADCAST_SIGNAL_ACTION__NO_ONPORT : number = 231;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Argument pins' of 'Call Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static CALL_ACTION__ARGUMENT_PINS : number = 232;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Result pins' of 'Call Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static CALL_ACTION__RESULT_PINS : number = 233;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Synchronous call' of 'Call Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static CALL_ACTION__SYNCHRONOUS_CALL : number = 234;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'No onport' of 'Call Behavior Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static CALL_BEHAVIOR_ACTION__NO_ONPORT : number = 235;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Type target pin' of 'Call Operation Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static CALL_OPERATION_ACTION__TYPE_TARGET_PIN : number = 236;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Body output pins' of 'Clause'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static CLAUSE__BODY_OUTPUT_PINS : number = 237;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Decider output' of 'Clause'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static CLAUSE__DECIDER_OUTPUT : number = 238;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Test and body' of 'Clause'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static CLAUSE__TEST_AND_BODY : number = 239;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Multiplicity' of 'Clear Association Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static CLEAR_ASSOCIATION_ACTION__MULTIPLICITY : number = 240;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Same type' of 'Clear Association Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static CLEAR_ASSOCIATION_ACTION__SAME_TYPE : number = 241;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Type of result' of 'Clear Structural Feature Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static CLEAR_STRUCTURAL_FEATURE_ACTION__TYPE_OF_RESULT : number = 242;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Multiplicity of result' of 'Clear Structural Feature Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static CLEAR_STRUCTURAL_FEATURE_ACTION__MULTIPLICITY_OF_RESULT : number = 243;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Result no incoming' of 'Conditional Node'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static CONDITIONAL_NODE__RESULT_NO_INCOMING : number = 244;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'No input pins' of 'Conditional Node'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static CONDITIONAL_NODE__NO_INPUT_PINS : number = 245;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'One clause with executable node' of 'Conditional Node'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static CONDITIONAL_NODE__ONE_CLAUSE_WITH_EXECUTABLE_NODE : number = 246;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Matching output pins' of 'Conditional Node'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static CONDITIONAL_NODE__MATCHING_OUTPUT_PINS : number = 247;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Executable nodes' of 'Conditional Node'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static CONDITIONAL_NODE__EXECUTABLE_NODES : number = 248;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Clause no predecessor' of 'Conditional Node'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static CONDITIONAL_NODE__CLAUSE_NO_PREDECESSOR : number = 249;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Association not abstract' of 'Create Link Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static CREATE_LINK_ACTION__ASSOCIATION_NOT_ABSTRACT : number = 250;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Insert At pin' of 'Link End Creation Data'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static LINK_END_CREATION_DATA__INSERT_AT_PIN : number = 251;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Multiplicity' of 'Create Link Object Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static CREATE_LINK_OBJECT_ACTION__MULTIPLICITY : number = 252;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Type of result' of 'Create Link Object Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static CREATE_LINK_OBJECT_ACTION__TYPE_OF_RESULT : number = 253;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Association class' of 'Create Link Object Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static CREATE_LINK_OBJECT_ACTION__ASSOCIATION_CLASS : number = 254;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Classifier not abstract' of 'Create Object Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static CREATE_OBJECT_ACTION__CLASSIFIER_NOT_ABSTRACT : number = 255;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Multiplicity' of 'Create Object Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static CREATE_OBJECT_ACTION__MULTIPLICITY : number = 256;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Classifier not association class' of 'Create Object Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static CREATE_OBJECT_ACTION__CLASSIFIER_NOT_ASSOCIATION_CLASS : number = 257;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Same type' of 'Create Object Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static CREATE_OBJECT_ACTION__SAME_TYPE : number = 258;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Destroy At pin' of 'Link End Destruction Data'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static LINK_END_DESTRUCTION_DATA__DESTROY_AT_PIN : number = 259;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Multiplicity' of 'Destroy Object Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static DESTROY_OBJECT_ACTION__MULTIPLICITY : number = 260;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'No type' of 'Destroy Object Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static DESTROY_OBJECT_ACTION__NO_TYPE : number = 261;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Region as input or output' of 'Expansion Node'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static EXPANSION_NODE__REGION_AS_INPUT_OR_OUTPUT : number = 262;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Result no incoming' of 'Loop Node'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static LOOP_NODE__RESULT_NO_INCOMING : number = 263;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Input edges' of 'Loop Node'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static LOOP_NODE__INPUT_EDGES : number = 264;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Executable nodes' of 'Loop Node'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static LOOP_NODE__EXECUTABLE_NODES : number = 265;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Body output pins' of 'Loop Node'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static LOOP_NODE__BODY_OUTPUT_PINS : number = 266;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Setup test and body' of 'Loop Node'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static LOOP_NODE__SETUP_TEST_AND_BODY : number = 267;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Matching output pins' of 'Loop Node'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static LOOP_NODE__MATCHING_OUTPUT_PINS : number = 268;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Matching loop variables' of 'Loop Node'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static LOOP_NODE__MATCHING_LOOP_VARIABLES : number = 269;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Matching result pins' of 'Loop Node'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static LOOP_NODE__MATCHING_RESULT_PINS : number = 270;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Loop variable outgoing' of 'Loop Node'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static LOOP_NODE__LOOP_VARIABLE_OUTGOING : number = 271;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Language body size' of 'Opaque Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static OPAQUE_ACTION__LANGUAGE_BODY_SIZE : number = 272;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Type is classifier' of 'Read Extent Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static READ_EXTENT_ACTION__TYPE_IS_CLASSIFIER : number = 273;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Multiplicity of result' of 'Read Extent Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static READ_EXTENT_ACTION__MULTIPLICITY_OF_RESULT : number = 274;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'No type' of 'Read Is Classified Object Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static READ_IS_CLASSIFIED_OBJECT_ACTION__NO_TYPE : number = 275;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Multiplicity of output' of 'Read Is Classified Object Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static READ_IS_CLASSIFIED_OBJECT_ACTION__MULTIPLICITY_OF_OUTPUT : number = 276;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Boolean result' of 'Read Is Classified Object Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static READ_IS_CLASSIFIED_OBJECT_ACTION__BOOLEAN_RESULT : number = 277;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Multiplicity of input' of 'Read Is Classified Object Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static READ_IS_CLASSIFIED_OBJECT_ACTION__MULTIPLICITY_OF_INPUT : number = 278;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Type and ordering' of 'Read Link Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static READ_LINK_ACTION__TYPE_AND_ORDERING : number = 279;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Compatible multiplicity' of 'Read Link Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static READ_LINK_ACTION__COMPATIBLE_MULTIPLICITY : number = 280;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Visibility' of 'Read Link Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static READ_LINK_ACTION__VISIBILITY : number = 281;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'One open end' of 'Read Link Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static READ_LINK_ACTION__ONE_OPEN_END : number = 282;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Navigable open end' of 'Read Link Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static READ_LINK_ACTION__NAVIGABLE_OPEN_END : number = 283;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Property' of 'Read Link Object End Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static READ_LINK_OBJECT_END_ACTION__PROPERTY : number = 284;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Multiplicity of object' of 'Read Link Object End Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static READ_LINK_OBJECT_END_ACTION__MULTIPLICITY_OF_OBJECT : number = 285;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Ends of association' of 'Read Link Object End Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static READ_LINK_OBJECT_END_ACTION__ENDS_OF_ASSOCIATION : number = 286;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Type of result' of 'Read Link Object End Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static READ_LINK_OBJECT_END_ACTION__TYPE_OF_RESULT : number = 287;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Multiplicity of result' of 'Read Link Object End Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static READ_LINK_OBJECT_END_ACTION__MULTIPLICITY_OF_RESULT : number = 288;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Type of object' of 'Read Link Object End Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static READ_LINK_OBJECT_END_ACTION__TYPE_OF_OBJECT : number = 289;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Association of association' of 'Read Link Object End Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static READ_LINK_OBJECT_END_ACTION__ASSOCIATION_OF_ASSOCIATION : number = 290;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Multiplicity of object' of 'Read Link Object End Qualifier Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static READ_LINK_OBJECT_END_QUALIFIER_ACTION__MULTIPLICITY_OF_OBJECT : number = 291;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Type of object' of 'Read Link Object End Qualifier Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static READ_LINK_OBJECT_END_QUALIFIER_ACTION__TYPE_OF_OBJECT : number = 292;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Multiplicity of qualifier' of 'Read Link Object End Qualifier Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static READ_LINK_OBJECT_END_QUALIFIER_ACTION__MULTIPLICITY_OF_QUALIFIER : number = 293;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Ends of association' of 'Read Link Object End Qualifier Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static READ_LINK_OBJECT_END_QUALIFIER_ACTION__ENDS_OF_ASSOCIATION : number = 294;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Multiplicity of result' of 'Read Link Object End Qualifier Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static READ_LINK_OBJECT_END_QUALIFIER_ACTION__MULTIPLICITY_OF_RESULT : number = 295;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Same type' of 'Read Link Object End Qualifier Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static READ_LINK_OBJECT_END_QUALIFIER_ACTION__SAME_TYPE : number = 296;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Association of association' of 'Read Link Object End Qualifier Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static READ_LINK_OBJECT_END_QUALIFIER_ACTION__ASSOCIATION_OF_ASSOCIATION : number = 297;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Qualifier attribute' of 'Read Link Object End Qualifier Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static READ_LINK_OBJECT_END_QUALIFIER_ACTION__QUALIFIER_ATTRIBUTE : number = 298;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Contained' of 'Read Self Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static READ_SELF_ACTION__CONTAINED : number = 299;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Multiplicity' of 'Read Self Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static READ_SELF_ACTION__MULTIPLICITY : number = 300;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Not static' of 'Read Self Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static READ_SELF_ACTION__NOT_STATIC : number = 301;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Type' of 'Read Self Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static READ_SELF_ACTION__TYPE : number = 302;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Type and ordering' of 'Read Structural Feature Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static READ_STRUCTURAL_FEATURE_ACTION__TYPE_AND_ORDERING : number = 303;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Type and ordering' of 'Read Variable Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static READ_VARIABLE_ACTION__TYPE_AND_ORDERING : number = 304;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Compatible multiplicity' of 'Read Variable Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static READ_VARIABLE_ACTION__COMPATIBLE_MULTIPLICITY : number = 305;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Input pin' of 'Reclassify Object Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static RECLASSIFY_OBJECT_ACTION__INPUT_PIN : number = 306;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Classifier not abstract' of 'Reclassify Object Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static RECLASSIFY_OBJECT_ACTION__CLASSIFIER_NOT_ABSTRACT : number = 307;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Multiplicity' of 'Reclassify Object Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static RECLASSIFY_OBJECT_ACTION__MULTIPLICITY : number = 308;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Reducer inputs output' of 'Reduce Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static REDUCE_ACTION__REDUCER_INPUTS_OUTPUT : number = 309;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Input type is collection' of 'Reduce Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static REDUCE_ACTION__INPUT_TYPE_IS_COLLECTION : number = 310;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Output types are compatible' of 'Reduce Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static REDUCE_ACTION__OUTPUT_TYPES_ARE_COMPATIBLE : number = 311;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Remove At and value' of 'Remove Structural Feature Value Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static REMOVE_STRUCTURAL_FEATURE_VALUE_ACTION__REMOVE_AT_AND_VALUE : number = 312;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Remove At and value' of 'Remove Variable Value Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static REMOVE_VARIABLE_VALUE_ACTION__REMOVE_AT_AND_VALUE : number = 313;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Pins match parameter' of 'Reply Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static REPLY_ACTION__PINS_MATCH_PARAMETER : number = 314;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Event on reply to call trigger' of 'Reply Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static REPLY_ACTION__EVENT_ON_REPLY_TO_CALL_TRIGGER : number = 315;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Type target pin' of 'Send Object Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static SEND_OBJECT_ACTION__TYPE_TARGET_PIN : number = 316;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Type ordering multiplicity' of 'Send Signal Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static SEND_SIGNAL_ACTION__TYPE_ORDERING_MULTIPLICITY : number = 317;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Number order' of 'Send Signal Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static SEND_SIGNAL_ACTION__NUMBER_ORDER : number = 318;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Type target pin' of 'Send Signal Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static SEND_SIGNAL_ACTION__TYPE_TARGET_PIN : number = 319;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Multiplicity' of 'Start Classifier Behavior Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static START_CLASSIFIER_BEHAVIOR_ACTION__MULTIPLICITY : number = 320;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Type has classifier' of 'Start Classifier Behavior Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static START_CLASSIFIER_BEHAVIOR_ACTION__TYPE_HAS_CLASSIFIER : number = 321;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Multiplicity of object' of 'Start Object Behavior Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static START_OBJECT_BEHAVIOR_ACTION__MULTIPLICITY_OF_OBJECT : number = 322;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Type of object' of 'Start Object Behavior Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static START_OBJECT_BEHAVIOR_ACTION__TYPE_OF_OBJECT : number = 323;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'No onport' of 'Start Object Behavior Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static START_OBJECT_BEHAVIOR_ACTION__NO_ONPORT : number = 324;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Multiplicity' of 'Test Identity Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static TEST_IDENTITY_ACTION__MULTIPLICITY : number = 325;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'No type' of 'Test Identity Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static TEST_IDENTITY_ACTION__NO_TYPE : number = 326;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Result is boolean' of 'Test Identity Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static TEST_IDENTITY_ACTION__RESULT_IS_BOOLEAN : number = 327;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Structural feature' of 'Unmarshall Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static UNMARSHALL_ACTION__STRUCTURAL_FEATURE : number = 328;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Number of result' of 'Unmarshall Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static UNMARSHALL_ACTION__NUMBER_OF_RESULT : number = 329;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Type ordering and multiplicity' of 'Unmarshall Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static UNMARSHALL_ACTION__TYPE_ORDERING_AND_MULTIPLICITY : number = 330;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Multiplicity of object' of 'Unmarshall Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static UNMARSHALL_ACTION__MULTIPLICITY_OF_OBJECT : number = 331;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Object type' of 'Unmarshall Action'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static UNMARSHALL_ACTION__OBJECT_TYPE : number = 332;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'No incoming edges' of 'Value Pin'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static VALUE_PIN__NO_INCOMING_EDGES : number = 333;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Compatible type' of 'Value Pin'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static VALUE_PIN__COMPATIBLE_TYPE : number = 334;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'No outgoing edges' of 'Final Node'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static FINAL_NODE__NO_OUTGOING_EDGES : number = 335;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'No outgoing edges' of 'Activity Parameter Node'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static ACTIVITY_PARAMETER_NODE__NO_OUTGOING_EDGES : number = 336;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Has parameters' of 'Activity Parameter Node'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static ACTIVITY_PARAMETER_NODE__HAS_PARAMETERS : number = 337;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Same type' of 'Activity Parameter Node'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static ACTIVITY_PARAMETER_NODE__SAME_TYPE : number = 338;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'No incoming edges' of 'Activity Parameter Node'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static ACTIVITY_PARAMETER_NODE__NO_INCOMING_EDGES : number = 339;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'No edges' of 'Activity Parameter Node'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static ACTIVITY_PARAMETER_NODE__NO_EDGES : number = 340;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Object nodes' of 'Control Flow'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static CONTROL_FLOW__OBJECT_NODES : number = 341;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Zero input parameters' of 'Decision Node'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static DECISION_NODE__ZERO_INPUT_PARAMETERS : number = 342;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Edges' of 'Decision Node'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static DECISION_NODE__EDGES : number = 343;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Decision input flow incoming' of 'Decision Node'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static DECISION_NODE__DECISION_INPUT_FLOW_INCOMING : number = 344;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Two input parameters' of 'Decision Node'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static DECISION_NODE__TWO_INPUT_PARAMETERS : number = 345;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Incoming outgoing edges' of 'Decision Node'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static DECISION_NODE__INCOMING_OUTGOING_EDGES : number = 346;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Incoming control one input parameter' of 'Decision Node'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static DECISION_NODE__INCOMING_CONTROL_ONE_INPUT_PARAMETER : number = 347;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Parameters' of 'Decision Node'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static DECISION_NODE__PARAMETERS : number = 348;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Incoming object one input parameter' of 'Decision Node'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static DECISION_NODE__INCOMING_OBJECT_ONE_INPUT_PARAMETER : number = 349;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Input and output parameter' of 'Object Flow'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static OBJECT_FLOW__INPUT_AND_OUTPUT_PARAMETER : number = 350;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'No executable nodes' of 'Object Flow'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static OBJECT_FLOW__NO_EXECUTABLE_NODES : number = 351;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Transformation behavior' of 'Object Flow'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static OBJECT_FLOW__TRANSFORMATION_BEHAVIOR : number = 352;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Selection behavior' of 'Object Flow'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static OBJECT_FLOW__SELECTION_BEHAVIOR : number = 353;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Compatible types' of 'Object Flow'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static OBJECT_FLOW__COMPATIBLE_TYPES : number = 354;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Same upper bounds' of 'Object Flow'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static OBJECT_FLOW__SAME_UPPER_BOUNDS : number = 355;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Target' of 'Object Flow'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static OBJECT_FLOW__TARGET : number = 356;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Is multicast or is multireceive' of 'Object Flow'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static OBJECT_FLOW__IS_MULTICAST_OR_IS_MULTIRECEIVE : number = 357;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Edges' of 'Fork Node'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static FORK_NODE__EDGES : number = 358;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'One incoming edge' of 'Fork Node'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static FORK_NODE__ONE_INCOMING_EDGE : number = 359;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'No incoming edges' of 'Initial Node'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static INITIAL_NODE__NO_INCOMING_EDGES : number = 360;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Control edges' of 'Initial Node'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static INITIAL_NODE__CONTROL_EDGES : number = 361;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'One outgoing edge' of 'Join Node'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static JOIN_NODE__ONE_OUTGOING_EDGE : number = 362;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Incoming object flow' of 'Join Node'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static JOIN_NODE__INCOMING_OBJECT_FLOW : number = 363;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'One outgoing edge' of 'Merge Node'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static MERGE_NODE__ONE_OUTGOING_EDGE : number = 364;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Edges' of 'Merge Node'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static MERGE_NODE__EDGES : number = 365;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'One output parameter' of 'Function Behavior'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static FUNCTION_BEHAVIOR__ONE_OUTPUT_PARAMETER : number = 366;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Types of parameters' of 'Function Behavior'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static FUNCTION_BEHAVIOR__TYPES_OF_PARAMETERS : number = 367;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'When non negative' of 'Time Event'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static TIME_EVENT__WHEN_NON_NEGATIVE : number = 368;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'No expr requires observation' of 'Time Expression'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static TIME_EXPRESSION__NO_EXPR_REQUIRES_OBSERVATION : number = 369;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Internal structure' of 'Node'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static NODE__INTERNAL_STRUCTURE : number = 370;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Must conform' of 'Information Flow'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static INFORMATION_FLOW__MUST_CONFORM : number = 371;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Sources and targets kind' of 'Information Flow'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static INFORMATION_FLOW__SOURCES_AND_TARGETS_KIND : number = 372;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Convey classifiers' of 'Information Flow'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static INFORMATION_FLOW__CONVEY_CLASSIFIERS : number = 373;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Sending receiving message event' of 'Message'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static MESSAGE__SENDING_RECEIVING_MESSAGE_EVENT : number = 374;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Arguments' of 'Message'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static MESSAGE__ARGUMENTS : number = 375;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Cannot cross boundaries' of 'Message'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static MESSAGE__CANNOT_CROSS_BOUNDARIES : number = 376;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Signature is signal' of 'Message'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static MESSAGE__SIGNATURE_IS_SIGNAL : number = 377;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Occurrence specifications' of 'Message'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static MESSAGE__OCCURRENCE_SPECIFICATIONS : number = 378;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Signature refer to' of 'Message'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static MESSAGE__SIGNATURE_REFER_TO : number = 379;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Signature is operation request' of 'Message'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static MESSAGE__SIGNATURE_IS_OPERATION_REQUEST : number = 380;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Signature is operation reply' of 'Message'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static MESSAGE__SIGNATURE_IS_OPERATION_REPLY : number = 381;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Not contained' of 'Interaction'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static INTERACTION__NOT_CONTAINED : number = 382;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Selector specified' of 'Lifeline'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static LIFELINE__SELECTOR_SPECIFIED : number = 383;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Interaction uses share lifeline' of 'Lifeline'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static LIFELINE__INTERACTION_USES_SHARE_LIFELINE : number = 384;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Same classifier' of 'Lifeline'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static LIFELINE__SAME_CLASSIFIER : number = 385;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Selector int or string' of 'Lifeline'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static LIFELINE__SELECTOR_INT_OR_STRING : number = 386;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Commutativity of decomposition' of 'Part Decomposition'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static PART_DECOMPOSITION__COMMUTATIVITY_OF_DECOMPOSITION : number = 387;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Assume' of 'Part Decomposition'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static PART_DECOMPOSITION__ASSUME : number = 388;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Parts of internal structures' of 'Part Decomposition'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static PART_DECOMPOSITION__PARTS_OF_INTERNAL_STRUCTURES : number = 389;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Gates match' of 'Interaction Use'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static INTERACTION_USE__GATES_MATCH : number = 390;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Arguments are constants' of 'Interaction Use'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static INTERACTION_USE__ARGUMENTS_ARE_CONSTANTS : number = 391;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Return Value Recipient coverage' of 'Interaction Use'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static INTERACTION_USE__RETURN_VALUE_RECIPIENT_COVERAGE : number = 392;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Arguments correspond to parameters' of 'Interaction Use'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static INTERACTION_USE__ARGUMENTS_CORRESPOND_TO_PARAMETERS : number = 393;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Return Value type recipient correspondence' of 'Interaction Use'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static INTERACTION_USE__RETURN_VALUE_TYPE_RECIPIENT_CORRESPONDENCE : number = 394;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'All lifelines' of 'Interaction Use'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static INTERACTION_USE__ALL_LIFELINES : number = 395;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Actual gate matched' of 'Gate'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static GATE__ACTUAL_GATE_MATCHED : number = 396;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Inside cf matched' of 'Gate'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static GATE__INSIDE_CF_MATCHED : number = 397;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Outside cf matched' of 'Gate'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static GATE__OUTSIDE_CF_MATCHED : number = 398;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Formal gate distinguishable' of 'Gate'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static GATE__FORMAL_GATE_DISTINGUISHABLE : number = 399;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Actual gate distinguishable' of 'Gate'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static GATE__ACTUAL_GATE_DISTINGUISHABLE : number = 400;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Outside cf gate distinguishable' of 'Gate'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static GATE__OUTSIDE_CF_GATE_DISTINGUISHABLE : number = 401;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Inside cf gate distinguishable' of 'Gate'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static GATE__INSIDE_CF_GATE_DISTINGUISHABLE : number = 402;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Guard contain references' of 'Interaction Operand'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static INTERACTION_OPERAND__GUARD_CONTAIN_REFERENCES : number = 403;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Guard directly prior' of 'Interaction Operand'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static INTERACTION_OPERAND__GUARD_DIRECTLY_PRIOR : number = 404;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Minint maxint' of 'Interaction Constraint'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static INTERACTION_CONSTRAINT__MININT_MAXINT : number = 405;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Minint non negative' of 'Interaction Constraint'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static INTERACTION_CONSTRAINT__MININT_NON_NEGATIVE : number = 406;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Maxint positive' of 'Interaction Constraint'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static INTERACTION_CONSTRAINT__MAXINT_POSITIVE : number = 407;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Dynamic variables' of 'Interaction Constraint'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static INTERACTION_CONSTRAINT__DYNAMIC_VARIABLES : number = 408;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Global data' of 'Interaction Constraint'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static INTERACTION_CONSTRAINT__GLOBAL_DATA : number = 409;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Maxint greater equal minint' of 'Interaction Constraint'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static INTERACTION_CONSTRAINT__MAXINT_GREATER_EQUAL_MININT : number = 410;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Irreflexive transitive closure' of 'General Ordering'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static GENERAL_ORDERING__IRREFLEXIVE_TRANSITIVE_CLOSURE : number = 411;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Sources and targets' of 'Information Item'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static INFORMATION_ITEM__SOURCES_AND_TARGETS : number = 412;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Has no' of 'Information Item'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static INFORMATION_ITEM__HAS_NO : number = 413;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Not instantiable' of 'Information Item'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static INFORMATION_ITEM__NOT_INSTANTIABLE : number = 414;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Action referenced' of 'Action Execution Specification'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static ACTION_EXECUTION_SPECIFICATION__ACTION_REFERENCED : number = 415;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Same lifeline' of 'Execution Specification'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static EXECUTION_SPECIFICATION__SAME_LIFELINE : number = 416;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Break ' of 'Combined Fragment'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static COMBINED_FRAGMENT__BREAK_ : number = 417;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Consider and ignore' of 'Combined Fragment'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static COMBINED_FRAGMENT__CONSIDER_AND_IGNORE : number = 418;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Opt loop break neg' of 'Combined Fragment'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static COMBINED_FRAGMENT__OPT_LOOP_BREAK_NEG : number = 419;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Consider or ignore' of 'Consider Ignore Fragment'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static CONSIDER_IGNORE_FRAGMENT__CONSIDER_OR_IGNORE : number = 420;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Type' of 'Consider Ignore Fragment'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static CONSIDER_IGNORE_FRAGMENT__TYPE : number = 421;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'First or last interaction fragment' of 'Continuation'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static CONTINUATION__FIRST_OR_LAST_INTERACTION_FRAGMENT : number = 422;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Same name' of 'Continuation'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static CONTINUATION__SAME_NAME : number = 423;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Global' of 'Continuation'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static CONTINUATION__GLOBAL : number = 424;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'No occurrence specifications below' of 'Destruction Occurrence Specification'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static DESTRUCTION_OCCURRENCE_SPECIFICATION__NO_OCCURRENCE_SPECIFICATIONS_BELOW : number = 425;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'No exit behavior' of 'Final State'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static FINAL_STATE__NO_EXIT_BEHAVIOR : number = 426;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'No outgoing transitions' of 'Final State'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static FINAL_STATE__NO_OUTGOING_TRANSITIONS : number = 427;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'No regions' of 'Final State'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static FINAL_STATE__NO_REGIONS : number = 428;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Cannot reference submachine' of 'Final State'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static FINAL_STATE__CANNOT_REFERENCE_SUBMACHINE : number = 429;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'No entry behavior' of 'Final State'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static FINAL_STATE__NO_ENTRY_BEHAVIOR : number = 430;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'No state behavior' of 'Final State'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static FINAL_STATE__NO_STATE_BEHAVIOR : number = 431;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Refers to operation' of 'Protocol Transition'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static PROTOCOL_TRANSITION__REFERS_TO_OPERATION : number = 432;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Associated actions' of 'Protocol Transition'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static PROTOCOL_TRANSITION__ASSOCIATED_ACTIONS : number = 433;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Belongs to psm' of 'Protocol Transition'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static PROTOCOL_TRANSITION__BELONGS_TO_PSM : number = 434;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Cannot be defined' of 'Association Class'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static ASSOCIATION_CLASS__CANNOT_BE_DEFINED : number = 435;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Disjoint attributes ends' of 'Association Class'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static ASSOCIATION_CLASS__DISJOINT_ATTRIBUTES_ENDS : number = 436;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'No nested classifiers' of 'Component'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static COMPONENT__NO_NESTED_CLASSIFIERS : number = 437;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'No packaged elements' of 'Component'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static COMPONENT__NO_PACKAGED_ELEMENTS : number = 438;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Associations' of 'Actor'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static ACTOR__ASSOCIATIONS : number = 439;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Must have name' of 'Actor'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static ACTOR__MUST_HAVE_NAME : number = 440;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'No expr requires observation' of 'Duration'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static DURATION__NO_EXPR_REQUIRES_OBSERVATION : number = 441;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'First event multiplicity' of 'Duration Constraint'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static DURATION_CONSTRAINT__FIRST_EVENT_MULTIPLICITY : number = 442;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Has one or two constrained Elements' of 'Duration Constraint'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static DURATION_CONSTRAINT__HAS_ONE_OR_TWO_CONSTRAINED_ELEMENTS : number = 443;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'First event multiplicity' of 'Duration Observation'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static DURATION_OBSERVATION__FIRST_EVENT_MULTIPLICITY : number = 444;

        /**
         * The {@link org.eclipse.emf.common.util.Diagnostic#getCode() code} for constraint 'Has one constrained Element' of 'Time Constraint'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        public static TIME_CONSTRAINT__HAS_ONE_CONSTRAINED_ELEMENT : number = 445;

        /**
         * A constant with a fixed name that can be used as the base value for additional hand written constants.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        static GENERATED_DIAGNOSTIC_CODE_COUNT : number = 445;

        /**
         * A constant with a fixed name that can be used as the base value for additional hand written constants in a derived class.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         */
        static DIAGNOSTIC_CODE_COUNT : number; public static DIAGNOSTIC_CODE_COUNT_$LI$() : number { if(UmlValidator.DIAGNOSTIC_CODE_COUNT == null) UmlValidator.DIAGNOSTIC_CODE_COUNT = UmlValidator.GENERATED_DIAGNOSTIC_CODE_COUNT; return UmlValidator.DIAGNOSTIC_CODE_COUNT; };

        public constructor() {
            super();
        }

        /**
         * Returns the package of this validator switch.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @return {*}
         */
        getEPackage() : org.eclipse.emf.ecore.EPackage {
            return uml.UmlPackage.eINSTANCE;
        }

        /**
         * Calls <code>validateXXX</code> for the corresponding classifier of the model.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {number} classifierID
         * @param {*} value
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        validate(classifierID : number, value : any, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            switch((classifierID)) {
            case uml.UmlPackage.ACTIVITY_CONTENT:
                return this.validateActivityContent(<uml.ActivityContent><any>value, diagnostics, context);
            case uml.UmlPackage.ACTIVITY:
                return this.validateActivity(<uml.Activity><any>value, diagnostics, context);
            case uml.UmlPackage.BEHAVIOR:
                return this.validateBehavior(<uml.Behavior><any>value, diagnostics, context);
            case uml.UmlPackage.CLASS:
                return this.validateClass(<uml.Class><any>value, diagnostics, context);
            case uml.UmlPackage.BEHAVIORED_CLASSIFIER:
                return this.validateBehavioredClassifier(<uml.BehavioredClassifier><any>value, diagnostics, context);
            case uml.UmlPackage.CLASSIFIER:
                return this.validateClassifier(<uml.Classifier><any>value, diagnostics, context);
            case uml.UmlPackage.NAMESPACE:
                return this.validateNamespace(<uml.Namespace><any>value, diagnostics, context);
            case uml.UmlPackage.NAMED_ELEMENT:
                return this.validateNamedElement(<uml.NamedElement><any>value, diagnostics, context);
            case uml.UmlPackage.ELEMENT:
                return this.validateElement(<uml.Element><any>value, diagnostics, context);
            case uml.UmlPackage.COMMENT:
                return this.validateComment(<uml.Comment><any>value, diagnostics, context);
            case uml.UmlPackage.STEREOTYPE:
                return this.validateStereotype(<uml.Stereotype><any>value, diagnostics, context);
            case uml.UmlPackage.IMAGE:
                return this.validateImage(<uml.Image><any>value, diagnostics, context);
            case uml.UmlPackage.PROFILE:
                return this.validateProfile(<uml.Profile><any>value, diagnostics, context);
            case uml.UmlPackage.PACKAGE:
                return this.validatePackage(<uml.Package><any>value, diagnostics, context);
            case uml.UmlPackage.PACKAGEABLE_ELEMENT:
                return this.validatePackageableElement(<uml.PackageableElement><any>value, diagnostics, context);
            case uml.UmlPackage.PARAMETERABLE_ELEMENT:
                return this.validateParameterableElement(<uml.ParameterableElement><any>value, diagnostics, context);
            case uml.UmlPackage.TEMPLATE_PARAMETER:
                return this.validateTemplateParameter(<uml.TemplateParameter><any>value, diagnostics, context);
            case uml.UmlPackage.TEMPLATE_SIGNATURE:
                return this.validateTemplateSignature(<uml.TemplateSignature><any>value, diagnostics, context);
            case uml.UmlPackage.TEMPLATEABLE_ELEMENT:
                return this.validateTemplateableElement(<uml.TemplateableElement><any>value, diagnostics, context);
            case uml.UmlPackage.TEMPLATE_BINDING:
                return this.validateTemplateBinding(<uml.TemplateBinding><any>value, diagnostics, context);
            case uml.UmlPackage.DIRECTED_RELATIONSHIP:
                return this.validateDirectedRelationship(<uml.DirectedRelationship><any>value, diagnostics, context);
            case uml.UmlPackage.RELATIONSHIP:
                return this.validateRelationship(<uml.Relationship><any>value, diagnostics, context);
            case uml.UmlPackage.TEMPLATE_PARAMETER_SUBSTITUTION:
                return this.validateTemplateParameterSubstitution(<uml.TemplateParameterSubstitution><any>value, diagnostics, context);
            case uml.UmlPackage.TYPE:
                return this.validateType(<uml.Type><any>value, diagnostics, context);
            case uml.UmlPackage.ASSOCIATION:
                return this.validateAssociation(<uml.Association><any>value, diagnostics, context);
            case uml.UmlPackage.PROPERTY:
                return this.validateProperty(<uml.Property><any>value, diagnostics, context);
            case uml.UmlPackage.CONNECTABLE_ELEMENT:
                return this.validateConnectableElement(<uml.ConnectableElement><any>value, diagnostics, context);
            case uml.UmlPackage.TYPED_ELEMENT:
                return this.validateTypedElement(<uml.TypedElement><any>value, diagnostics, context);
            case uml.UmlPackage.CONNECTOR_END:
                return this.validateConnectorEnd(<uml.ConnectorEnd><any>value, diagnostics, context);
            case uml.UmlPackage.MULTIPLICITY_ELEMENT:
                return this.validateMultiplicityElement(<uml.MultiplicityElement><any>value, diagnostics, context);
            case uml.UmlPackage.VALUE_SPECIFICATION:
                return this.validateValueSpecification(<uml.ValueSpecification><any>value, diagnostics, context);
            case uml.UmlPackage.CONNECTABLE_ELEMENT_TEMPLATE_PARAMETER:
                return this.validateConnectableElementTemplateParameter(<uml.ConnectableElementTemplateParameter><any>value, diagnostics, context);
            case uml.UmlPackage.DEPLOYMENT_TARGET:
                return this.validateDeploymentTarget(<uml.DeploymentTarget><any>value, diagnostics, context);
            case uml.UmlPackage.DEPLOYMENT:
                return this.validateDeployment(<uml.Deployment><any>value, diagnostics, context);
            case uml.UmlPackage.DEPENDENCY:
                return this.validateDependency(<uml.Dependency><any>value, diagnostics, context);
            case uml.UmlPackage.DEPLOYMENT_SPECIFICATION:
                return this.validateDeploymentSpecification(<uml.DeploymentSpecification><any>value, diagnostics, context);
            case uml.UmlPackage.ARTIFACT:
                return this.validateArtifact(<uml.Artifact><any>value, diagnostics, context);
            case uml.UmlPackage.DEPLOYED_ARTIFACT:
                return this.validateDeployedArtifact(<uml.DeployedArtifact><any>value, diagnostics, context);
            case uml.UmlPackage.MANIFESTATION:
                return this.validateManifestation(<uml.Manifestation><any>value, diagnostics, context);
            case uml.UmlPackage.ABSTRACTION:
                return this.validateAbstraction(<uml.Abstraction><any>value, diagnostics, context);
            case uml.UmlPackage.OPAQUE_EXPRESSION:
                return this.validateOpaqueExpression(<uml.OpaqueExpression><any>value, diagnostics, context);
            case uml.UmlPackage.PARAMETER:
                return this.validateParameter(<uml.Parameter><any>value, diagnostics, context);
            case uml.UmlPackage.OPERATION:
                return this.validateOperation(<uml.Operation><any>value, diagnostics, context);
            case uml.UmlPackage.BEHAVIORAL_FEATURE:
                return this.validateBehavioralFeature(<uml.BehavioralFeature><any>value, diagnostics, context);
            case uml.UmlPackage.FEATURE:
                return this.validateFeature(<uml.Feature><any>value, diagnostics, context);
            case uml.UmlPackage.REDEFINABLE_ELEMENT:
                return this.validateRedefinableElement(<uml.RedefinableElement><any>value, diagnostics, context);
            case uml.UmlPackage.PARAMETER_SET:
                return this.validateParameterSet(<uml.ParameterSet><any>value, diagnostics, context);
            case uml.UmlPackage.CONSTRAINT:
                return this.validateConstraint(<uml.Constraint><any>value, diagnostics, context);
            case uml.UmlPackage.DATA_TYPE:
                return this.validateDataType(<uml.DataType><any>value, diagnostics, context);
            case uml.UmlPackage.INTERFACE:
                return this.validateInterface(<uml.Interface><any>value, diagnostics, context);
            case uml.UmlPackage.RECEPTION:
                return this.validateReception(<uml.Reception><any>value, diagnostics, context);
            case uml.UmlPackage.SIGNAL:
                return this.validateSignal(<uml.Signal><any>value, diagnostics, context);
            case uml.UmlPackage.PROTOCOL_STATE_MACHINE:
                return this.validateProtocolStateMachine(<uml.ProtocolStateMachine><any>value, diagnostics, context);
            case uml.UmlPackage.STATE_MACHINE:
                return this.validateStateMachine(<uml.StateMachine><any>value, diagnostics, context);
            case uml.UmlPackage.PSEUDOSTATE:
                return this.validatePseudostate(<uml.Pseudostate><any>value, diagnostics, context);
            case uml.UmlPackage.VERTEX:
                return this.validateVertex(<uml.Vertex><any>value, diagnostics, context);
            case uml.UmlPackage.REGION:
                return this.validateRegion(<uml.Region><any>value, diagnostics, context);
            case uml.UmlPackage.STATE:
                return this.validateState(<uml.State><any>value, diagnostics, context);
            case uml.UmlPackage.CONNECTION_POINT_REFERENCE:
                return this.validateConnectionPointReference(<uml.ConnectionPointReference><any>value, diagnostics, context);
            case uml.UmlPackage.TRIGGER:
                return this.validateTrigger(<uml.Trigger><any>value, diagnostics, context);
            case uml.UmlPackage.EVENT:
                return this.validateEvent(<uml.Event><any>value, diagnostics, context);
            case uml.UmlPackage.PORT:
                return this.validatePort(<uml.Port><any>value, diagnostics, context);
            case uml.UmlPackage.TRANSITION:
                return this.validateTransition(<uml.Transition><any>value, diagnostics, context);
            case uml.UmlPackage.PROTOCOL_CONFORMANCE:
                return this.validateProtocolConformance(<uml.ProtocolConformance><any>value, diagnostics, context);
            case uml.UmlPackage.OPERATION_TEMPLATE_PARAMETER:
                return this.validateOperationTemplateParameter(<uml.OperationTemplateParameter><any>value, diagnostics, context);
            case uml.UmlPackage.STRUCTURAL_FEATURE:
                return this.validateStructuralFeature(<uml.StructuralFeature><any>value, diagnostics, context);
            case uml.UmlPackage.PACKAGE_MERGE:
                return this.validatePackageMerge(<uml.PackageMerge><any>value, diagnostics, context);
            case uml.UmlPackage.PROFILE_APPLICATION:
                return this.validateProfileApplication(<uml.ProfileApplication><any>value, diagnostics, context);
            case uml.UmlPackage.ENUMERATION:
                return this.validateEnumeration(<uml.Enumeration><any>value, diagnostics, context);
            case uml.UmlPackage.ENUMERATION_LITERAL:
                return this.validateEnumerationLiteral(<uml.EnumerationLiteral><any>value, diagnostics, context);
            case uml.UmlPackage.INSTANCE_SPECIFICATION:
                return this.validateInstanceSpecification(<uml.InstanceSpecification><any>value, diagnostics, context);
            case uml.UmlPackage.SLOT:
                return this.validateSlot(<uml.Slot><any>value, diagnostics, context);
            case uml.UmlPackage.PRIMITIVE_TYPE:
                return this.validatePrimitiveType(<uml.PrimitiveType><any>value, diagnostics, context);
            case uml.UmlPackage.ELEMENT_IMPORT:
                return this.validateElementImport(<uml.ElementImport><any>value, diagnostics, context);
            case uml.UmlPackage.PACKAGE_IMPORT:
                return this.validatePackageImport(<uml.PackageImport><any>value, diagnostics, context);
            case uml.UmlPackage.EXTENSION:
                return this.validateExtension(<uml.Extension><any>value, diagnostics, context);
            case uml.UmlPackage.EXTENSION_END:
                return this.validateExtensionEnd(<uml.ExtensionEnd><any>value, diagnostics, context);
            case uml.UmlPackage.MODEL:
                return this.validateModel(<uml.Model><any>value, diagnostics, context);
            case uml.UmlPackage.STRING_EXPRESSION:
                return this.validateStringExpression(<uml.StringExpression><any>value, diagnostics, context);
            case uml.UmlPackage.EXPRESSION:
                return this.validateExpression(<uml.Expression><any>value, diagnostics, context);
            case uml.UmlPackage.USAGE:
                return this.validateUsage(<uml.Usage><any>value, diagnostics, context);
            case uml.UmlPackage.COLLABORATION_USE:
                return this.validateCollaborationUse(<uml.CollaborationUse><any>value, diagnostics, context);
            case uml.UmlPackage.COLLABORATION:
                return this.validateCollaboration(<uml.Collaboration><any>value, diagnostics, context);
            case uml.UmlPackage.STRUCTURED_CLASSIFIER:
                return this.validateStructuredClassifier(<uml.StructuredClassifier><any>value, diagnostics, context);
            case uml.UmlPackage.CONNECTOR:
                return this.validateConnector(<uml.Connector><any>value, diagnostics, context);
            case uml.UmlPackage.GENERALIZATION:
                return this.validateGeneralization(<uml.Generalization><any>value, diagnostics, context);
            case uml.UmlPackage.GENERALIZATION_SET:
                return this.validateGeneralizationSet(<uml.GeneralizationSet><any>value, diagnostics, context);
            case uml.UmlPackage.REDEFINABLE_TEMPLATE_SIGNATURE:
                return this.validateRedefinableTemplateSignature(<uml.RedefinableTemplateSignature><any>value, diagnostics, context);
            case uml.UmlPackage.USE_CASE:
                return this.validateUseCase(<uml.UseCase><any>value, diagnostics, context);
            case uml.UmlPackage.EXTEND:
                return this.validateExtend(<uml.Extend><any>value, diagnostics, context);
            case uml.UmlPackage.EXTENSION_POINT:
                return this.validateExtensionPoint(<uml.ExtensionPoint><any>value, diagnostics, context);
            case uml.UmlPackage.INCLUDE:
                return this.validateInclude(<uml.Include><any>value, diagnostics, context);
            case uml.UmlPackage.SUBSTITUTION:
                return this.validateSubstitution(<uml.Substitution><any>value, diagnostics, context);
            case uml.UmlPackage.REALIZATION:
                return this.validateRealization(<uml.Realization><any>value, diagnostics, context);
            case uml.UmlPackage.CLASSIFIER_TEMPLATE_PARAMETER:
                return this.validateClassifierTemplateParameter(<uml.ClassifierTemplateParameter><any>value, diagnostics, context);
            case uml.UmlPackage.INTERFACE_REALIZATION:
                return this.validateInterfaceRealization(<uml.InterfaceRealization><any>value, diagnostics, context);
            case uml.UmlPackage.ENCAPSULATED_CLASSIFIER:
                return this.validateEncapsulatedClassifier(<uml.EncapsulatedClassifier><any>value, diagnostics, context);
            case uml.UmlPackage.ACTIVITY_GROUP:
                return this.validateActivityGroup(<uml.ActivityGroup><any>value, diagnostics, context);
            case uml.UmlPackage.ACTIVITY_EDGE:
                return this.validateActivityEdge(<uml.ActivityEdge><any>value, diagnostics, context);
            case uml.UmlPackage.ACTIVITY_PARTITION:
                return this.validateActivityPartition(<uml.ActivityPartition><any>value, diagnostics, context);
            case uml.UmlPackage.ACTIVITY_NODE:
                return this.validateActivityNode(<uml.ActivityNode><any>value, diagnostics, context);
            case uml.UmlPackage.INTERRUPTIBLE_ACTIVITY_REGION:
                return this.validateInterruptibleActivityRegion(<uml.InterruptibleActivityRegion><any>value, diagnostics, context);
            case uml.UmlPackage.STRUCTURED_ACTIVITY_NODE:
                return this.validateStructuredActivityNode(<uml.StructuredActivityNode><any>value, diagnostics, context);
            case uml.UmlPackage.ACTION:
                return this.validateAction(<uml.Action><any>value, diagnostics, context);
            case uml.UmlPackage.EXECUTABLE_NODE:
                return this.validateExecutableNode(<uml.ExecutableNode><any>value, diagnostics, context);
            case uml.UmlPackage.EXCEPTION_HANDLER:
                return this.validateExceptionHandler(<uml.ExceptionHandler><any>value, diagnostics, context);
            case uml.UmlPackage.OBJECT_NODE:
                return this.validateObjectNode(<uml.ObjectNode><any>value, diagnostics, context);
            case uml.UmlPackage.INPUT_PIN:
                return this.validateInputPin(<uml.InputPin><any>value, diagnostics, context);
            case uml.UmlPackage.PIN:
                return this.validatePin(<uml.Pin><any>value, diagnostics, context);
            case uml.UmlPackage.OUTPUT_PIN:
                return this.validateOutputPin(<uml.OutputPin><any>value, diagnostics, context);
            case uml.UmlPackage.VARIABLE:
                return this.validateVariable(<uml.Variable><any>value, diagnostics, context);
            case uml.UmlPackage.VALUE_SPECIFICATION_ACTION:
                return this.validateValueSpecificationAction(<uml.ValueSpecificationAction><any>value, diagnostics, context);
            case uml.UmlPackage.VARIABLE_ACTION:
                return this.validateVariableAction(<uml.VariableAction><any>value, diagnostics, context);
            case uml.UmlPackage.WRITE_LINK_ACTION:
                return this.validateWriteLinkAction(<uml.WriteLinkAction><any>value, diagnostics, context);
            case uml.UmlPackage.LINK_ACTION:
                return this.validateLinkAction(<uml.LinkAction><any>value, diagnostics, context);
            case uml.UmlPackage.LINK_END_DATA:
                return this.validateLinkEndData(<uml.LinkEndData><any>value, diagnostics, context);
            case uml.UmlPackage.QUALIFIER_VALUE:
                return this.validateQualifierValue(<uml.QualifierValue><any>value, diagnostics, context);
            case uml.UmlPackage.WRITE_STRUCTURAL_FEATURE_ACTION:
                return this.validateWriteStructuralFeatureAction(<uml.WriteStructuralFeatureAction><any>value, diagnostics, context);
            case uml.UmlPackage.STRUCTURAL_FEATURE_ACTION:
                return this.validateStructuralFeatureAction(<uml.StructuralFeatureAction><any>value, diagnostics, context);
            case uml.UmlPackage.WRITE_VARIABLE_ACTION:
                return this.validateWriteVariableAction(<uml.WriteVariableAction><any>value, diagnostics, context);
            case uml.UmlPackage.ACCEPT_CALL_ACTION:
                return this.validateAcceptCallAction(<uml.AcceptCallAction><any>value, diagnostics, context);
            case uml.UmlPackage.ACCEPT_EVENT_ACTION:
                return this.validateAcceptEventAction(<uml.AcceptEventAction><any>value, diagnostics, context);
            case uml.UmlPackage.ACTION_INPUT_PIN:
                return this.validateActionInputPin(<uml.ActionInputPin><any>value, diagnostics, context);
            case uml.UmlPackage.ADD_STRUCTURAL_FEATURE_VALUE_ACTION:
                return this.validateAddStructuralFeatureValueAction(<uml.AddStructuralFeatureValueAction><any>value, diagnostics, context);
            case uml.UmlPackage.ADD_VARIABLE_VALUE_ACTION:
                return this.validateAddVariableValueAction(<uml.AddVariableValueAction><any>value, diagnostics, context);
            case uml.UmlPackage.BROADCAST_SIGNAL_ACTION:
                return this.validateBroadcastSignalAction(<uml.BroadcastSignalAction><any>value, diagnostics, context);
            case uml.UmlPackage.INVOCATION_ACTION:
                return this.validateInvocationAction(<uml.InvocationAction><any>value, diagnostics, context);
            case uml.UmlPackage.CALL_ACTION:
                return this.validateCallAction(<uml.CallAction><any>value, diagnostics, context);
            case uml.UmlPackage.CALL_BEHAVIOR_ACTION:
                return this.validateCallBehaviorAction(<uml.CallBehaviorAction><any>value, diagnostics, context);
            case uml.UmlPackage.CALL_OPERATION_ACTION:
                return this.validateCallOperationAction(<uml.CallOperationAction><any>value, diagnostics, context);
            case uml.UmlPackage.CLAUSE:
                return this.validateClause(<uml.Clause><any>value, diagnostics, context);
            case uml.UmlPackage.CLEAR_ASSOCIATION_ACTION:
                return this.validateClearAssociationAction(<uml.ClearAssociationAction><any>value, diagnostics, context);
            case uml.UmlPackage.CLEAR_STRUCTURAL_FEATURE_ACTION:
                return this.validateClearStructuralFeatureAction(<uml.ClearStructuralFeatureAction><any>value, diagnostics, context);
            case uml.UmlPackage.CLEAR_VARIABLE_ACTION:
                return this.validateClearVariableAction(<uml.ClearVariableAction><any>value, diagnostics, context);
            case uml.UmlPackage.CONDITIONAL_NODE:
                return this.validateConditionalNode(<uml.ConditionalNode><any>value, diagnostics, context);
            case uml.UmlPackage.CREATE_LINK_ACTION:
                return this.validateCreateLinkAction(<uml.CreateLinkAction><any>value, diagnostics, context);
            case uml.UmlPackage.LINK_END_CREATION_DATA:
                return this.validateLinkEndCreationData(<uml.LinkEndCreationData><any>value, diagnostics, context);
            case uml.UmlPackage.CREATE_LINK_OBJECT_ACTION:
                return this.validateCreateLinkObjectAction(<uml.CreateLinkObjectAction><any>value, diagnostics, context);
            case uml.UmlPackage.CREATE_OBJECT_ACTION:
                return this.validateCreateObjectAction(<uml.CreateObjectAction><any>value, diagnostics, context);
            case uml.UmlPackage.DESTROY_LINK_ACTION:
                return this.validateDestroyLinkAction(<uml.DestroyLinkAction><any>value, diagnostics, context);
            case uml.UmlPackage.LINK_END_DESTRUCTION_DATA:
                return this.validateLinkEndDestructionData(<uml.LinkEndDestructionData><any>value, diagnostics, context);
            case uml.UmlPackage.DESTROY_OBJECT_ACTION:
                return this.validateDestroyObjectAction(<uml.DestroyObjectAction><any>value, diagnostics, context);
            case uml.UmlPackage.EXPANSION_NODE:
                return this.validateExpansionNode(<uml.ExpansionNode><any>value, diagnostics, context);
            case uml.UmlPackage.EXPANSION_REGION:
                return this.validateExpansionRegion(<uml.ExpansionRegion><any>value, diagnostics, context);
            case uml.UmlPackage.LOOP_NODE:
                return this.validateLoopNode(<uml.LoopNode><any>value, diagnostics, context);
            case uml.UmlPackage.OPAQUE_ACTION:
                return this.validateOpaqueAction(<uml.OpaqueAction><any>value, diagnostics, context);
            case uml.UmlPackage.RAISE_EXCEPTION_ACTION:
                return this.validateRaiseExceptionAction(<uml.RaiseExceptionAction><any>value, diagnostics, context);
            case uml.UmlPackage.READ_EXTENT_ACTION:
                return this.validateReadExtentAction(<uml.ReadExtentAction><any>value, diagnostics, context);
            case uml.UmlPackage.READ_IS_CLASSIFIED_OBJECT_ACTION:
                return this.validateReadIsClassifiedObjectAction(<uml.ReadIsClassifiedObjectAction><any>value, diagnostics, context);
            case uml.UmlPackage.READ_LINK_ACTION:
                return this.validateReadLinkAction(<uml.ReadLinkAction><any>value, diagnostics, context);
            case uml.UmlPackage.READ_LINK_OBJECT_END_ACTION:
                return this.validateReadLinkObjectEndAction(<uml.ReadLinkObjectEndAction><any>value, diagnostics, context);
            case uml.UmlPackage.READ_LINK_OBJECT_END_QUALIFIER_ACTION:
                return this.validateReadLinkObjectEndQualifierAction(<uml.ReadLinkObjectEndQualifierAction><any>value, diagnostics, context);
            case uml.UmlPackage.READ_SELF_ACTION:
                return this.validateReadSelfAction(<uml.ReadSelfAction><any>value, diagnostics, context);
            case uml.UmlPackage.READ_STRUCTURAL_FEATURE_ACTION:
                return this.validateReadStructuralFeatureAction(<uml.ReadStructuralFeatureAction><any>value, diagnostics, context);
            case uml.UmlPackage.READ_VARIABLE_ACTION:
                return this.validateReadVariableAction(<uml.ReadVariableAction><any>value, diagnostics, context);
            case uml.UmlPackage.RECLASSIFY_OBJECT_ACTION:
                return this.validateReclassifyObjectAction(<uml.ReclassifyObjectAction><any>value, diagnostics, context);
            case uml.UmlPackage.REDUCE_ACTION:
                return this.validateReduceAction(<uml.ReduceAction><any>value, diagnostics, context);
            case uml.UmlPackage.REMOVE_STRUCTURAL_FEATURE_VALUE_ACTION:
                return this.validateRemoveStructuralFeatureValueAction(<uml.RemoveStructuralFeatureValueAction><any>value, diagnostics, context);
            case uml.UmlPackage.REMOVE_VARIABLE_VALUE_ACTION:
                return this.validateRemoveVariableValueAction(<uml.RemoveVariableValueAction><any>value, diagnostics, context);
            case uml.UmlPackage.REPLY_ACTION:
                return this.validateReplyAction(<uml.ReplyAction><any>value, diagnostics, context);
            case uml.UmlPackage.SEND_OBJECT_ACTION:
                return this.validateSendObjectAction(<uml.SendObjectAction><any>value, diagnostics, context);
            case uml.UmlPackage.SEND_SIGNAL_ACTION:
                return this.validateSendSignalAction(<uml.SendSignalAction><any>value, diagnostics, context);
            case uml.UmlPackage.SEQUENCE_NODE:
                return this.validateSequenceNode(<uml.SequenceNode><any>value, diagnostics, context);
            case uml.UmlPackage.START_CLASSIFIER_BEHAVIOR_ACTION:
                return this.validateStartClassifierBehaviorAction(<uml.StartClassifierBehaviorAction><any>value, diagnostics, context);
            case uml.UmlPackage.START_OBJECT_BEHAVIOR_ACTION:
                return this.validateStartObjectBehaviorAction(<uml.StartObjectBehaviorAction><any>value, diagnostics, context);
            case uml.UmlPackage.TEST_IDENTITY_ACTION:
                return this.validateTestIdentityAction(<uml.TestIdentityAction><any>value, diagnostics, context);
            case uml.UmlPackage.UNMARSHALL_ACTION:
                return this.validateUnmarshallAction(<uml.UnmarshallAction><any>value, diagnostics, context);
            case uml.UmlPackage.VALUE_PIN:
                return this.validateValuePin(<uml.ValuePin><any>value, diagnostics, context);
            case uml.UmlPackage.ACTIVITY_FINAL_NODE:
                return this.validateActivityFinalNode(<uml.ActivityFinalNode><any>value, diagnostics, context);
            case uml.UmlPackage.FINAL_NODE:
                return this.validateFinalNode(<uml.FinalNode><any>value, diagnostics, context);
            case uml.UmlPackage.CONTROL_NODE:
                return this.validateControlNode(<uml.ControlNode><any>value, diagnostics, context);
            case uml.UmlPackage.ACTIVITY_PARAMETER_NODE:
                return this.validateActivityParameterNode(<uml.ActivityParameterNode><any>value, diagnostics, context);
            case uml.UmlPackage.CENTRAL_BUFFER_NODE:
                return this.validateCentralBufferNode(<uml.CentralBufferNode><any>value, diagnostics, context);
            case uml.UmlPackage.CONTROL_FLOW:
                return this.validateControlFlow(<uml.ControlFlow><any>value, diagnostics, context);
            case uml.UmlPackage.DATA_STORE_NODE:
                return this.validateDataStoreNode(<uml.DataStoreNode><any>value, diagnostics, context);
            case uml.UmlPackage.DECISION_NODE:
                return this.validateDecisionNode(<uml.DecisionNode><any>value, diagnostics, context);
            case uml.UmlPackage.OBJECT_FLOW:
                return this.validateObjectFlow(<uml.ObjectFlow><any>value, diagnostics, context);
            case uml.UmlPackage.FLOW_FINAL_NODE:
                return this.validateFlowFinalNode(<uml.FlowFinalNode><any>value, diagnostics, context);
            case uml.UmlPackage.FORK_NODE:
                return this.validateForkNode(<uml.ForkNode><any>value, diagnostics, context);
            case uml.UmlPackage.INITIAL_NODE:
                return this.validateInitialNode(<uml.InitialNode><any>value, diagnostics, context);
            case uml.UmlPackage.JOIN_NODE:
                return this.validateJoinNode(<uml.JoinNode><any>value, diagnostics, context);
            case uml.UmlPackage.MERGE_NODE:
                return this.validateMergeNode(<uml.MergeNode><any>value, diagnostics, context);
            case uml.UmlPackage.INSTANCE_VALUE:
                return this.validateInstanceValue(<uml.InstanceValue><any>value, diagnostics, context);
            case uml.UmlPackage.ANY_RECEIVE_EVENT:
                return this.validateAnyReceiveEvent(<uml.AnyReceiveEvent><any>value, diagnostics, context);
            case uml.UmlPackage.MESSAGE_EVENT:
                return this.validateMessageEvent(<uml.MessageEvent><any>value, diagnostics, context);
            case uml.UmlPackage.CALL_EVENT:
                return this.validateCallEvent(<uml.CallEvent><any>value, diagnostics, context);
            case uml.UmlPackage.CHANGE_EVENT:
                return this.validateChangeEvent(<uml.ChangeEvent><any>value, diagnostics, context);
            case uml.UmlPackage.FUNCTION_BEHAVIOR:
                return this.validateFunctionBehavior(<uml.FunctionBehavior><any>value, diagnostics, context);
            case uml.UmlPackage.OPAQUE_BEHAVIOR:
                return this.validateOpaqueBehavior(<uml.OpaqueBehavior><any>value, diagnostics, context);
            case uml.UmlPackage.SIGNAL_EVENT:
                return this.validateSignalEvent(<uml.SignalEvent><any>value, diagnostics, context);
            case uml.UmlPackage.TIME_EVENT:
                return this.validateTimeEvent(<uml.TimeEvent><any>value, diagnostics, context);
            case uml.UmlPackage.TIME_EXPRESSION:
                return this.validateTimeExpression(<uml.TimeExpression><any>value, diagnostics, context);
            case uml.UmlPackage.OBSERVATION:
                return this.validateObservation(<uml.Observation><any>value, diagnostics, context);
            case uml.UmlPackage.COMMUNICATION_PATH:
                return this.validateCommunicationPath(<uml.CommunicationPath><any>value, diagnostics, context);
            case uml.UmlPackage.DEVICE:
                return this.validateDevice(<uml.Device><any>value, diagnostics, context);
            case uml.UmlPackage.NODE:
                return this.validateNode(<uml.Node><any>value, diagnostics, context);
            case uml.UmlPackage.EXECUTION_ENVIRONMENT:
                return this.validateExecutionEnvironment(<uml.ExecutionEnvironment><any>value, diagnostics, context);
            case uml.UmlPackage.INFORMATION_FLOW:
                return this.validateInformationFlow(<uml.InformationFlow><any>value, diagnostics, context);
            case uml.UmlPackage.MESSAGE:
                return this.validateMessage(<uml.Message><any>value, diagnostics, context);
            case uml.UmlPackage.INTERACTION:
                return this.validateInteraction(<uml.Interaction><any>value, diagnostics, context);
            case uml.UmlPackage.INTERACTION_FRAGMENT:
                return this.validateInteractionFragment(<uml.InteractionFragment><any>value, diagnostics, context);
            case uml.UmlPackage.LIFELINE:
                return this.validateLifeline(<uml.Lifeline><any>value, diagnostics, context);
            case uml.UmlPackage.PART_DECOMPOSITION:
                return this.validatePartDecomposition(<uml.PartDecomposition><any>value, diagnostics, context);
            case uml.UmlPackage.INTERACTION_USE:
                return this.validateInteractionUse(<uml.InteractionUse><any>value, diagnostics, context);
            case uml.UmlPackage.GATE:
                return this.validateGate(<uml.Gate><any>value, diagnostics, context);
            case uml.UmlPackage.MESSAGE_END:
                return this.validateMessageEnd(<uml.MessageEnd><any>value, diagnostics, context);
            case uml.UmlPackage.INTERACTION_OPERAND:
                return this.validateInteractionOperand(<uml.InteractionOperand><any>value, diagnostics, context);
            case uml.UmlPackage.INTERACTION_CONSTRAINT:
                return this.validateInteractionConstraint(<uml.InteractionConstraint><any>value, diagnostics, context);
            case uml.UmlPackage.GENERAL_ORDERING:
                return this.validateGeneralOrdering(<uml.GeneralOrdering><any>value, diagnostics, context);
            case uml.UmlPackage.OCCURRENCE_SPECIFICATION:
                return this.validateOccurrenceSpecification(<uml.OccurrenceSpecification><any>value, diagnostics, context);
            case uml.UmlPackage.INFORMATION_ITEM:
                return this.validateInformationItem(<uml.InformationItem><any>value, diagnostics, context);
            case uml.UmlPackage.ACTION_EXECUTION_SPECIFICATION:
                return this.validateActionExecutionSpecification(<uml.ActionExecutionSpecification><any>value, diagnostics, context);
            case uml.UmlPackage.EXECUTION_SPECIFICATION:
                return this.validateExecutionSpecification(<uml.ExecutionSpecification><any>value, diagnostics, context);
            case uml.UmlPackage.BEHAVIOR_EXECUTION_SPECIFICATION:
                return this.validateBehaviorExecutionSpecification(<uml.BehaviorExecutionSpecification><any>value, diagnostics, context);
            case uml.UmlPackage.COMBINED_FRAGMENT:
                return this.validateCombinedFragment(<uml.CombinedFragment><any>value, diagnostics, context);
            case uml.UmlPackage.CONSIDER_IGNORE_FRAGMENT:
                return this.validateConsiderIgnoreFragment(<uml.ConsiderIgnoreFragment><any>value, diagnostics, context);
            case uml.UmlPackage.CONTINUATION:
                return this.validateContinuation(<uml.Continuation><any>value, diagnostics, context);
            case uml.UmlPackage.DESTRUCTION_OCCURRENCE_SPECIFICATION:
                return this.validateDestructionOccurrenceSpecification(<uml.DestructionOccurrenceSpecification><any>value, diagnostics, context);
            case uml.UmlPackage.MESSAGE_OCCURRENCE_SPECIFICATION:
                return this.validateMessageOccurrenceSpecification(<uml.MessageOccurrenceSpecification><any>value, diagnostics, context);
            case uml.UmlPackage.EXECUTION_OCCURRENCE_SPECIFICATION:
                return this.validateExecutionOccurrenceSpecification(<uml.ExecutionOccurrenceSpecification><any>value, diagnostics, context);
            case uml.UmlPackage.STATE_INVARIANT:
                return this.validateStateInvariant(<uml.StateInvariant><any>value, diagnostics, context);
            case uml.UmlPackage.FINAL_STATE:
                return this.validateFinalState(<uml.FinalState><any>value, diagnostics, context);
            case uml.UmlPackage.PROTOCOL_TRANSITION:
                return this.validateProtocolTransition(<uml.ProtocolTransition><any>value, diagnostics, context);
            case uml.UmlPackage.ASSOCIATION_CLASS:
                return this.validateAssociationClass(<uml.AssociationClass><any>value, diagnostics, context);
            case uml.UmlPackage.COMPONENT:
                return this.validateComponent(<uml.Component><any>value, diagnostics, context);
            case uml.UmlPackage.COMPONENT_REALIZATION:
                return this.validateComponentRealization(<uml.ComponentRealization><any>value, diagnostics, context);
            case uml.UmlPackage.ACTOR:
                return this.validateActor(<uml.Actor><any>value, diagnostics, context);
            case uml.UmlPackage.DURATION:
                return this.validateDuration(<uml.Duration><any>value, diagnostics, context);
            case uml.UmlPackage.DURATION_CONSTRAINT:
                return this.validateDurationConstraint(<uml.DurationConstraint><any>value, diagnostics, context);
            case uml.UmlPackage.INTERVAL_CONSTRAINT:
                return this.validateIntervalConstraint(<uml.IntervalConstraint><any>value, diagnostics, context);
            case uml.UmlPackage.INTERVAL:
                return this.validateInterval(<uml.Interval><any>value, diagnostics, context);
            case uml.UmlPackage.DURATION_INTERVAL:
                return this.validateDurationInterval(<uml.DurationInterval><any>value, diagnostics, context);
            case uml.UmlPackage.DURATION_OBSERVATION:
                return this.validateDurationObservation(<uml.DurationObservation><any>value, diagnostics, context);
            case uml.UmlPackage.LITERAL_BOOLEAN:
                return this.validateLiteralBoolean(<uml.LiteralBoolean><any>value, diagnostics, context);
            case uml.UmlPackage.LITERAL_SPECIFICATION:
                return this.validateLiteralSpecification(<uml.LiteralSpecification><any>value, diagnostics, context);
            case uml.UmlPackage.LITERAL_INTEGER:
                return this.validateLiteralInteger(<uml.LiteralInteger><any>value, diagnostics, context);
            case uml.UmlPackage.LITERAL_NULL:
                return this.validateLiteralNull(<uml.LiteralNull><any>value, diagnostics, context);
            case uml.UmlPackage.LITERAL_REAL:
                return this.validateLiteralReal(<uml.LiteralReal><any>value, diagnostics, context);
            case uml.UmlPackage.LITERAL_STRING:
                return this.validateLiteralString(<uml.LiteralString><any>value, diagnostics, context);
            case uml.UmlPackage.LITERAL_UNLIMITED_NATURAL:
                return this.validateLiteralUnlimitedNatural(<uml.LiteralUnlimitedNatural><any>value, diagnostics, context);
            case uml.UmlPackage.TIME_CONSTRAINT:
                return this.validateTimeConstraint(<uml.TimeConstraint><any>value, diagnostics, context);
            case uml.UmlPackage.TIME_INTERVAL:
                return this.validateTimeInterval(<uml.TimeInterval><any>value, diagnostics, context);
            case uml.UmlPackage.TIME_OBSERVATION:
                return this.validateTimeObservation(<uml.TimeObservation><any>value, diagnostics, context);
            case uml.UmlPackage.VISIBILITY_KIND:
                return this.validateVisibilityKind(<uml.VisibilityKind>value, diagnostics, context);
            case uml.UmlPackage.PARAMETER_DIRECTION_KIND:
                return this.validateParameterDirectionKind(<uml.ParameterDirectionKind>value, diagnostics, context);
            case uml.UmlPackage.PARAMETER_EFFECT_KIND:
                return this.validateParameterEffectKind(<uml.ParameterEffectKind>value, diagnostics, context);
            case uml.UmlPackage.CALL_CONCURRENCY_KIND:
                return this.validateCallConcurrencyKind(<uml.CallConcurrencyKind>value, diagnostics, context);
            case uml.UmlPackage.TRANSITION_KIND:
                return this.validateTransitionKind(<uml.TransitionKind>value, diagnostics, context);
            case uml.UmlPackage.PSEUDOSTATE_KIND:
                return this.validatePseudostateKind(<uml.PseudostateKind>value, diagnostics, context);
            case uml.UmlPackage.AGGREGATION_KIND:
                return this.validateAggregationKind(<uml.AggregationKind>value, diagnostics, context);
            case uml.UmlPackage.CONNECTOR_KIND:
                return this.validateConnectorKind(<uml.ConnectorKind>value, diagnostics, context);
            case uml.UmlPackage.OBJECT_NODE_ORDERING_KIND:
                return this.validateObjectNodeOrderingKind(<uml.ObjectNodeOrderingKind>value, diagnostics, context);
            case uml.UmlPackage.EXPANSION_KIND:
                return this.validateExpansionKind(<uml.ExpansionKind>value, diagnostics, context);
            case uml.UmlPackage.MESSAGE_KIND:
                return this.validateMessageKind(<uml.MessageKind>value, diagnostics, context);
            case uml.UmlPackage.MESSAGE_SORT:
                return this.validateMessageSort(<uml.MessageSort>value, diagnostics, context);
            case uml.UmlPackage.INTERACTION_OPERATOR_KIND:
                return this.validateInteractionOperatorKind(<uml.InteractionOperatorKind>value, diagnostics, context);
            default:
                return true;
            }
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} activityContent
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateActivityContent(activityContent : uml.ActivityContent, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return this.validate_EveryDefaultConstraint(activityContent, diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} activity
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateActivity(activity : uml.Activity, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(activity, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(activity, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(activity, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(activity, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(activity, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(activity, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(activity, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(activity, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(activity, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(activity, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(activity, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(activity, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(activity, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(activity, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_members_distinguishable(activity, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_self(activity, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_ownedMembers(activity, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(activity, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(activity, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(activity, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePackageableElement_namespace_needs_visibility(activity, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_specialize_type(activity, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_maps_to_generalization_set(activity, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_non_final_parents(activity, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_no_cycles_in_generalization(activity, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateBehavioredClassifier_class_behavior(activity, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClass_passive_class(activity, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateBehavior_most_one_behavior(activity, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateBehavior_parameters_match(activity, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateBehavior_feature_of_context_classifier(activity, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateActivity_maximum_one_parameter_node(activity, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateActivity_maximum_two_parameter_nodes(activity, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the maximum_one_parameter_node constraint of '<em>Activity</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} activity
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateActivity_maximum_one_parameter_node(activity : uml.Activity, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return activity.maximum_one_parameter_node(diagnostics, context);
        }

        /**
         * Validates the maximum_two_parameter_nodes constraint of '<em>Activity</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} activity
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateActivity_maximum_two_parameter_nodes(activity : uml.Activity, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return activity.maximum_two_parameter_nodes(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} behavior
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateBehavior(behavior : uml.Behavior, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(behavior, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(behavior, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(behavior, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(behavior, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(behavior, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(behavior, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(behavior, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(behavior, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(behavior, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(behavior, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(behavior, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(behavior, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(behavior, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(behavior, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_members_distinguishable(behavior, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_self(behavior, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_ownedMembers(behavior, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(behavior, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(behavior, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(behavior, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePackageableElement_namespace_needs_visibility(behavior, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_specialize_type(behavior, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_maps_to_generalization_set(behavior, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_non_final_parents(behavior, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_no_cycles_in_generalization(behavior, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateBehavioredClassifier_class_behavior(behavior, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClass_passive_class(behavior, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateBehavior_most_one_behavior(behavior, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateBehavior_parameters_match(behavior, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateBehavior_feature_of_context_classifier(behavior, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the most_one_behavior constraint of '<em>Behavior</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} behavior
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateBehavior_most_one_behavior(behavior : uml.Behavior, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return behavior.most_one_behavior(diagnostics, context);
        }

        /**
         * Validates the parameters_match constraint of '<em>Behavior</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} behavior
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateBehavior_parameters_match(behavior : uml.Behavior, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return behavior.parameters_match(diagnostics, context);
        }

        /**
         * Validates the feature_of_context_classifier constraint of '<em>Behavior</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} behavior
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateBehavior_feature_of_context_classifier(behavior : uml.Behavior, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return behavior.feature_of_context_classifier(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} class_
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateClass(class_ : uml.Class, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(class_, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(class_, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(class_, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(class_, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(class_, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(class_, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(class_, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(class_, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(class_, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(class_, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(class_, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(class_, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(class_, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(class_, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_members_distinguishable(class_, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_self(class_, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_ownedMembers(class_, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(class_, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(class_, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(class_, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePackageableElement_namespace_needs_visibility(class_, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_specialize_type(class_, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_maps_to_generalization_set(class_, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_non_final_parents(class_, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_no_cycles_in_generalization(class_, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateBehavioredClassifier_class_behavior(class_, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClass_passive_class(class_, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the passive_class constraint of '<em>Class</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} class_
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateClass_passive_class(class_ : uml.Class, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return class_.passive_class(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} behavioredClassifier
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateBehavioredClassifier(behavioredClassifier : uml.BehavioredClassifier, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(behavioredClassifier, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(behavioredClassifier, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(behavioredClassifier, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(behavioredClassifier, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(behavioredClassifier, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(behavioredClassifier, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(behavioredClassifier, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(behavioredClassifier, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(behavioredClassifier, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(behavioredClassifier, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(behavioredClassifier, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(behavioredClassifier, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(behavioredClassifier, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(behavioredClassifier, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_members_distinguishable(behavioredClassifier, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_self(behavioredClassifier, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_ownedMembers(behavioredClassifier, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(behavioredClassifier, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(behavioredClassifier, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(behavioredClassifier, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePackageableElement_namespace_needs_visibility(behavioredClassifier, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_specialize_type(behavioredClassifier, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_maps_to_generalization_set(behavioredClassifier, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_non_final_parents(behavioredClassifier, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_no_cycles_in_generalization(behavioredClassifier, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateBehavioredClassifier_class_behavior(behavioredClassifier, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the class_behavior constraint of '<em>Behaviored Classifier</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} behavioredClassifier
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateBehavioredClassifier_class_behavior(behavioredClassifier : uml.BehavioredClassifier, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return behavioredClassifier.class_behavior(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} classifier
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateClassifier(classifier : uml.Classifier, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(classifier, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(classifier, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(classifier, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(classifier, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(classifier, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(classifier, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(classifier, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(classifier, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(classifier, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(classifier, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(classifier, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(classifier, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(classifier, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(classifier, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_members_distinguishable(classifier, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_self(classifier, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_ownedMembers(classifier, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(classifier, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(classifier, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(classifier, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePackageableElement_namespace_needs_visibility(classifier, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_specialize_type(classifier, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_maps_to_generalization_set(classifier, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_non_final_parents(classifier, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_no_cycles_in_generalization(classifier, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the specialize_type constraint of '<em>Classifier</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} classifier
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateClassifier_specialize_type(classifier : uml.Classifier, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return classifier.specialize_type(diagnostics, context);
        }

        /**
         * Validates the maps_to_generalization_set constraint of '<em>Classifier</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} classifier
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateClassifier_maps_to_generalization_set(classifier : uml.Classifier, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return classifier.maps_to_generalization_set(diagnostics, context);
        }

        /**
         * Validates the non_final_parents constraint of '<em>Classifier</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} classifier
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateClassifier_non_final_parents(classifier : uml.Classifier, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return classifier.non_final_parents(diagnostics, context);
        }

        /**
         * Validates the no_cycles_in_generalization constraint of '<em>Classifier</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} classifier
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateClassifier_no_cycles_in_generalization(classifier : uml.Classifier, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return classifier.no_cycles_in_generalization(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} namespace
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateNamespace(namespace : uml.Namespace, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(namespace, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(namespace, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(namespace, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(namespace, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(namespace, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(namespace, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(namespace, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(namespace, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(namespace, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(namespace, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(namespace, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(namespace, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(namespace, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(namespace, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_members_distinguishable(namespace, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_self(namespace, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_ownedMembers(namespace, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the members_distinguishable constraint of '<em>Namespace</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} namespace
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateNamespace_members_distinguishable(namespace : uml.Namespace, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return namespace.members_distinguishable(diagnostics, context);
        }

        /**
         * Validates the cannot_import_self constraint of '<em>Namespace</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} namespace
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateNamespace_cannot_import_self(namespace : uml.Namespace, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return namespace.cannot_import_self(diagnostics, context);
        }

        /**
         * Validates the cannot_import_ownedMembers constraint of '<em>Namespace</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} namespace
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateNamespace_cannot_import_ownedMembers(namespace : uml.Namespace, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return namespace.cannot_import_ownedMembers(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} namedElement
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateNamedElement(namedElement : uml.NamedElement, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(namedElement, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(namedElement, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(namedElement, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(namedElement, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(namedElement, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(namedElement, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(namedElement, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(namedElement, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(namedElement, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(namedElement, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(namedElement, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(namedElement, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(namedElement, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(namedElement, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the visibility_needs_ownership constraint of '<em>Named Element</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} namedElement
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateNamedElement_visibility_needs_ownership(namedElement : uml.NamedElement, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return namedElement.visibility_needs_ownership(diagnostics, context);
        }

        /**
         * Validates the has_qualified_name constraint of '<em>Named Element</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} namedElement
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateNamedElement_has_qualified_name(namedElement : uml.NamedElement, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return namedElement.has_qualified_name(diagnostics, context);
        }

        /**
         * Validates the has_no_qualified_name constraint of '<em>Named Element</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} namedElement
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateNamedElement_has_no_qualified_name(namedElement : uml.NamedElement, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return namedElement.has_no_qualified_name(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} element
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateElement(element : uml.Element, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(element, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(element, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(element, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(element, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(element, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(element, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(element, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(element, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(element, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(element, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(element, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the has_owner constraint of '<em>Element</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} element
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateElement_has_owner(element : uml.Element, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return element.has_owner(diagnostics, context);
        }

        /**
         * Validates the not_own_self constraint of '<em>Element</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} element
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateElement_not_own_self(element : uml.Element, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return element.not_own_self(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} comment
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateComment(comment : uml.Comment, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(comment, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(comment, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(comment, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(comment, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(comment, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(comment, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(comment, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(comment, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(comment, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(comment, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(comment, diagnostics, context) && result;
            return result;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} stereotype
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateStereotype(stereotype : uml.Stereotype, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(stereotype, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(stereotype, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(stereotype, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(stereotype, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(stereotype, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(stereotype, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(stereotype, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(stereotype, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(stereotype, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(stereotype, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(stereotype, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(stereotype, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(stereotype, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(stereotype, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_members_distinguishable(stereotype, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_self(stereotype, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_ownedMembers(stereotype, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(stereotype, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(stereotype, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(stereotype, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePackageableElement_namespace_needs_visibility(stereotype, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_specialize_type(stereotype, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_maps_to_generalization_set(stereotype, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_non_final_parents(stereotype, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_no_cycles_in_generalization(stereotype, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateBehavioredClassifier_class_behavior(stereotype, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClass_passive_class(stereotype, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateStereotype_binaryAssociationsOnly(stereotype, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateStereotype_generalize(stereotype, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateStereotype_name_not_clash(stereotype, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateStereotype_associationEndOwnership(stereotype, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateStereotype_base_property_upper_bound(stereotype, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateStereotype_base_property_multiplicity_single_extension(stereotype, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateStereotype_base_property_multiplicity_multiple_extension(stereotype, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the binaryAssociationsOnly constraint of '<em>Stereotype</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} stereotype
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateStereotype_binaryAssociationsOnly(stereotype : uml.Stereotype, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return stereotype.binaryAssociationsOnly(diagnostics, context);
        }

        /**
         * Validates the generalize constraint of '<em>Stereotype</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} stereotype
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateStereotype_generalize(stereotype : uml.Stereotype, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return stereotype.generalize(diagnostics, context);
        }

        /**
         * Validates the name_not_clash constraint of '<em>Stereotype</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} stereotype
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateStereotype_name_not_clash(stereotype : uml.Stereotype, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return stereotype.name_not_clash(diagnostics, context);
        }

        /**
         * Validates the associationEndOwnership constraint of '<em>Stereotype</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} stereotype
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateStereotype_associationEndOwnership(stereotype : uml.Stereotype, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return stereotype.associationEndOwnership(diagnostics, context);
        }

        /**
         * Validates the base_property_upper_bound constraint of '<em>Stereotype</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} stereotype
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateStereotype_base_property_upper_bound(stereotype : uml.Stereotype, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return stereotype.base_property_upper_bound(diagnostics, context);
        }

        /**
         * Validates the base_property_multiplicity_single_extension constraint of '<em>Stereotype</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} stereotype
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateStereotype_base_property_multiplicity_single_extension(stereotype : uml.Stereotype, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return stereotype.base_property_multiplicity_single_extension(diagnostics, context);
        }

        /**
         * Validates the base_property_multiplicity_multiple_extension constraint of '<em>Stereotype</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} stereotype
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateStereotype_base_property_multiplicity_multiple_extension(stereotype : uml.Stereotype, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return stereotype.base_property_multiplicity_multiple_extension(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} image
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateImage(image : uml.Image, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(image, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(image, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(image, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(image, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(image, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(image, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(image, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(image, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(image, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(image, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(image, diagnostics, context) && result;
            return result;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} profile
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateProfile(profile : uml.Profile, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(profile, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(profile, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(profile, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(profile, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(profile, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(profile, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(profile, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(profile, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(profile, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(profile, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(profile, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(profile, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(profile, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(profile, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_members_distinguishable(profile, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_self(profile, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_ownedMembers(profile, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePackageableElement_namespace_needs_visibility(profile, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePackage_elements_public_or_private(profile, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateProfile_metaclass_reference_not_specialized(profile, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateProfile_references_same_metamodel(profile, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the metaclass_reference_not_specialized constraint of '<em>Profile</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} profile
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateProfile_metaclass_reference_not_specialized(profile : uml.Profile, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return profile.metaclass_reference_not_specialized(diagnostics, context);
        }

        /**
         * Validates the references_same_metamodel constraint of '<em>Profile</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} profile
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateProfile_references_same_metamodel(profile : uml.Profile, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return profile.references_same_metamodel(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} package_
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validatePackage(package_ : uml.Package, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(package_, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(package_, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(package_, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(package_, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(package_, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(package_, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(package_, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(package_, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(package_, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(package_, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(package_, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(package_, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(package_, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(package_, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_members_distinguishable(package_, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_self(package_, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_ownedMembers(package_, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePackageableElement_namespace_needs_visibility(package_, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePackage_elements_public_or_private(package_, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the elements_public_or_private constraint of '<em>Package</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} package_
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validatePackage_elements_public_or_private(package_ : uml.Package, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return package_.elements_public_or_private(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} packageableElement
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validatePackageableElement(packageableElement : uml.PackageableElement, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(packageableElement, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(packageableElement, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(packageableElement, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(packageableElement, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(packageableElement, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(packageableElement, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(packageableElement, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(packageableElement, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(packageableElement, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(packageableElement, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(packageableElement, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(packageableElement, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(packageableElement, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(packageableElement, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePackageableElement_namespace_needs_visibility(packageableElement, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the namespace_needs_visibility constraint of '<em>Packageable Element</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} packageableElement
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validatePackageableElement_namespace_needs_visibility(packageableElement : uml.PackageableElement, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return packageableElement.namespace_needs_visibility(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} parameterableElement
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateParameterableElement(parameterableElement : uml.ParameterableElement, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(parameterableElement, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(parameterableElement, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(parameterableElement, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(parameterableElement, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(parameterableElement, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(parameterableElement, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(parameterableElement, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(parameterableElement, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(parameterableElement, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(parameterableElement, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(parameterableElement, diagnostics, context) && result;
            return result;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} templateParameter
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateTemplateParameter(templateParameter : uml.TemplateParameter, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(templateParameter, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(templateParameter, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(templateParameter, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(templateParameter, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(templateParameter, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(templateParameter, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(templateParameter, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(templateParameter, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(templateParameter, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(templateParameter, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(templateParameter, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateTemplateParameter_must_be_compatible(templateParameter, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the must_be_compatible constraint of '<em>Template Parameter</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} templateParameter
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateTemplateParameter_must_be_compatible(templateParameter : uml.TemplateParameter, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return templateParameter.must_be_compatible(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} templateSignature
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateTemplateSignature(templateSignature : uml.TemplateSignature, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(templateSignature, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(templateSignature, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(templateSignature, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(templateSignature, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(templateSignature, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(templateSignature, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(templateSignature, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(templateSignature, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(templateSignature, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(templateSignature, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(templateSignature, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateTemplateSignature_own_elements(templateSignature, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateTemplateSignature_unique_parameters(templateSignature, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the own_elements constraint of '<em>Template Signature</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} templateSignature
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateTemplateSignature_own_elements(templateSignature : uml.TemplateSignature, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return templateSignature.own_elements(diagnostics, context);
        }

        /**
         * Validates the unique_parameters constraint of '<em>Template Signature</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} templateSignature
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateTemplateSignature_unique_parameters(templateSignature : uml.TemplateSignature, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return templateSignature.unique_parameters(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} templateableElement
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateTemplateableElement(templateableElement : uml.TemplateableElement, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(templateableElement, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(templateableElement, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(templateableElement, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(templateableElement, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(templateableElement, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(templateableElement, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(templateableElement, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(templateableElement, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(templateableElement, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(templateableElement, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(templateableElement, diagnostics, context) && result;
            return result;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} templateBinding
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateTemplateBinding(templateBinding : uml.TemplateBinding, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(templateBinding, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(templateBinding, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(templateBinding, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(templateBinding, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(templateBinding, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(templateBinding, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(templateBinding, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(templateBinding, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(templateBinding, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(templateBinding, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(templateBinding, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateTemplateBinding_parameter_substitution_formal(templateBinding, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateTemplateBinding_one_parameter_substitution(templateBinding, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the parameter_substitution_formal constraint of '<em>Template Binding</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} templateBinding
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateTemplateBinding_parameter_substitution_formal(templateBinding : uml.TemplateBinding, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return templateBinding.parameter_substitution_formal(diagnostics, context);
        }

        /**
         * Validates the one_parameter_substitution constraint of '<em>Template Binding</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} templateBinding
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateTemplateBinding_one_parameter_substitution(templateBinding : uml.TemplateBinding, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return templateBinding.one_parameter_substitution(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} directedRelationship
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateDirectedRelationship(directedRelationship : uml.DirectedRelationship, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(directedRelationship, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(directedRelationship, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(directedRelationship, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(directedRelationship, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(directedRelationship, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(directedRelationship, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(directedRelationship, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(directedRelationship, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(directedRelationship, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(directedRelationship, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(directedRelationship, diagnostics, context) && result;
            return result;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} relationship
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateRelationship(relationship : uml.Relationship, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(relationship, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(relationship, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(relationship, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(relationship, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(relationship, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(relationship, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(relationship, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(relationship, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(relationship, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(relationship, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(relationship, diagnostics, context) && result;
            return result;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} templateParameterSubstitution
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateTemplateParameterSubstitution(templateParameterSubstitution : uml.TemplateParameterSubstitution, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(templateParameterSubstitution, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(templateParameterSubstitution, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(templateParameterSubstitution, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(templateParameterSubstitution, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(templateParameterSubstitution, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(templateParameterSubstitution, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(templateParameterSubstitution, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(templateParameterSubstitution, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(templateParameterSubstitution, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(templateParameterSubstitution, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(templateParameterSubstitution, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateTemplateParameterSubstitution_must_be_compatible(templateParameterSubstitution, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the must_be_compatible constraint of '<em>Template Parameter Substitution</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} templateParameterSubstitution
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateTemplateParameterSubstitution_must_be_compatible(templateParameterSubstitution : uml.TemplateParameterSubstitution, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return templateParameterSubstitution.must_be_compatible(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} type
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateType(type : uml.Type, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(type, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(type, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(type, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(type, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(type, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(type, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(type, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(type, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(type, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(type, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(type, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(type, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(type, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(type, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePackageableElement_namespace_needs_visibility(type, diagnostics, context) && result;
            return result;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} association
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateAssociation(association : uml.Association, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(association, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(association, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(association, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(association, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(association, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(association, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(association, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(association, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(association, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(association, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(association, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(association, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(association, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(association, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_members_distinguishable(association, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_self(association, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_ownedMembers(association, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(association, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(association, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(association, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePackageableElement_namespace_needs_visibility(association, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_specialize_type(association, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_maps_to_generalization_set(association, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_non_final_parents(association, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_no_cycles_in_generalization(association, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateAssociation_specialized_end_number(association, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateAssociation_specialized_end_types(association, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateAssociation_binary_associations(association, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateAssociation_association_ends(association, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateAssociation_ends_must_be_typed(association, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the specialized_end_number constraint of '<em>Association</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} association
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateAssociation_specialized_end_number(association : uml.Association, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return association.specialized_end_number(diagnostics, context);
        }

        /**
         * Validates the specialized_end_types constraint of '<em>Association</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} association
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateAssociation_specialized_end_types(association : uml.Association, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return association.specialized_end_types(diagnostics, context);
        }

        /**
         * Validates the binary_associations constraint of '<em>Association</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} association
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateAssociation_binary_associations(association : uml.Association, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return association.binary_associations(diagnostics, context);
        }

        /**
         * Validates the association_ends constraint of '<em>Association</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} association
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateAssociation_association_ends(association : uml.Association, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return association.association_ends(diagnostics, context);
        }

        /**
         * Validates the ends_must_be_typed constraint of '<em>Association</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} association
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateAssociation_ends_must_be_typed(association : uml.Association, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return association.ends_must_be_typed(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} property
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateProperty(property : uml.Property, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(property, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(property, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(property, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(property, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(property, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(property, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(property, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(property, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(property, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(property, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(property, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(property, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(property, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(property, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(property, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(property, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(property, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateMultiplicityElement_upper_ge_lower(property, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateMultiplicityElement_lower_ge_0(property, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateMultiplicityElement_value_specification_no_side_effects(property, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateMultiplicityElement_value_specification_constant(property, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateMultiplicityElement_lower_is_integer(property, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateMultiplicityElement_upper_is_unlimitedNatural(property, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateProperty_subsetting_context_conforms(property, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateProperty_derived_union_is_read_only(property, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateProperty_multiplicity_of_composite(property, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateProperty_redefined_property_inherited(property, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateProperty_subsetting_rules(property, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateProperty_binding_to_attribute(property, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateProperty_derived_union_is_derived(property, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateProperty_deployment_target(property, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateProperty_subsetted_property_names(property, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateProperty_type_of_opposite_end(property, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateProperty_qualified_is_association_end(property, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the subsetting_context_conforms constraint of '<em>Property</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} property
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateProperty_subsetting_context_conforms(property : uml.Property, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return property.subsetting_context_conforms(diagnostics, context);
        }

        /**
         * Validates the derived_union_is_read_only constraint of '<em>Property</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} property
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateProperty_derived_union_is_read_only(property : uml.Property, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return property.derived_union_is_read_only(diagnostics, context);
        }

        /**
         * Validates the multiplicity_of_composite constraint of '<em>Property</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} property
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateProperty_multiplicity_of_composite(property : uml.Property, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return property.multiplicity_of_composite(diagnostics, context);
        }

        /**
         * Validates the redefined_property_inherited constraint of '<em>Property</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} property
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateProperty_redefined_property_inherited(property : uml.Property, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return property.redefined_property_inherited(diagnostics, context);
        }

        /**
         * Validates the subsetting_rules constraint of '<em>Property</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} property
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateProperty_subsetting_rules(property : uml.Property, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return property.subsetting_rules(diagnostics, context);
        }

        /**
         * Validates the binding_to_attribute constraint of '<em>Property</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} property
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateProperty_binding_to_attribute(property : uml.Property, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return property.binding_to_attribute(diagnostics, context);
        }

        /**
         * Validates the derived_union_is_derived constraint of '<em>Property</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} property
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateProperty_derived_union_is_derived(property : uml.Property, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return property.derived_union_is_derived(diagnostics, context);
        }

        /**
         * Validates the deployment_target constraint of '<em>Property</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} property
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateProperty_deployment_target(property : uml.Property, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return property.deployment_target(diagnostics, context);
        }

        /**
         * Validates the subsetted_property_names constraint of '<em>Property</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} property
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateProperty_subsetted_property_names(property : uml.Property, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return property.subsetted_property_names(diagnostics, context);
        }

        /**
         * Validates the type_of_opposite_end constraint of '<em>Property</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} property
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateProperty_type_of_opposite_end(property : uml.Property, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return property.type_of_opposite_end(diagnostics, context);
        }

        /**
         * Validates the qualified_is_association_end constraint of '<em>Property</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} property
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateProperty_qualified_is_association_end(property : uml.Property, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return property.qualified_is_association_end(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} connectableElement
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateConnectableElement(connectableElement : uml.ConnectableElement, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(connectableElement, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(connectableElement, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(connectableElement, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(connectableElement, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(connectableElement, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(connectableElement, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(connectableElement, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(connectableElement, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(connectableElement, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(connectableElement, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(connectableElement, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(connectableElement, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(connectableElement, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(connectableElement, diagnostics, context) && result;
            return result;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} typedElement
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateTypedElement(typedElement : uml.TypedElement, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(typedElement, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(typedElement, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(typedElement, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(typedElement, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(typedElement, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(typedElement, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(typedElement, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(typedElement, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(typedElement, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(typedElement, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(typedElement, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(typedElement, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(typedElement, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(typedElement, diagnostics, context) && result;
            return result;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} connectorEnd
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateConnectorEnd(connectorEnd : uml.ConnectorEnd, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(connectorEnd, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(connectorEnd, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(connectorEnd, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(connectorEnd, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(connectorEnd, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(connectorEnd, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(connectorEnd, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(connectorEnd, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(connectorEnd, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(connectorEnd, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(connectorEnd, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateMultiplicityElement_upper_ge_lower(connectorEnd, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateMultiplicityElement_lower_ge_0(connectorEnd, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateMultiplicityElement_value_specification_no_side_effects(connectorEnd, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateMultiplicityElement_value_specification_constant(connectorEnd, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateMultiplicityElement_lower_is_integer(connectorEnd, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateMultiplicityElement_upper_is_unlimitedNatural(connectorEnd, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateConnectorEnd_role_and_part_with_port(connectorEnd, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateConnectorEnd_part_with_port_empty(connectorEnd, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateConnectorEnd_multiplicity(connectorEnd, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateConnectorEnd_self_part_with_port(connectorEnd, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the role_and_part_with_port constraint of '<em>Connector End</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} connectorEnd
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateConnectorEnd_role_and_part_with_port(connectorEnd : uml.ConnectorEnd, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return connectorEnd.role_and_part_with_port(diagnostics, context);
        }

        /**
         * Validates the part_with_port_empty constraint of '<em>Connector End</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} connectorEnd
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateConnectorEnd_part_with_port_empty(connectorEnd : uml.ConnectorEnd, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return connectorEnd.part_with_port_empty(diagnostics, context);
        }

        /**
         * Validates the multiplicity constraint of '<em>Connector End</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} connectorEnd
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateConnectorEnd_multiplicity(connectorEnd : uml.ConnectorEnd, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return connectorEnd.multiplicity(diagnostics, context);
        }

        /**
         * Validates the self_part_with_port constraint of '<em>Connector End</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} connectorEnd
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateConnectorEnd_self_part_with_port(connectorEnd : uml.ConnectorEnd, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return connectorEnd.self_part_with_port(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} multiplicityElement
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateMultiplicityElement(multiplicityElement : uml.MultiplicityElement, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(multiplicityElement, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(multiplicityElement, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(multiplicityElement, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(multiplicityElement, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(multiplicityElement, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(multiplicityElement, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(multiplicityElement, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(multiplicityElement, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(multiplicityElement, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(multiplicityElement, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(multiplicityElement, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateMultiplicityElement_upper_ge_lower(multiplicityElement, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateMultiplicityElement_lower_ge_0(multiplicityElement, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateMultiplicityElement_value_specification_no_side_effects(multiplicityElement, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateMultiplicityElement_value_specification_constant(multiplicityElement, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateMultiplicityElement_lower_is_integer(multiplicityElement, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateMultiplicityElement_upper_is_unlimitedNatural(multiplicityElement, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the upper_ge_lower constraint of '<em>Multiplicity Element</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} multiplicityElement
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateMultiplicityElement_upper_ge_lower(multiplicityElement : uml.MultiplicityElement, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return multiplicityElement.upper_ge_lower(diagnostics, context);
        }

        /**
         * Validates the lower_ge_0 constraint of '<em>Multiplicity Element</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} multiplicityElement
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateMultiplicityElement_lower_ge_0(multiplicityElement : uml.MultiplicityElement, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return multiplicityElement.lower_ge_0(diagnostics, context);
        }

        /**
         * Validates the value_specification_no_side_effects constraint of '<em>Multiplicity Element</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} multiplicityElement
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateMultiplicityElement_value_specification_no_side_effects(multiplicityElement : uml.MultiplicityElement, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return multiplicityElement.value_specification_no_side_effects(diagnostics, context);
        }

        /**
         * Validates the value_specification_constant constraint of '<em>Multiplicity Element</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} multiplicityElement
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateMultiplicityElement_value_specification_constant(multiplicityElement : uml.MultiplicityElement, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return multiplicityElement.value_specification_constant(diagnostics, context);
        }

        /**
         * Validates the lower_is_integer constraint of '<em>Multiplicity Element</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} multiplicityElement
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateMultiplicityElement_lower_is_integer(multiplicityElement : uml.MultiplicityElement, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return multiplicityElement.lower_is_integer(diagnostics, context);
        }

        /**
         * Validates the upper_is_unlimitedNatural constraint of '<em>Multiplicity Element</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} multiplicityElement
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateMultiplicityElement_upper_is_unlimitedNatural(multiplicityElement : uml.MultiplicityElement, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return multiplicityElement.upper_is_unlimitedNatural(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} valueSpecification
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateValueSpecification(valueSpecification : uml.ValueSpecification, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(valueSpecification, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(valueSpecification, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(valueSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(valueSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(valueSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(valueSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(valueSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(valueSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(valueSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(valueSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(valueSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(valueSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(valueSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(valueSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePackageableElement_namespace_needs_visibility(valueSpecification, diagnostics, context) && result;
            return result;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} connectableElementTemplateParameter
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateConnectableElementTemplateParameter(connectableElementTemplateParameter : uml.ConnectableElementTemplateParameter, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(connectableElementTemplateParameter, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(connectableElementTemplateParameter, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(connectableElementTemplateParameter, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(connectableElementTemplateParameter, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(connectableElementTemplateParameter, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(connectableElementTemplateParameter, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(connectableElementTemplateParameter, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(connectableElementTemplateParameter, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(connectableElementTemplateParameter, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(connectableElementTemplateParameter, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(connectableElementTemplateParameter, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateTemplateParameter_must_be_compatible(connectableElementTemplateParameter, diagnostics, context) && result;
            return result;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} deploymentTarget
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateDeploymentTarget(deploymentTarget : uml.DeploymentTarget, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(deploymentTarget, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(deploymentTarget, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(deploymentTarget, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(deploymentTarget, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(deploymentTarget, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(deploymentTarget, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(deploymentTarget, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(deploymentTarget, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(deploymentTarget, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(deploymentTarget, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(deploymentTarget, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(deploymentTarget, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(deploymentTarget, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(deploymentTarget, diagnostics, context) && result;
            return result;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} deployment
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateDeployment(deployment : uml.Deployment, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(deployment, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(deployment, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(deployment, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(deployment, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(deployment, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(deployment, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(deployment, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(deployment, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(deployment, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(deployment, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(deployment, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(deployment, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(deployment, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(deployment, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePackageableElement_namespace_needs_visibility(deployment, diagnostics, context) && result;
            return result;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} dependency
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateDependency(dependency : uml.Dependency, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(dependency, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(dependency, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(dependency, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(dependency, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(dependency, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(dependency, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(dependency, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(dependency, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(dependency, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(dependency, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(dependency, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(dependency, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(dependency, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(dependency, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePackageableElement_namespace_needs_visibility(dependency, diagnostics, context) && result;
            return result;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} deploymentSpecification
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateDeploymentSpecification(deploymentSpecification : uml.DeploymentSpecification, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(deploymentSpecification, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(deploymentSpecification, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(deploymentSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(deploymentSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(deploymentSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(deploymentSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(deploymentSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(deploymentSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(deploymentSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(deploymentSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(deploymentSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(deploymentSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(deploymentSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(deploymentSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_members_distinguishable(deploymentSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_self(deploymentSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_ownedMembers(deploymentSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(deploymentSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(deploymentSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(deploymentSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePackageableElement_namespace_needs_visibility(deploymentSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_specialize_type(deploymentSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_maps_to_generalization_set(deploymentSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_non_final_parents(deploymentSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_no_cycles_in_generalization(deploymentSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateDeploymentSpecification_deployment_target(deploymentSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateDeploymentSpecification_deployed_elements(deploymentSpecification, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the deployment_target constraint of '<em>Deployment Specification</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} deploymentSpecification
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateDeploymentSpecification_deployment_target(deploymentSpecification : uml.DeploymentSpecification, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return deploymentSpecification.deployment_target(diagnostics, context);
        }

        /**
         * Validates the deployed_elements constraint of '<em>Deployment Specification</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} deploymentSpecification
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateDeploymentSpecification_deployed_elements(deploymentSpecification : uml.DeploymentSpecification, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return deploymentSpecification.deployed_elements(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} artifact
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateArtifact(artifact : uml.Artifact, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(artifact, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(artifact, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(artifact, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(artifact, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(artifact, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(artifact, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(artifact, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(artifact, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(artifact, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(artifact, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(artifact, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(artifact, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(artifact, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(artifact, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_members_distinguishable(artifact, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_self(artifact, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_ownedMembers(artifact, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(artifact, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(artifact, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(artifact, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePackageableElement_namespace_needs_visibility(artifact, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_specialize_type(artifact, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_maps_to_generalization_set(artifact, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_non_final_parents(artifact, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_no_cycles_in_generalization(artifact, diagnostics, context) && result;
            return result;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} deployedArtifact
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateDeployedArtifact(deployedArtifact : uml.DeployedArtifact, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(deployedArtifact, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(deployedArtifact, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(deployedArtifact, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(deployedArtifact, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(deployedArtifact, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(deployedArtifact, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(deployedArtifact, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(deployedArtifact, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(deployedArtifact, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(deployedArtifact, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(deployedArtifact, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(deployedArtifact, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(deployedArtifact, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(deployedArtifact, diagnostics, context) && result;
            return result;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} manifestation
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateManifestation(manifestation : uml.Manifestation, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(manifestation, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(manifestation, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(manifestation, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(manifestation, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(manifestation, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(manifestation, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(manifestation, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(manifestation, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(manifestation, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(manifestation, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(manifestation, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(manifestation, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(manifestation, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(manifestation, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePackageableElement_namespace_needs_visibility(manifestation, diagnostics, context) && result;
            return result;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} abstraction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateAbstraction(abstraction : uml.Abstraction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(abstraction, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(abstraction, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(abstraction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(abstraction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(abstraction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(abstraction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(abstraction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(abstraction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(abstraction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(abstraction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(abstraction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(abstraction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(abstraction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(abstraction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePackageableElement_namespace_needs_visibility(abstraction, diagnostics, context) && result;
            return result;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} opaqueExpression
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateOpaqueExpression(opaqueExpression : uml.OpaqueExpression, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(opaqueExpression, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(opaqueExpression, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(opaqueExpression, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(opaqueExpression, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(opaqueExpression, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(opaqueExpression, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(opaqueExpression, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(opaqueExpression, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(opaqueExpression, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(opaqueExpression, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(opaqueExpression, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(opaqueExpression, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(opaqueExpression, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(opaqueExpression, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePackageableElement_namespace_needs_visibility(opaqueExpression, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateOpaqueExpression_language_body_size(opaqueExpression, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateOpaqueExpression_one_return_result_parameter(opaqueExpression, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateOpaqueExpression_only_return_result_parameters(opaqueExpression, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the language_body_size constraint of '<em>Opaque Expression</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} opaqueExpression
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateOpaqueExpression_language_body_size(opaqueExpression : uml.OpaqueExpression, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return opaqueExpression.language_body_size(diagnostics, context);
        }

        /**
         * Validates the one_return_result_parameter constraint of '<em>Opaque Expression</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} opaqueExpression
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateOpaqueExpression_one_return_result_parameter(opaqueExpression : uml.OpaqueExpression, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return opaqueExpression.one_return_result_parameter(diagnostics, context);
        }

        /**
         * Validates the only_return_result_parameters constraint of '<em>Opaque Expression</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} opaqueExpression
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateOpaqueExpression_only_return_result_parameters(opaqueExpression : uml.OpaqueExpression, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return opaqueExpression.only_return_result_parameters(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} parameter
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateParameter(parameter : uml.Parameter, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(parameter, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(parameter, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(parameter, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(parameter, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(parameter, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(parameter, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(parameter, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(parameter, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(parameter, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(parameter, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(parameter, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(parameter, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(parameter, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(parameter, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateMultiplicityElement_upper_ge_lower(parameter, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateMultiplicityElement_lower_ge_0(parameter, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateMultiplicityElement_value_specification_no_side_effects(parameter, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateMultiplicityElement_value_specification_constant(parameter, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateMultiplicityElement_lower_is_integer(parameter, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateMultiplicityElement_upper_is_unlimitedNatural(parameter, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateParameter_in_and_out(parameter, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateParameter_not_exception(parameter, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateParameter_connector_end(parameter, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateParameter_reentrant_behaviors(parameter, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateParameter_stream_and_exception(parameter, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateParameter_object_effect(parameter, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the in_and_out constraint of '<em>Parameter</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} parameter
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateParameter_in_and_out(parameter : uml.Parameter, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return parameter.in_and_out(diagnostics, context);
        }

        /**
         * Validates the not_exception constraint of '<em>Parameter</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} parameter
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateParameter_not_exception(parameter : uml.Parameter, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return parameter.not_exception(diagnostics, context);
        }

        /**
         * Validates the connector_end constraint of '<em>Parameter</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} parameter
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateParameter_connector_end(parameter : uml.Parameter, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return parameter.connector_end(diagnostics, context);
        }

        /**
         * Validates the reentrant_behaviors constraint of '<em>Parameter</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} parameter
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateParameter_reentrant_behaviors(parameter : uml.Parameter, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return parameter.reentrant_behaviors(diagnostics, context);
        }

        /**
         * Validates the stream_and_exception constraint of '<em>Parameter</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} parameter
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateParameter_stream_and_exception(parameter : uml.Parameter, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return parameter.stream_and_exception(diagnostics, context);
        }

        /**
         * Validates the object_effect constraint of '<em>Parameter</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} parameter
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateParameter_object_effect(parameter : uml.Parameter, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return parameter.object_effect(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} operation
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateOperation(operation : uml.Operation, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(operation, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(operation, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(operation, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(operation, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(operation, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(operation, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(operation, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(operation, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(operation, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(operation, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(operation, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(operation, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(operation, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(operation, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_members_distinguishable(operation, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_self(operation, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_ownedMembers(operation, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(operation, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(operation, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(operation, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateBehavioralFeature_abstract_no_method(operation, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateOperation_at_most_one_return(operation, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateOperation_only_body_for_query(operation, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the at_most_one_return constraint of '<em>Operation</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} operation
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateOperation_at_most_one_return(operation : uml.Operation, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return operation.at_most_one_return(diagnostics, context);
        }

        /**
         * Validates the only_body_for_query constraint of '<em>Operation</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} operation
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateOperation_only_body_for_query(operation : uml.Operation, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return operation.only_body_for_query(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} behavioralFeature
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateBehavioralFeature(behavioralFeature : uml.BehavioralFeature, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(behavioralFeature, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(behavioralFeature, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(behavioralFeature, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(behavioralFeature, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(behavioralFeature, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(behavioralFeature, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(behavioralFeature, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(behavioralFeature, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(behavioralFeature, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(behavioralFeature, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(behavioralFeature, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(behavioralFeature, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(behavioralFeature, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(behavioralFeature, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_members_distinguishable(behavioralFeature, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_self(behavioralFeature, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_ownedMembers(behavioralFeature, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(behavioralFeature, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(behavioralFeature, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(behavioralFeature, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateBehavioralFeature_abstract_no_method(behavioralFeature, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the abstract_no_method constraint of '<em>Behavioral Feature</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} behavioralFeature
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateBehavioralFeature_abstract_no_method(behavioralFeature : uml.BehavioralFeature, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return behavioralFeature.abstract_no_method(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} feature
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateFeature(feature : uml.Feature, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(feature, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(feature, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(feature, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(feature, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(feature, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(feature, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(feature, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(feature, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(feature, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(feature, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(feature, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(feature, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(feature, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(feature, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(feature, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(feature, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(feature, diagnostics, context) && result;
            return result;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} redefinableElement
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateRedefinableElement(redefinableElement : uml.RedefinableElement, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(redefinableElement, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(redefinableElement, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(redefinableElement, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(redefinableElement, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(redefinableElement, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(redefinableElement, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(redefinableElement, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(redefinableElement, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(redefinableElement, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(redefinableElement, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(redefinableElement, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(redefinableElement, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(redefinableElement, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(redefinableElement, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(redefinableElement, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(redefinableElement, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(redefinableElement, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the redefinition_consistent constraint of '<em>Redefinable Element</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} redefinableElement
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateRedefinableElement_redefinition_consistent(redefinableElement : uml.RedefinableElement, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return redefinableElement.redefinition_consistent(diagnostics, context);
        }

        /**
         * Validates the non_leaf_redefinition constraint of '<em>Redefinable Element</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} redefinableElement
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateRedefinableElement_non_leaf_redefinition(redefinableElement : uml.RedefinableElement, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return redefinableElement.non_leaf_redefinition(diagnostics, context);
        }

        /**
         * Validates the redefinition_context_valid constraint of '<em>Redefinable Element</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} redefinableElement
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateRedefinableElement_redefinition_context_valid(redefinableElement : uml.RedefinableElement, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return redefinableElement.redefinition_context_valid(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} parameterSet
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateParameterSet(parameterSet : uml.ParameterSet, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(parameterSet, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(parameterSet, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(parameterSet, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(parameterSet, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(parameterSet, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(parameterSet, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(parameterSet, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(parameterSet, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(parameterSet, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(parameterSet, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(parameterSet, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(parameterSet, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(parameterSet, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(parameterSet, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateParameterSet_same_parameterized_entity(parameterSet, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateParameterSet_input(parameterSet, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateParameterSet_two_parameter_sets(parameterSet, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the same_parameterized_entity constraint of '<em>Parameter Set</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} parameterSet
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateParameterSet_same_parameterized_entity(parameterSet : uml.ParameterSet, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return parameterSet.same_parameterized_entity(diagnostics, context);
        }

        /**
         * Validates the input constraint of '<em>Parameter Set</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} parameterSet
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateParameterSet_input(parameterSet : uml.ParameterSet, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return parameterSet.input(diagnostics, context);
        }

        /**
         * Validates the two_parameter_sets constraint of '<em>Parameter Set</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} parameterSet
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateParameterSet_two_parameter_sets(parameterSet : uml.ParameterSet, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return parameterSet.two_parameter_sets(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} constraint
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateConstraint(constraint : uml.Constraint, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(constraint, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(constraint, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(constraint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(constraint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(constraint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(constraint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(constraint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(constraint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(constraint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(constraint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(constraint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(constraint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(constraint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(constraint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePackageableElement_namespace_needs_visibility(constraint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateConstraint_boolean_value(constraint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateConstraint_no_side_effects(constraint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateConstraint_not_apply_to_self(constraint, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the boolean_value constraint of '<em>Constraint</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} constraint
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateConstraint_boolean_value(constraint : uml.Constraint, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return constraint.boolean_value(diagnostics, context);
        }

        /**
         * Validates the no_side_effects constraint of '<em>Constraint</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} constraint
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateConstraint_no_side_effects(constraint : uml.Constraint, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return constraint.no_side_effects(diagnostics, context);
        }

        /**
         * Validates the not_apply_to_self constraint of '<em>Constraint</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} constraint
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateConstraint_not_apply_to_self(constraint : uml.Constraint, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return constraint.not_apply_to_self(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} dataType
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateDataType(dataType : uml.DataType, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(dataType, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(dataType, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(dataType, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(dataType, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(dataType, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(dataType, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(dataType, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(dataType, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(dataType, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(dataType, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(dataType, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(dataType, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(dataType, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(dataType, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_members_distinguishable(dataType, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_self(dataType, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_ownedMembers(dataType, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(dataType, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(dataType, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(dataType, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePackageableElement_namespace_needs_visibility(dataType, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_specialize_type(dataType, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_maps_to_generalization_set(dataType, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_non_final_parents(dataType, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_no_cycles_in_generalization(dataType, diagnostics, context) && result;
            return result;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} interface_
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateInterface(interface_ : uml.Interface, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(interface_, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(interface_, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(interface_, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(interface_, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(interface_, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(interface_, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(interface_, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(interface_, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(interface_, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(interface_, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(interface_, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(interface_, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(interface_, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(interface_, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_members_distinguishable(interface_, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_self(interface_, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_ownedMembers(interface_, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(interface_, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(interface_, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(interface_, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePackageableElement_namespace_needs_visibility(interface_, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_specialize_type(interface_, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_maps_to_generalization_set(interface_, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_non_final_parents(interface_, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_no_cycles_in_generalization(interface_, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateInterface_visibility(interface_, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the visibility constraint of '<em>Interface</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} interface_
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateInterface_visibility(interface_ : uml.Interface, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return interface_.visibility(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} reception
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateReception(reception : uml.Reception, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(reception, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(reception, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(reception, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(reception, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(reception, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(reception, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(reception, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(reception, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(reception, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(reception, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(reception, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(reception, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(reception, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(reception, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_members_distinguishable(reception, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_self(reception, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_ownedMembers(reception, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(reception, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(reception, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(reception, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateBehavioralFeature_abstract_no_method(reception, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateReception_same_name_as_signal(reception, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateReception_same_structure_as_signal(reception, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the same_name_as_signal constraint of '<em>Reception</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} reception
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateReception_same_name_as_signal(reception : uml.Reception, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return reception.same_name_as_signal(diagnostics, context);
        }

        /**
         * Validates the same_structure_as_signal constraint of '<em>Reception</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} reception
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateReception_same_structure_as_signal(reception : uml.Reception, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return reception.same_structure_as_signal(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} signal
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateSignal(signal : uml.Signal, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(signal, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(signal, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(signal, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(signal, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(signal, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(signal, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(signal, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(signal, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(signal, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(signal, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(signal, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(signal, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(signal, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(signal, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_members_distinguishable(signal, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_self(signal, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_ownedMembers(signal, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(signal, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(signal, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(signal, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePackageableElement_namespace_needs_visibility(signal, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_specialize_type(signal, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_maps_to_generalization_set(signal, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_non_final_parents(signal, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_no_cycles_in_generalization(signal, diagnostics, context) && result;
            return result;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} protocolStateMachine
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateProtocolStateMachine(protocolStateMachine : uml.ProtocolStateMachine, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(protocolStateMachine, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(protocolStateMachine, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(protocolStateMachine, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(protocolStateMachine, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(protocolStateMachine, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(protocolStateMachine, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(protocolStateMachine, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(protocolStateMachine, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(protocolStateMachine, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(protocolStateMachine, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(protocolStateMachine, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(protocolStateMachine, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(protocolStateMachine, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(protocolStateMachine, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_members_distinguishable(protocolStateMachine, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_self(protocolStateMachine, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_ownedMembers(protocolStateMachine, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(protocolStateMachine, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(protocolStateMachine, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(protocolStateMachine, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePackageableElement_namespace_needs_visibility(protocolStateMachine, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_specialize_type(protocolStateMachine, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_maps_to_generalization_set(protocolStateMachine, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_non_final_parents(protocolStateMachine, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_no_cycles_in_generalization(protocolStateMachine, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateBehavioredClassifier_class_behavior(protocolStateMachine, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClass_passive_class(protocolStateMachine, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateBehavior_most_one_behavior(protocolStateMachine, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateBehavior_parameters_match(protocolStateMachine, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateBehavior_feature_of_context_classifier(protocolStateMachine, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateStateMachine_connection_points(protocolStateMachine, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateStateMachine_classifier_context(protocolStateMachine, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateStateMachine_method(protocolStateMachine, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateStateMachine_context_classifier(protocolStateMachine, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateProtocolStateMachine_deep_or_shallow_history(protocolStateMachine, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateProtocolStateMachine_entry_exit_do(protocolStateMachine, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateProtocolStateMachine_protocol_transitions(protocolStateMachine, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the deep_or_shallow_history constraint of '<em>Protocol State Machine</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} protocolStateMachine
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateProtocolStateMachine_deep_or_shallow_history(protocolStateMachine : uml.ProtocolStateMachine, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return protocolStateMachine.deep_or_shallow_history(diagnostics, context);
        }

        /**
         * Validates the entry_exit_do constraint of '<em>Protocol State Machine</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} protocolStateMachine
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateProtocolStateMachine_entry_exit_do(protocolStateMachine : uml.ProtocolStateMachine, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return protocolStateMachine.entry_exit_do(diagnostics, context);
        }

        /**
         * Validates the protocol_transitions constraint of '<em>Protocol State Machine</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} protocolStateMachine
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateProtocolStateMachine_protocol_transitions(protocolStateMachine : uml.ProtocolStateMachine, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return protocolStateMachine.protocol_transitions(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} stateMachine
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateStateMachine(stateMachine : uml.StateMachine, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(stateMachine, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(stateMachine, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(stateMachine, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(stateMachine, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(stateMachine, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(stateMachine, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(stateMachine, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(stateMachine, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(stateMachine, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(stateMachine, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(stateMachine, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(stateMachine, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(stateMachine, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(stateMachine, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_members_distinguishable(stateMachine, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_self(stateMachine, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_ownedMembers(stateMachine, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(stateMachine, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(stateMachine, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(stateMachine, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePackageableElement_namespace_needs_visibility(stateMachine, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_specialize_type(stateMachine, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_maps_to_generalization_set(stateMachine, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_non_final_parents(stateMachine, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_no_cycles_in_generalization(stateMachine, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateBehavioredClassifier_class_behavior(stateMachine, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClass_passive_class(stateMachine, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateBehavior_most_one_behavior(stateMachine, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateBehavior_parameters_match(stateMachine, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateBehavior_feature_of_context_classifier(stateMachine, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateStateMachine_connection_points(stateMachine, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateStateMachine_classifier_context(stateMachine, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateStateMachine_method(stateMachine, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateStateMachine_context_classifier(stateMachine, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the connection_points constraint of '<em>State Machine</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} stateMachine
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateStateMachine_connection_points(stateMachine : uml.StateMachine, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return stateMachine.connection_points(diagnostics, context);
        }

        /**
         * Validates the classifier_context constraint of '<em>State Machine</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} stateMachine
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateStateMachine_classifier_context(stateMachine : uml.StateMachine, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return stateMachine.classifier_context(diagnostics, context);
        }

        /**
         * Validates the method constraint of '<em>State Machine</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} stateMachine
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateStateMachine_method(stateMachine : uml.StateMachine, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return stateMachine.method(diagnostics, context);
        }

        /**
         * Validates the context_classifier constraint of '<em>State Machine</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} stateMachine
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateStateMachine_context_classifier(stateMachine : uml.StateMachine, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return stateMachine.context_classifier(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} pseudostate
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validatePseudostate(pseudostate : uml.Pseudostate, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(pseudostate, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(pseudostate, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(pseudostate, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(pseudostate, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(pseudostate, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(pseudostate, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(pseudostate, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(pseudostate, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(pseudostate, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(pseudostate, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(pseudostate, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(pseudostate, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(pseudostate, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(pseudostate, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePseudostate_transitions_outgoing(pseudostate, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePseudostate_choice_vertex(pseudostate, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePseudostate_outgoing_from_initial(pseudostate, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePseudostate_join_vertex(pseudostate, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePseudostate_junction_vertex(pseudostate, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePseudostate_history_vertices(pseudostate, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePseudostate_initial_vertex(pseudostate, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePseudostate_fork_vertex(pseudostate, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePseudostate_transitions_incoming(pseudostate, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the transitions_outgoing constraint of '<em>Pseudostate</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} pseudostate
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validatePseudostate_transitions_outgoing(pseudostate : uml.Pseudostate, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return pseudostate.transitions_outgoing(diagnostics, context);
        }

        /**
         * Validates the choice_vertex constraint of '<em>Pseudostate</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} pseudostate
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validatePseudostate_choice_vertex(pseudostate : uml.Pseudostate, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return pseudostate.choice_vertex(diagnostics, context);
        }

        /**
         * Validates the outgoing_from_initial constraint of '<em>Pseudostate</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} pseudostate
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validatePseudostate_outgoing_from_initial(pseudostate : uml.Pseudostate, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return pseudostate.outgoing_from_initial(diagnostics, context);
        }

        /**
         * Validates the join_vertex constraint of '<em>Pseudostate</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} pseudostate
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validatePseudostate_join_vertex(pseudostate : uml.Pseudostate, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return pseudostate.join_vertex(diagnostics, context);
        }

        /**
         * Validates the junction_vertex constraint of '<em>Pseudostate</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} pseudostate
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validatePseudostate_junction_vertex(pseudostate : uml.Pseudostate, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return pseudostate.junction_vertex(diagnostics, context);
        }

        /**
         * Validates the history_vertices constraint of '<em>Pseudostate</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} pseudostate
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validatePseudostate_history_vertices(pseudostate : uml.Pseudostate, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return pseudostate.history_vertices(diagnostics, context);
        }

        /**
         * Validates the initial_vertex constraint of '<em>Pseudostate</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} pseudostate
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validatePseudostate_initial_vertex(pseudostate : uml.Pseudostate, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return pseudostate.initial_vertex(diagnostics, context);
        }

        /**
         * Validates the fork_vertex constraint of '<em>Pseudostate</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} pseudostate
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validatePseudostate_fork_vertex(pseudostate : uml.Pseudostate, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return pseudostate.fork_vertex(diagnostics, context);
        }

        /**
         * Validates the transitions_incoming constraint of '<em>Pseudostate</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} pseudostate
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validatePseudostate_transitions_incoming(pseudostate : uml.Pseudostate, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return pseudostate.transitions_incoming(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} vertex
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateVertex(vertex : uml.Vertex, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(vertex, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(vertex, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(vertex, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(vertex, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(vertex, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(vertex, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(vertex, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(vertex, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(vertex, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(vertex, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(vertex, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(vertex, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(vertex, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(vertex, diagnostics, context) && result;
            return result;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} region
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateRegion(region : uml.Region, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(region, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(region, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(region, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(region, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(region, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(region, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(region, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(region, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(region, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(region, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(region, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(region, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(region, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(region, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_members_distinguishable(region, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_self(region, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_ownedMembers(region, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(region, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(region, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(region, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRegion_deep_history_vertex(region, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRegion_shallow_history_vertex(region, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRegion_owned(region, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRegion_initial_vertex(region, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the deep_history_vertex constraint of '<em>Region</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} region
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateRegion_deep_history_vertex(region : uml.Region, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return region.deep_history_vertex(diagnostics, context);
        }

        /**
         * Validates the shallow_history_vertex constraint of '<em>Region</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} region
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateRegion_shallow_history_vertex(region : uml.Region, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return region.shallow_history_vertex(diagnostics, context);
        }

        /**
         * Validates the owned constraint of '<em>Region</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} region
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateRegion_owned(region : uml.Region, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return region.owned(diagnostics, context);
        }

        /**
         * Validates the initial_vertex constraint of '<em>Region</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} region
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateRegion_initial_vertex(region : uml.Region, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return region.initial_vertex(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} state
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateState(state : uml.State, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(state, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(state, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(state, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(state, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(state, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(state, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(state, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(state, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(state, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(state, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(state, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(state, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(state, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(state, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_members_distinguishable(state, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_self(state, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_ownedMembers(state, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(state, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(state, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(state, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateState_entry_or_exit(state, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateState_submachine_states(state, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateState_composite_states(state, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateState_destinations_or_sources_of_transitions(state, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateState_submachine_or_regions(state, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the entry_or_exit constraint of '<em>State</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} state
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateState_entry_or_exit(state : uml.State, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return state.entry_or_exit(diagnostics, context);
        }

        /**
         * Validates the submachine_states constraint of '<em>State</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} state
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateState_submachine_states(state : uml.State, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return state.submachine_states(diagnostics, context);
        }

        /**
         * Validates the composite_states constraint of '<em>State</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} state
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateState_composite_states(state : uml.State, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return state.composite_states(diagnostics, context);
        }

        /**
         * Validates the destinations_or_sources_of_transitions constraint of '<em>State</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} state
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateState_destinations_or_sources_of_transitions(state : uml.State, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return state.destinations_or_sources_of_transitions(diagnostics, context);
        }

        /**
         * Validates the submachine_or_regions constraint of '<em>State</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} state
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateState_submachine_or_regions(state : uml.State, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return state.submachine_or_regions(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} connectionPointReference
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateConnectionPointReference(connectionPointReference : uml.ConnectionPointReference, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(connectionPointReference, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(connectionPointReference, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(connectionPointReference, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(connectionPointReference, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(connectionPointReference, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(connectionPointReference, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(connectionPointReference, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(connectionPointReference, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(connectionPointReference, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(connectionPointReference, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(connectionPointReference, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(connectionPointReference, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(connectionPointReference, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(connectionPointReference, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateConnectionPointReference_exit_pseudostates(connectionPointReference, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateConnectionPointReference_entry_pseudostates(connectionPointReference, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the exit_pseudostates constraint of '<em>Connection Point Reference</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} connectionPointReference
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateConnectionPointReference_exit_pseudostates(connectionPointReference : uml.ConnectionPointReference, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return connectionPointReference.exit_pseudostates(diagnostics, context);
        }

        /**
         * Validates the entry_pseudostates constraint of '<em>Connection Point Reference</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} connectionPointReference
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateConnectionPointReference_entry_pseudostates(connectionPointReference : uml.ConnectionPointReference, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return connectionPointReference.entry_pseudostates(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} trigger
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateTrigger(trigger : uml.Trigger, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(trigger, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(trigger, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(trigger, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(trigger, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(trigger, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(trigger, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(trigger, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(trigger, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(trigger, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(trigger, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(trigger, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(trigger, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(trigger, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(trigger, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateTrigger_trigger_with_ports(trigger, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the trigger_with_ports constraint of '<em>Trigger</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} trigger
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateTrigger_trigger_with_ports(trigger : uml.Trigger, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return trigger.trigger_with_ports(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} event
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateEvent(event : uml.Event, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(event, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(event, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(event, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(event, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(event, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(event, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(event, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(event, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(event, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(event, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(event, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(event, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(event, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(event, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePackageableElement_namespace_needs_visibility(event, diagnostics, context) && result;
            return result;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} port
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validatePort(port : uml.Port, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(port, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(port, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(port, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(port, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(port, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(port, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(port, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(port, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(port, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(port, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(port, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(port, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(port, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(port, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(port, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(port, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(port, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateMultiplicityElement_upper_ge_lower(port, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateMultiplicityElement_lower_ge_0(port, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateMultiplicityElement_value_specification_no_side_effects(port, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateMultiplicityElement_value_specification_constant(port, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateMultiplicityElement_lower_is_integer(port, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateMultiplicityElement_upper_is_unlimitedNatural(port, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateProperty_subsetting_context_conforms(port, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateProperty_derived_union_is_read_only(port, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateProperty_multiplicity_of_composite(port, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateProperty_redefined_property_inherited(port, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateProperty_subsetting_rules(port, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateProperty_binding_to_attribute(port, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateProperty_derived_union_is_derived(port, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateProperty_deployment_target(port, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateProperty_subsetted_property_names(port, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateProperty_type_of_opposite_end(port, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateProperty_qualified_is_association_end(port, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePort_port_aggregation(port, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePort_default_value(port, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePort_encapsulated_owner(port, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the port_aggregation constraint of '<em>Port</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} port
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validatePort_port_aggregation(port : uml.Port, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return port.port_aggregation(diagnostics, context);
        }

        /**
         * Validates the default_value constraint of '<em>Port</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} port
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validatePort_default_value(port : uml.Port, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return port.default_value(diagnostics, context);
        }

        /**
         * Validates the encapsulated_owner constraint of '<em>Port</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} port
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validatePort_encapsulated_owner(port : uml.Port, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return port.encapsulated_owner(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} transition
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateTransition(transition : uml.Transition, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(transition, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(transition, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(transition, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(transition, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(transition, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(transition, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(transition, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(transition, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(transition, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(transition, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(transition, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(transition, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(transition, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(transition, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_members_distinguishable(transition, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_self(transition, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_ownedMembers(transition, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(transition, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(transition, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(transition, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateTransition_state_is_external(transition, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateTransition_join_segment_guards(transition, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateTransition_state_is_internal(transition, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateTransition_outgoing_pseudostates(transition, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateTransition_join_segment_state(transition, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateTransition_fork_segment_state(transition, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateTransition_state_is_local(transition, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateTransition_initial_transition(transition, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateTransition_fork_segment_guards(transition, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the state_is_external constraint of '<em>Transition</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} transition
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateTransition_state_is_external(transition : uml.Transition, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return transition.state_is_external(diagnostics, context);
        }

        /**
         * Validates the join_segment_guards constraint of '<em>Transition</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} transition
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateTransition_join_segment_guards(transition : uml.Transition, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return transition.join_segment_guards(diagnostics, context);
        }

        /**
         * Validates the state_is_internal constraint of '<em>Transition</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} transition
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateTransition_state_is_internal(transition : uml.Transition, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return transition.state_is_internal(diagnostics, context);
        }

        /**
         * Validates the outgoing_pseudostates constraint of '<em>Transition</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} transition
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateTransition_outgoing_pseudostates(transition : uml.Transition, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return transition.outgoing_pseudostates(diagnostics, context);
        }

        /**
         * Validates the join_segment_state constraint of '<em>Transition</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} transition
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateTransition_join_segment_state(transition : uml.Transition, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return transition.join_segment_state(diagnostics, context);
        }

        /**
         * Validates the fork_segment_state constraint of '<em>Transition</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} transition
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateTransition_fork_segment_state(transition : uml.Transition, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return transition.fork_segment_state(diagnostics, context);
        }

        /**
         * Validates the state_is_local constraint of '<em>Transition</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} transition
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateTransition_state_is_local(transition : uml.Transition, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return transition.state_is_local(diagnostics, context);
        }

        /**
         * Validates the initial_transition constraint of '<em>Transition</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} transition
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateTransition_initial_transition(transition : uml.Transition, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return transition.initial_transition(diagnostics, context);
        }

        /**
         * Validates the fork_segment_guards constraint of '<em>Transition</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} transition
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateTransition_fork_segment_guards(transition : uml.Transition, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return transition.fork_segment_guards(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} protocolConformance
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateProtocolConformance(protocolConformance : uml.ProtocolConformance, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(protocolConformance, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(protocolConformance, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(protocolConformance, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(protocolConformance, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(protocolConformance, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(protocolConformance, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(protocolConformance, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(protocolConformance, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(protocolConformance, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(protocolConformance, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(protocolConformance, diagnostics, context) && result;
            return result;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} operationTemplateParameter
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateOperationTemplateParameter(operationTemplateParameter : uml.OperationTemplateParameter, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(operationTemplateParameter, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(operationTemplateParameter, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(operationTemplateParameter, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(operationTemplateParameter, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(operationTemplateParameter, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(operationTemplateParameter, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(operationTemplateParameter, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(operationTemplateParameter, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(operationTemplateParameter, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(operationTemplateParameter, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(operationTemplateParameter, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateTemplateParameter_must_be_compatible(operationTemplateParameter, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateOperationTemplateParameter_match_default_signature(operationTemplateParameter, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the match_default_signature constraint of '<em>Operation Template Parameter</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} operationTemplateParameter
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateOperationTemplateParameter_match_default_signature(operationTemplateParameter : uml.OperationTemplateParameter, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return operationTemplateParameter.match_default_signature(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} structuralFeature
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateStructuralFeature(structuralFeature : uml.StructuralFeature, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(structuralFeature, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(structuralFeature, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(structuralFeature, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(structuralFeature, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(structuralFeature, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(structuralFeature, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(structuralFeature, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(structuralFeature, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(structuralFeature, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(structuralFeature, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(structuralFeature, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(structuralFeature, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(structuralFeature, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(structuralFeature, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(structuralFeature, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(structuralFeature, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(structuralFeature, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateMultiplicityElement_upper_ge_lower(structuralFeature, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateMultiplicityElement_lower_ge_0(structuralFeature, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateMultiplicityElement_value_specification_no_side_effects(structuralFeature, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateMultiplicityElement_value_specification_constant(structuralFeature, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateMultiplicityElement_lower_is_integer(structuralFeature, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateMultiplicityElement_upper_is_unlimitedNatural(structuralFeature, diagnostics, context) && result;
            return result;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} packageMerge
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validatePackageMerge(packageMerge : uml.PackageMerge, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(packageMerge, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(packageMerge, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(packageMerge, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(packageMerge, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(packageMerge, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(packageMerge, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(packageMerge, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(packageMerge, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(packageMerge, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(packageMerge, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(packageMerge, diagnostics, context) && result;
            return result;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} profileApplication
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateProfileApplication(profileApplication : uml.ProfileApplication, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(profileApplication, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(profileApplication, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(profileApplication, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(profileApplication, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(profileApplication, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(profileApplication, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(profileApplication, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(profileApplication, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(profileApplication, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(profileApplication, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(profileApplication, diagnostics, context) && result;
            return result;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} enumeration
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateEnumeration(enumeration : uml.Enumeration, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(enumeration, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(enumeration, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(enumeration, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(enumeration, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(enumeration, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(enumeration, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(enumeration, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(enumeration, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(enumeration, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(enumeration, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(enumeration, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(enumeration, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(enumeration, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(enumeration, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_members_distinguishable(enumeration, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_self(enumeration, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_ownedMembers(enumeration, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(enumeration, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(enumeration, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(enumeration, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePackageableElement_namespace_needs_visibility(enumeration, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_specialize_type(enumeration, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_maps_to_generalization_set(enumeration, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_non_final_parents(enumeration, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_no_cycles_in_generalization(enumeration, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateEnumeration_immutable(enumeration, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the immutable constraint of '<em>Enumeration</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} enumeration
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateEnumeration_immutable(enumeration : uml.Enumeration, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return enumeration.immutable(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} enumerationLiteral
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateEnumerationLiteral(enumerationLiteral : uml.EnumerationLiteral, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(enumerationLiteral, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(enumerationLiteral, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(enumerationLiteral, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(enumerationLiteral, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(enumerationLiteral, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(enumerationLiteral, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(enumerationLiteral, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(enumerationLiteral, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(enumerationLiteral, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(enumerationLiteral, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(enumerationLiteral, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(enumerationLiteral, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(enumerationLiteral, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(enumerationLiteral, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePackageableElement_namespace_needs_visibility(enumerationLiteral, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateInstanceSpecification_deployment_artifact(enumerationLiteral, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateInstanceSpecification_structural_feature(enumerationLiteral, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateInstanceSpecification_defining_feature(enumerationLiteral, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateInstanceSpecification_deployment_target(enumerationLiteral, diagnostics, context) && result;
            return result;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} instanceSpecification
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateInstanceSpecification(instanceSpecification : uml.InstanceSpecification, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(instanceSpecification, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(instanceSpecification, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(instanceSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(instanceSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(instanceSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(instanceSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(instanceSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(instanceSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(instanceSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(instanceSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(instanceSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(instanceSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(instanceSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(instanceSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePackageableElement_namespace_needs_visibility(instanceSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateInstanceSpecification_deployment_artifact(instanceSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateInstanceSpecification_structural_feature(instanceSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateInstanceSpecification_defining_feature(instanceSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateInstanceSpecification_deployment_target(instanceSpecification, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the deployment_artifact constraint of '<em>Instance Specification</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} instanceSpecification
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateInstanceSpecification_deployment_artifact(instanceSpecification : uml.InstanceSpecification, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return instanceSpecification.deployment_artifact(diagnostics, context);
        }

        /**
         * Validates the structural_feature constraint of '<em>Instance Specification</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} instanceSpecification
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateInstanceSpecification_structural_feature(instanceSpecification : uml.InstanceSpecification, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return instanceSpecification.structural_feature(diagnostics, context);
        }

        /**
         * Validates the defining_feature constraint of '<em>Instance Specification</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} instanceSpecification
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateInstanceSpecification_defining_feature(instanceSpecification : uml.InstanceSpecification, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return instanceSpecification.defining_feature(diagnostics, context);
        }

        /**
         * Validates the deployment_target constraint of '<em>Instance Specification</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} instanceSpecification
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateInstanceSpecification_deployment_target(instanceSpecification : uml.InstanceSpecification, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return instanceSpecification.deployment_target(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} slot
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateSlot(slot : uml.Slot, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(slot, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(slot, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(slot, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(slot, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(slot, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(slot, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(slot, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(slot, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(slot, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(slot, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(slot, diagnostics, context) && result;
            return result;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} primitiveType
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validatePrimitiveType(primitiveType : uml.PrimitiveType, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(primitiveType, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(primitiveType, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(primitiveType, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(primitiveType, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(primitiveType, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(primitiveType, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(primitiveType, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(primitiveType, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(primitiveType, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(primitiveType, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(primitiveType, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(primitiveType, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(primitiveType, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(primitiveType, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_members_distinguishable(primitiveType, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_self(primitiveType, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_ownedMembers(primitiveType, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(primitiveType, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(primitiveType, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(primitiveType, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePackageableElement_namespace_needs_visibility(primitiveType, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_specialize_type(primitiveType, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_maps_to_generalization_set(primitiveType, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_non_final_parents(primitiveType, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_no_cycles_in_generalization(primitiveType, diagnostics, context) && result;
            return result;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} elementImport
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateElementImport(elementImport : uml.ElementImport, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(elementImport, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(elementImport, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(elementImport, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(elementImport, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(elementImport, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(elementImport, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(elementImport, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(elementImport, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(elementImport, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(elementImport, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(elementImport, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElementImport_imported_element_is_public(elementImport, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElementImport_visibility_public_or_private(elementImport, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the imported_element_is_public constraint of '<em>Element Import</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} elementImport
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateElementImport_imported_element_is_public(elementImport : uml.ElementImport, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return elementImport.imported_element_is_public(diagnostics, context);
        }

        /**
         * Validates the visibility_public_or_private constraint of '<em>Element Import</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} elementImport
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateElementImport_visibility_public_or_private(elementImport : uml.ElementImport, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return elementImport.visibility_public_or_private(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} packageImport
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validatePackageImport(packageImport : uml.PackageImport, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(packageImport, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(packageImport, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(packageImport, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(packageImport, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(packageImport, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(packageImport, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(packageImport, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(packageImport, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(packageImport, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(packageImport, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(packageImport, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePackageImport_public_or_private(packageImport, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the public_or_private constraint of '<em>Package Import</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} packageImport
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validatePackageImport_public_or_private(packageImport : uml.PackageImport, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return packageImport.public_or_private(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} extension
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateExtension(extension : uml.Extension, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(extension, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(extension, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(extension, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(extension, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(extension, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(extension, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(extension, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(extension, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(extension, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(extension, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(extension, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(extension, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(extension, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(extension, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_members_distinguishable(extension, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_self(extension, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_ownedMembers(extension, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(extension, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(extension, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(extension, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePackageableElement_namespace_needs_visibility(extension, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_specialize_type(extension, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_maps_to_generalization_set(extension, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_non_final_parents(extension, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_no_cycles_in_generalization(extension, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateAssociation_specialized_end_number(extension, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateAssociation_specialized_end_types(extension, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateAssociation_binary_associations(extension, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateAssociation_association_ends(extension, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateAssociation_ends_must_be_typed(extension, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateExtension_non_owned_end(extension, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateExtension_is_binary(extension, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the non_owned_end constraint of '<em>Extension</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} extension
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateExtension_non_owned_end(extension : uml.Extension, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return extension.non_owned_end(diagnostics, context);
        }

        /**
         * Validates the is_binary constraint of '<em>Extension</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} extension
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateExtension_is_binary(extension : uml.Extension, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return extension.is_binary(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} extensionEnd
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateExtensionEnd(extensionEnd : uml.ExtensionEnd, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(extensionEnd, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(extensionEnd, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(extensionEnd, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(extensionEnd, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(extensionEnd, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(extensionEnd, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(extensionEnd, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(extensionEnd, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(extensionEnd, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(extensionEnd, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(extensionEnd, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(extensionEnd, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(extensionEnd, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(extensionEnd, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(extensionEnd, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(extensionEnd, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(extensionEnd, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateMultiplicityElement_upper_ge_lower(extensionEnd, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateMultiplicityElement_lower_ge_0(extensionEnd, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateMultiplicityElement_value_specification_no_side_effects(extensionEnd, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateMultiplicityElement_value_specification_constant(extensionEnd, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateMultiplicityElement_lower_is_integer(extensionEnd, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateMultiplicityElement_upper_is_unlimitedNatural(extensionEnd, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateProperty_subsetting_context_conforms(extensionEnd, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateProperty_derived_union_is_read_only(extensionEnd, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateProperty_multiplicity_of_composite(extensionEnd, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateProperty_redefined_property_inherited(extensionEnd, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateProperty_subsetting_rules(extensionEnd, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateProperty_binding_to_attribute(extensionEnd, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateProperty_derived_union_is_derived(extensionEnd, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateProperty_deployment_target(extensionEnd, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateProperty_subsetted_property_names(extensionEnd, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateProperty_type_of_opposite_end(extensionEnd, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateProperty_qualified_is_association_end(extensionEnd, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateExtensionEnd_multiplicity(extensionEnd, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateExtensionEnd_aggregation(extensionEnd, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the multiplicity constraint of '<em>Extension End</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} extensionEnd
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateExtensionEnd_multiplicity(extensionEnd : uml.ExtensionEnd, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return extensionEnd.multiplicity(diagnostics, context);
        }

        /**
         * Validates the aggregation constraint of '<em>Extension End</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} extensionEnd
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateExtensionEnd_aggregation(extensionEnd : uml.ExtensionEnd, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return extensionEnd.aggregation(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} model
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateModel(model : uml.Model, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(model, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(model, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(model, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(model, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(model, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(model, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(model, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(model, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(model, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(model, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(model, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(model, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(model, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(model, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_members_distinguishable(model, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_self(model, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_ownedMembers(model, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePackageableElement_namespace_needs_visibility(model, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePackage_elements_public_or_private(model, diagnostics, context) && result;
            return result;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} stringExpression
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateStringExpression(stringExpression : uml.StringExpression, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(stringExpression, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(stringExpression, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(stringExpression, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(stringExpression, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(stringExpression, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(stringExpression, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(stringExpression, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(stringExpression, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(stringExpression, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(stringExpression, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(stringExpression, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(stringExpression, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(stringExpression, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(stringExpression, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePackageableElement_namespace_needs_visibility(stringExpression, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateStringExpression_operands(stringExpression, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateStringExpression_subexpressions(stringExpression, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the operands constraint of '<em>String Expression</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} stringExpression
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateStringExpression_operands(stringExpression : uml.StringExpression, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return stringExpression.operands(diagnostics, context);
        }

        /**
         * Validates the subexpressions constraint of '<em>String Expression</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} stringExpression
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateStringExpression_subexpressions(stringExpression : uml.StringExpression, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return stringExpression.subexpressions(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} expression
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateExpression(expression : uml.Expression, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(expression, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(expression, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(expression, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(expression, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(expression, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(expression, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(expression, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(expression, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(expression, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(expression, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(expression, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(expression, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(expression, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(expression, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePackageableElement_namespace_needs_visibility(expression, diagnostics, context) && result;
            return result;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} usage
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateUsage(usage : uml.Usage, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(usage, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(usage, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(usage, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(usage, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(usage, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(usage, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(usage, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(usage, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(usage, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(usage, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(usage, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(usage, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(usage, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(usage, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePackageableElement_namespace_needs_visibility(usage, diagnostics, context) && result;
            return result;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} collaborationUse
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateCollaborationUse(collaborationUse : uml.CollaborationUse, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(collaborationUse, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(collaborationUse, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(collaborationUse, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(collaborationUse, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(collaborationUse, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(collaborationUse, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(collaborationUse, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(collaborationUse, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(collaborationUse, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(collaborationUse, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(collaborationUse, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(collaborationUse, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(collaborationUse, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(collaborationUse, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateCollaborationUse_client_elements(collaborationUse, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateCollaborationUse_every_role(collaborationUse, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateCollaborationUse_connectors(collaborationUse, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the client_elements constraint of '<em>Collaboration Use</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} collaborationUse
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateCollaborationUse_client_elements(collaborationUse : uml.CollaborationUse, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return collaborationUse.client_elements(diagnostics, context);
        }

        /**
         * Validates the every_role constraint of '<em>Collaboration Use</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} collaborationUse
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateCollaborationUse_every_role(collaborationUse : uml.CollaborationUse, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return collaborationUse.every_role(diagnostics, context);
        }

        /**
         * Validates the connectors constraint of '<em>Collaboration Use</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} collaborationUse
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateCollaborationUse_connectors(collaborationUse : uml.CollaborationUse, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return collaborationUse.connectors(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} collaboration
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateCollaboration(collaboration : uml.Collaboration, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(collaboration, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(collaboration, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(collaboration, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(collaboration, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(collaboration, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(collaboration, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(collaboration, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(collaboration, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(collaboration, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(collaboration, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(collaboration, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(collaboration, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(collaboration, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(collaboration, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_members_distinguishable(collaboration, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_self(collaboration, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_ownedMembers(collaboration, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(collaboration, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(collaboration, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(collaboration, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePackageableElement_namespace_needs_visibility(collaboration, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_specialize_type(collaboration, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_maps_to_generalization_set(collaboration, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_non_final_parents(collaboration, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_no_cycles_in_generalization(collaboration, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateBehavioredClassifier_class_behavior(collaboration, diagnostics, context) && result;
            return result;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} structuredClassifier
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateStructuredClassifier(structuredClassifier : uml.StructuredClassifier, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(structuredClassifier, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(structuredClassifier, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(structuredClassifier, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(structuredClassifier, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(structuredClassifier, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(structuredClassifier, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(structuredClassifier, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(structuredClassifier, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(structuredClassifier, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(structuredClassifier, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(structuredClassifier, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(structuredClassifier, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(structuredClassifier, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(structuredClassifier, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_members_distinguishable(structuredClassifier, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_self(structuredClassifier, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_ownedMembers(structuredClassifier, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(structuredClassifier, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(structuredClassifier, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(structuredClassifier, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePackageableElement_namespace_needs_visibility(structuredClassifier, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_specialize_type(structuredClassifier, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_maps_to_generalization_set(structuredClassifier, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_non_final_parents(structuredClassifier, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_no_cycles_in_generalization(structuredClassifier, diagnostics, context) && result;
            return result;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} connector
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateConnector(connector : uml.Connector, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(connector, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(connector, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(connector, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(connector, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(connector, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(connector, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(connector, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(connector, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(connector, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(connector, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(connector, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(connector, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(connector, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(connector, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(connector, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(connector, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(connector, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateConnector_types(connector, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateConnector_roles(connector, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the types constraint of '<em>Connector</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} connector
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateConnector_types(connector : uml.Connector, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return connector.types(diagnostics, context);
        }

        /**
         * Validates the roles constraint of '<em>Connector</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} connector
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateConnector_roles(connector : uml.Connector, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return connector.roles(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} generalization
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateGeneralization(generalization : uml.Generalization, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(generalization, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(generalization, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(generalization, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(generalization, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(generalization, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(generalization, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(generalization, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(generalization, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(generalization, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(generalization, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(generalization, diagnostics, context) && result;
            return result;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} generalizationSet
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateGeneralizationSet(generalizationSet : uml.GeneralizationSet, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(generalizationSet, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(generalizationSet, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(generalizationSet, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(generalizationSet, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(generalizationSet, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(generalizationSet, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(generalizationSet, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(generalizationSet, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(generalizationSet, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(generalizationSet, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(generalizationSet, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(generalizationSet, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(generalizationSet, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(generalizationSet, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePackageableElement_namespace_needs_visibility(generalizationSet, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateGeneralizationSet_generalization_same_classifier(generalizationSet, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateGeneralizationSet_maps_to_generalization_set(generalizationSet, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the generalization_same_classifier constraint of '<em>Generalization Set</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} generalizationSet
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateGeneralizationSet_generalization_same_classifier(generalizationSet : uml.GeneralizationSet, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return generalizationSet.generalization_same_classifier(diagnostics, context);
        }

        /**
         * Validates the maps_to_generalization_set constraint of '<em>Generalization Set</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} generalizationSet
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateGeneralizationSet_maps_to_generalization_set(generalizationSet : uml.GeneralizationSet, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return generalizationSet.maps_to_generalization_set(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} redefinableTemplateSignature
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateRedefinableTemplateSignature(redefinableTemplateSignature : uml.RedefinableTemplateSignature, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(redefinableTemplateSignature, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(redefinableTemplateSignature, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(redefinableTemplateSignature, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(redefinableTemplateSignature, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(redefinableTemplateSignature, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(redefinableTemplateSignature, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(redefinableTemplateSignature, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(redefinableTemplateSignature, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(redefinableTemplateSignature, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(redefinableTemplateSignature, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(redefinableTemplateSignature, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(redefinableTemplateSignature, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(redefinableTemplateSignature, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(redefinableTemplateSignature, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(redefinableTemplateSignature, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(redefinableTemplateSignature, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(redefinableTemplateSignature, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateTemplateSignature_own_elements(redefinableTemplateSignature, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateTemplateSignature_unique_parameters(redefinableTemplateSignature, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableTemplateSignature_redefines_parents(redefinableTemplateSignature, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the redefines_parents constraint of '<em>Redefinable Template Signature</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} redefinableTemplateSignature
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateRedefinableTemplateSignature_redefines_parents(redefinableTemplateSignature : uml.RedefinableTemplateSignature, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return redefinableTemplateSignature.redefines_parents(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} useCase
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateUseCase(useCase : uml.UseCase, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(useCase, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(useCase, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(useCase, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(useCase, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(useCase, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(useCase, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(useCase, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(useCase, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(useCase, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(useCase, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(useCase, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(useCase, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(useCase, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(useCase, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_members_distinguishable(useCase, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_self(useCase, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_ownedMembers(useCase, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(useCase, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(useCase, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(useCase, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePackageableElement_namespace_needs_visibility(useCase, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_specialize_type(useCase, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_maps_to_generalization_set(useCase, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_non_final_parents(useCase, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_no_cycles_in_generalization(useCase, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateBehavioredClassifier_class_behavior(useCase, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateUseCase_binary_associations(useCase, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateUseCase_no_association_to_use_case(useCase, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateUseCase_cannot_include_self(useCase, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateUseCase_must_have_name(useCase, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the binary_associations constraint of '<em>Use Case</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} useCase
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateUseCase_binary_associations(useCase : uml.UseCase, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return useCase.binary_associations(diagnostics, context);
        }

        /**
         * Validates the no_association_to_use_case constraint of '<em>Use Case</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} useCase
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateUseCase_no_association_to_use_case(useCase : uml.UseCase, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return useCase.no_association_to_use_case(diagnostics, context);
        }

        /**
         * Validates the cannot_include_self constraint of '<em>Use Case</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} useCase
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateUseCase_cannot_include_self(useCase : uml.UseCase, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return useCase.cannot_include_self(diagnostics, context);
        }

        /**
         * Validates the must_have_name constraint of '<em>Use Case</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} useCase
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateUseCase_must_have_name(useCase : uml.UseCase, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return useCase.must_have_name(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} extend
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateExtend(extend : uml.Extend, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(extend, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(extend, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(extend, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(extend, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(extend, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(extend, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(extend, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(extend, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(extend, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(extend, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(extend, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(extend, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(extend, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(extend, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateExtend_extension_points(extend, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the extension_points constraint of '<em>Extend</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} extend
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateExtend_extension_points(extend : uml.Extend, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return extend.extension_points(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} extensionPoint
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateExtensionPoint(extensionPoint : uml.ExtensionPoint, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(extensionPoint, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(extensionPoint, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(extensionPoint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(extensionPoint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(extensionPoint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(extensionPoint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(extensionPoint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(extensionPoint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(extensionPoint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(extensionPoint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(extensionPoint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(extensionPoint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(extensionPoint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(extensionPoint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(extensionPoint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(extensionPoint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(extensionPoint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateExtensionPoint_must_have_name(extensionPoint, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the must_have_name constraint of '<em>Extension Point</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} extensionPoint
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateExtensionPoint_must_have_name(extensionPoint : uml.ExtensionPoint, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return extensionPoint.must_have_name(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} include
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateInclude(include : uml.Include, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(include, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(include, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(include, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(include, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(include, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(include, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(include, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(include, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(include, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(include, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(include, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(include, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(include, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(include, diagnostics, context) && result;
            return result;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} substitution
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateSubstitution(substitution : uml.Substitution, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(substitution, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(substitution, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(substitution, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(substitution, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(substitution, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(substitution, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(substitution, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(substitution, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(substitution, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(substitution, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(substitution, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(substitution, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(substitution, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(substitution, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePackageableElement_namespace_needs_visibility(substitution, diagnostics, context) && result;
            return result;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} realization
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateRealization(realization : uml.Realization, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(realization, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(realization, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(realization, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(realization, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(realization, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(realization, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(realization, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(realization, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(realization, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(realization, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(realization, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(realization, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(realization, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(realization, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePackageableElement_namespace_needs_visibility(realization, diagnostics, context) && result;
            return result;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} classifierTemplateParameter
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateClassifierTemplateParameter(classifierTemplateParameter : uml.ClassifierTemplateParameter, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(classifierTemplateParameter, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(classifierTemplateParameter, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(classifierTemplateParameter, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(classifierTemplateParameter, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(classifierTemplateParameter, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(classifierTemplateParameter, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(classifierTemplateParameter, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(classifierTemplateParameter, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(classifierTemplateParameter, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(classifierTemplateParameter, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(classifierTemplateParameter, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateTemplateParameter_must_be_compatible(classifierTemplateParameter, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifierTemplateParameter_has_constraining_classifier(classifierTemplateParameter, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifierTemplateParameter_parametered_element_no_features(classifierTemplateParameter, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifierTemplateParameter_matching_abstract(classifierTemplateParameter, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifierTemplateParameter_actual_is_classifier(classifierTemplateParameter, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifierTemplateParameter_constraining_classifiers_constrain_args(classifierTemplateParameter, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifierTemplateParameter_constraining_classifiers_constrain_parametered_element(classifierTemplateParameter, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the has_constraining_classifier constraint of '<em>Classifier Template Parameter</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} classifierTemplateParameter
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateClassifierTemplateParameter_has_constraining_classifier(classifierTemplateParameter : uml.ClassifierTemplateParameter, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return classifierTemplateParameter.has_constraining_classifier(diagnostics, context);
        }

        /**
         * Validates the parametered_element_no_features constraint of '<em>Classifier Template Parameter</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} classifierTemplateParameter
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateClassifierTemplateParameter_parametered_element_no_features(classifierTemplateParameter : uml.ClassifierTemplateParameter, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return classifierTemplateParameter.parametered_element_no_features(diagnostics, context);
        }

        /**
         * Validates the matching_abstract constraint of '<em>Classifier Template Parameter</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} classifierTemplateParameter
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateClassifierTemplateParameter_matching_abstract(classifierTemplateParameter : uml.ClassifierTemplateParameter, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return classifierTemplateParameter.matching_abstract(diagnostics, context);
        }

        /**
         * Validates the actual_is_classifier constraint of '<em>Classifier Template Parameter</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} classifierTemplateParameter
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateClassifierTemplateParameter_actual_is_classifier(classifierTemplateParameter : uml.ClassifierTemplateParameter, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return classifierTemplateParameter.actual_is_classifier(diagnostics, context);
        }

        /**
         * Validates the constraining_classifiers_constrain_args constraint of '<em>Classifier Template Parameter</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} classifierTemplateParameter
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateClassifierTemplateParameter_constraining_classifiers_constrain_args(classifierTemplateParameter : uml.ClassifierTemplateParameter, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return classifierTemplateParameter.constraining_classifiers_constrain_args(diagnostics, context);
        }

        /**
         * Validates the constraining_classifiers_constrain_parametered_element constraint of '<em>Classifier Template Parameter</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} classifierTemplateParameter
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateClassifierTemplateParameter_constraining_classifiers_constrain_parametered_element(classifierTemplateParameter : uml.ClassifierTemplateParameter, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return classifierTemplateParameter.constraining_classifiers_constrain_parametered_element(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} interfaceRealization
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateInterfaceRealization(interfaceRealization : uml.InterfaceRealization, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(interfaceRealization, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(interfaceRealization, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(interfaceRealization, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(interfaceRealization, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(interfaceRealization, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(interfaceRealization, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(interfaceRealization, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(interfaceRealization, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(interfaceRealization, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(interfaceRealization, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(interfaceRealization, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(interfaceRealization, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(interfaceRealization, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(interfaceRealization, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePackageableElement_namespace_needs_visibility(interfaceRealization, diagnostics, context) && result;
            return result;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} encapsulatedClassifier
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateEncapsulatedClassifier(encapsulatedClassifier : uml.EncapsulatedClassifier, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(encapsulatedClassifier, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(encapsulatedClassifier, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(encapsulatedClassifier, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(encapsulatedClassifier, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(encapsulatedClassifier, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(encapsulatedClassifier, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(encapsulatedClassifier, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(encapsulatedClassifier, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(encapsulatedClassifier, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(encapsulatedClassifier, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(encapsulatedClassifier, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(encapsulatedClassifier, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(encapsulatedClassifier, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(encapsulatedClassifier, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_members_distinguishable(encapsulatedClassifier, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_self(encapsulatedClassifier, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_ownedMembers(encapsulatedClassifier, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(encapsulatedClassifier, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(encapsulatedClassifier, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(encapsulatedClassifier, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePackageableElement_namespace_needs_visibility(encapsulatedClassifier, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_specialize_type(encapsulatedClassifier, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_maps_to_generalization_set(encapsulatedClassifier, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_non_final_parents(encapsulatedClassifier, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_no_cycles_in_generalization(encapsulatedClassifier, diagnostics, context) && result;
            return result;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} activityGroup
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateActivityGroup(activityGroup : uml.ActivityGroup, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(activityGroup, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(activityGroup, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(activityGroup, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(activityGroup, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(activityGroup, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(activityGroup, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(activityGroup, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(activityGroup, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(activityGroup, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(activityGroup, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(activityGroup, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(activityGroup, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(activityGroup, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(activityGroup, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateActivityGroup_nodes_and_edges(activityGroup, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateActivityGroup_not_contained(activityGroup, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the nodes_and_edges constraint of '<em>Activity Group</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} activityGroup
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateActivityGroup_nodes_and_edges(activityGroup : uml.ActivityGroup, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return activityGroup.nodes_and_edges(diagnostics, context);
        }

        /**
         * Validates the not_contained constraint of '<em>Activity Group</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} activityGroup
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateActivityGroup_not_contained(activityGroup : uml.ActivityGroup, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return activityGroup.not_contained(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} activityEdge
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateActivityEdge(activityEdge : uml.ActivityEdge, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(activityEdge, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(activityEdge, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(activityEdge, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(activityEdge, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(activityEdge, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(activityEdge, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(activityEdge, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(activityEdge, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(activityEdge, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(activityEdge, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(activityEdge, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(activityEdge, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(activityEdge, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(activityEdge, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(activityEdge, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(activityEdge, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(activityEdge, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateActivityEdge_source_and_target(activityEdge, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the source_and_target constraint of '<em>Activity Edge</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} activityEdge
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateActivityEdge_source_and_target(activityEdge : uml.ActivityEdge, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return activityEdge.source_and_target(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} activityPartition
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateActivityPartition(activityPartition : uml.ActivityPartition, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(activityPartition, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(activityPartition, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(activityPartition, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(activityPartition, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(activityPartition, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(activityPartition, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(activityPartition, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(activityPartition, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(activityPartition, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(activityPartition, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(activityPartition, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(activityPartition, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(activityPartition, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(activityPartition, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateActivityGroup_nodes_and_edges(activityPartition, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateActivityGroup_not_contained(activityPartition, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateActivityPartition_represents_classifier(activityPartition, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateActivityPartition_represents_property_and_is_contained(activityPartition, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateActivityPartition_represents_property(activityPartition, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateActivityPartition_dimension_not_contained(activityPartition, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the represents_classifier constraint of '<em>Activity Partition</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} activityPartition
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateActivityPartition_represents_classifier(activityPartition : uml.ActivityPartition, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return activityPartition.represents_classifier(diagnostics, context);
        }

        /**
         * Validates the represents_property_and_is_contained constraint of '<em>Activity Partition</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} activityPartition
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateActivityPartition_represents_property_and_is_contained(activityPartition : uml.ActivityPartition, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return activityPartition.represents_property_and_is_contained(diagnostics, context);
        }

        /**
         * Validates the represents_property constraint of '<em>Activity Partition</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} activityPartition
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateActivityPartition_represents_property(activityPartition : uml.ActivityPartition, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return activityPartition.represents_property(diagnostics, context);
        }

        /**
         * Validates the dimension_not_contained constraint of '<em>Activity Partition</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} activityPartition
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateActivityPartition_dimension_not_contained(activityPartition : uml.ActivityPartition, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return activityPartition.dimension_not_contained(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} activityNode
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateActivityNode(activityNode : uml.ActivityNode, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(activityNode, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(activityNode, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(activityNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(activityNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(activityNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(activityNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(activityNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(activityNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(activityNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(activityNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(activityNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(activityNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(activityNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(activityNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(activityNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(activityNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(activityNode, diagnostics, context) && result;
            return result;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} interruptibleActivityRegion
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateInterruptibleActivityRegion(interruptibleActivityRegion : uml.InterruptibleActivityRegion, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(interruptibleActivityRegion, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(interruptibleActivityRegion, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(interruptibleActivityRegion, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(interruptibleActivityRegion, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(interruptibleActivityRegion, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(interruptibleActivityRegion, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(interruptibleActivityRegion, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(interruptibleActivityRegion, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(interruptibleActivityRegion, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(interruptibleActivityRegion, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(interruptibleActivityRegion, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(interruptibleActivityRegion, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(interruptibleActivityRegion, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(interruptibleActivityRegion, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateActivityGroup_nodes_and_edges(interruptibleActivityRegion, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateActivityGroup_not_contained(interruptibleActivityRegion, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateInterruptibleActivityRegion_interrupting_edges(interruptibleActivityRegion, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the interrupting_edges constraint of '<em>Interruptible Activity Region</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} interruptibleActivityRegion
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateInterruptibleActivityRegion_interrupting_edges(interruptibleActivityRegion : uml.InterruptibleActivityRegion, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return interruptibleActivityRegion.interrupting_edges(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} structuredActivityNode
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateStructuredActivityNode(structuredActivityNode : uml.StructuredActivityNode, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(structuredActivityNode, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(structuredActivityNode, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(structuredActivityNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(structuredActivityNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(structuredActivityNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(structuredActivityNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(structuredActivityNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(structuredActivityNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(structuredActivityNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(structuredActivityNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(structuredActivityNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(structuredActivityNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(structuredActivityNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(structuredActivityNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(structuredActivityNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(structuredActivityNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(structuredActivityNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_members_distinguishable(structuredActivityNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_self(structuredActivityNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_ownedMembers(structuredActivityNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateActivityGroup_nodes_and_edges(structuredActivityNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateActivityGroup_not_contained(structuredActivityNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateStructuredActivityNode_output_pin_edges(structuredActivityNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateStructuredActivityNode_edges(structuredActivityNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateStructuredActivityNode_input_pin_edges(structuredActivityNode, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the output_pin_edges constraint of '<em>Structured Activity Node</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} structuredActivityNode
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateStructuredActivityNode_output_pin_edges(structuredActivityNode : uml.StructuredActivityNode, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return structuredActivityNode.output_pin_edges(diagnostics, context);
        }

        /**
         * Validates the edges constraint of '<em>Structured Activity Node</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} structuredActivityNode
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateStructuredActivityNode_edges(structuredActivityNode : uml.StructuredActivityNode, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return structuredActivityNode.edges(diagnostics, context);
        }

        /**
         * Validates the input_pin_edges constraint of '<em>Structured Activity Node</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} structuredActivityNode
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateStructuredActivityNode_input_pin_edges(structuredActivityNode : uml.StructuredActivityNode, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return structuredActivityNode.input_pin_edges(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} action
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateAction(action : uml.Action, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(action, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(action, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(action, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(action, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(action, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(action, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(action, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(action, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(action, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(action, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(action, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(action, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(action, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(action, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(action, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(action, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(action, diagnostics, context) && result;
            return result;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} executableNode
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateExecutableNode(executableNode : uml.ExecutableNode, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(executableNode, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(executableNode, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(executableNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(executableNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(executableNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(executableNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(executableNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(executableNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(executableNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(executableNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(executableNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(executableNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(executableNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(executableNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(executableNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(executableNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(executableNode, diagnostics, context) && result;
            return result;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} exceptionHandler
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateExceptionHandler(exceptionHandler : uml.ExceptionHandler, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(exceptionHandler, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(exceptionHandler, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(exceptionHandler, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(exceptionHandler, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(exceptionHandler, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(exceptionHandler, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(exceptionHandler, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(exceptionHandler, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(exceptionHandler, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(exceptionHandler, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(exceptionHandler, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateExceptionHandler_handler_body_edges(exceptionHandler, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateExceptionHandler_output_pins(exceptionHandler, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateExceptionHandler_one_input(exceptionHandler, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateExceptionHandler_edge_source_target(exceptionHandler, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateExceptionHandler_handler_body_owner(exceptionHandler, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateExceptionHandler_exception_input_type(exceptionHandler, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the handler_body_edges constraint of '<em>Exception Handler</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} exceptionHandler
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateExceptionHandler_handler_body_edges(exceptionHandler : uml.ExceptionHandler, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return exceptionHandler.handler_body_edges(diagnostics, context);
        }

        /**
         * Validates the output_pins constraint of '<em>Exception Handler</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} exceptionHandler
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateExceptionHandler_output_pins(exceptionHandler : uml.ExceptionHandler, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return exceptionHandler.output_pins(diagnostics, context);
        }

        /**
         * Validates the one_input constraint of '<em>Exception Handler</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} exceptionHandler
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateExceptionHandler_one_input(exceptionHandler : uml.ExceptionHandler, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return exceptionHandler.one_input(diagnostics, context);
        }

        /**
         * Validates the edge_source_target constraint of '<em>Exception Handler</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} exceptionHandler
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateExceptionHandler_edge_source_target(exceptionHandler : uml.ExceptionHandler, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return exceptionHandler.edge_source_target(diagnostics, context);
        }

        /**
         * Validates the handler_body_owner constraint of '<em>Exception Handler</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} exceptionHandler
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateExceptionHandler_handler_body_owner(exceptionHandler : uml.ExceptionHandler, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return exceptionHandler.handler_body_owner(diagnostics, context);
        }

        /**
         * Validates the exception_input_type constraint of '<em>Exception Handler</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} exceptionHandler
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateExceptionHandler_exception_input_type(exceptionHandler : uml.ExceptionHandler, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return exceptionHandler.exception_input_type(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} objectNode
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateObjectNode(objectNode : uml.ObjectNode, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(objectNode, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(objectNode, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(objectNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(objectNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(objectNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(objectNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(objectNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(objectNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(objectNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(objectNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(objectNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(objectNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(objectNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(objectNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(objectNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(objectNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(objectNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateObjectNode_input_output_parameter(objectNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateObjectNode_selection_behavior(objectNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateObjectNode_object_flow_edges(objectNode, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the input_output_parameter constraint of '<em>Object Node</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} objectNode
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateObjectNode_input_output_parameter(objectNode : uml.ObjectNode, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return objectNode.input_output_parameter(diagnostics, context);
        }

        /**
         * Validates the selection_behavior constraint of '<em>Object Node</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} objectNode
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateObjectNode_selection_behavior(objectNode : uml.ObjectNode, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return objectNode.selection_behavior(diagnostics, context);
        }

        /**
         * Validates the object_flow_edges constraint of '<em>Object Node</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} objectNode
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateObjectNode_object_flow_edges(objectNode : uml.ObjectNode, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return objectNode.object_flow_edges(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} inputPin
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateInputPin(inputPin : uml.InputPin, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(inputPin, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(inputPin, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(inputPin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(inputPin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(inputPin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(inputPin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(inputPin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(inputPin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(inputPin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(inputPin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(inputPin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(inputPin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(inputPin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(inputPin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(inputPin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(inputPin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(inputPin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateObjectNode_input_output_parameter(inputPin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateObjectNode_selection_behavior(inputPin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateObjectNode_object_flow_edges(inputPin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateMultiplicityElement_upper_ge_lower(inputPin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateMultiplicityElement_lower_ge_0(inputPin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateMultiplicityElement_value_specification_no_side_effects(inputPin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateMultiplicityElement_value_specification_constant(inputPin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateMultiplicityElement_lower_is_integer(inputPin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateMultiplicityElement_upper_is_unlimitedNatural(inputPin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePin_control_pins(inputPin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePin_not_unique(inputPin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateInputPin_outgoing_edges_structured_only(inputPin, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the outgoing_edges_structured_only constraint of '<em>Input Pin</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} inputPin
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateInputPin_outgoing_edges_structured_only(inputPin : uml.InputPin, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return inputPin.outgoing_edges_structured_only(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} pin
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validatePin(pin : uml.Pin, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(pin, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(pin, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(pin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(pin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(pin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(pin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(pin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(pin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(pin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(pin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(pin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(pin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(pin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(pin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(pin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(pin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(pin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateObjectNode_input_output_parameter(pin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateObjectNode_selection_behavior(pin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateObjectNode_object_flow_edges(pin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateMultiplicityElement_upper_ge_lower(pin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateMultiplicityElement_lower_ge_0(pin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateMultiplicityElement_value_specification_no_side_effects(pin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateMultiplicityElement_value_specification_constant(pin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateMultiplicityElement_lower_is_integer(pin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateMultiplicityElement_upper_is_unlimitedNatural(pin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePin_control_pins(pin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePin_not_unique(pin, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the control_pins constraint of '<em>Pin</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} pin
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validatePin_control_pins(pin : uml.Pin, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return pin.control_pins(diagnostics, context);
        }

        /**
         * Validates the not_unique constraint of '<em>Pin</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} pin
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validatePin_not_unique(pin : uml.Pin, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return pin.not_unique(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} outputPin
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateOutputPin(outputPin : uml.OutputPin, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(outputPin, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(outputPin, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(outputPin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(outputPin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(outputPin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(outputPin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(outputPin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(outputPin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(outputPin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(outputPin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(outputPin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(outputPin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(outputPin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(outputPin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(outputPin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(outputPin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(outputPin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateObjectNode_input_output_parameter(outputPin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateObjectNode_selection_behavior(outputPin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateObjectNode_object_flow_edges(outputPin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateMultiplicityElement_upper_ge_lower(outputPin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateMultiplicityElement_lower_ge_0(outputPin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateMultiplicityElement_value_specification_no_side_effects(outputPin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateMultiplicityElement_value_specification_constant(outputPin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateMultiplicityElement_lower_is_integer(outputPin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateMultiplicityElement_upper_is_unlimitedNatural(outputPin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePin_control_pins(outputPin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePin_not_unique(outputPin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateOutputPin_incoming_edges_structured_only(outputPin, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the incoming_edges_structured_only constraint of '<em>Output Pin</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} outputPin
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateOutputPin_incoming_edges_structured_only(outputPin : uml.OutputPin, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return outputPin.incoming_edges_structured_only(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} variable
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateVariable(variable : uml.Variable, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(variable, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(variable, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(variable, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(variable, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(variable, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(variable, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(variable, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(variable, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(variable, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(variable, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(variable, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(variable, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(variable, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(variable, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateMultiplicityElement_upper_ge_lower(variable, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateMultiplicityElement_lower_ge_0(variable, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateMultiplicityElement_value_specification_no_side_effects(variable, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateMultiplicityElement_value_specification_constant(variable, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateMultiplicityElement_lower_is_integer(variable, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateMultiplicityElement_upper_is_unlimitedNatural(variable, diagnostics, context) && result;
            return result;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} valueSpecificationAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateValueSpecificationAction(valueSpecificationAction : uml.ValueSpecificationAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(valueSpecificationAction, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(valueSpecificationAction, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(valueSpecificationAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(valueSpecificationAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(valueSpecificationAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(valueSpecificationAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(valueSpecificationAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(valueSpecificationAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(valueSpecificationAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(valueSpecificationAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(valueSpecificationAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(valueSpecificationAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(valueSpecificationAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(valueSpecificationAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(valueSpecificationAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(valueSpecificationAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(valueSpecificationAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateValueSpecificationAction_multiplicity(valueSpecificationAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateValueSpecificationAction_compatible_type(valueSpecificationAction, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the multiplicity constraint of '<em>Value Specification Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} valueSpecificationAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateValueSpecificationAction_multiplicity(valueSpecificationAction : uml.ValueSpecificationAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return valueSpecificationAction.multiplicity(diagnostics, context);
        }

        /**
         * Validates the compatible_type constraint of '<em>Value Specification Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} valueSpecificationAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateValueSpecificationAction_compatible_type(valueSpecificationAction : uml.ValueSpecificationAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return valueSpecificationAction.compatible_type(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} variableAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateVariableAction(variableAction : uml.VariableAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(variableAction, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(variableAction, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(variableAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(variableAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(variableAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(variableAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(variableAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(variableAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(variableAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(variableAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(variableAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(variableAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(variableAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(variableAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(variableAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(variableAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(variableAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateVariableAction_scope_of_variable(variableAction, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the scope_of_variable constraint of '<em>Variable Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} variableAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateVariableAction_scope_of_variable(variableAction : uml.VariableAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return variableAction.scope_of_variable(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} writeLinkAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateWriteLinkAction(writeLinkAction : uml.WriteLinkAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(writeLinkAction, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(writeLinkAction, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(writeLinkAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(writeLinkAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(writeLinkAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(writeLinkAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(writeLinkAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(writeLinkAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(writeLinkAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(writeLinkAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(writeLinkAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(writeLinkAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(writeLinkAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(writeLinkAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(writeLinkAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(writeLinkAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(writeLinkAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateLinkAction_same_pins(writeLinkAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateLinkAction_same_association(writeLinkAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateLinkAction_not_static(writeLinkAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateWriteLinkAction_allow_access(writeLinkAction, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the allow_access constraint of '<em>Write Link Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} writeLinkAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateWriteLinkAction_allow_access(writeLinkAction : uml.WriteLinkAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return writeLinkAction.allow_access(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} linkAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateLinkAction(linkAction : uml.LinkAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(linkAction, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(linkAction, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(linkAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(linkAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(linkAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(linkAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(linkAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(linkAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(linkAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(linkAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(linkAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(linkAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(linkAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(linkAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(linkAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(linkAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(linkAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateLinkAction_same_pins(linkAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateLinkAction_same_association(linkAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateLinkAction_not_static(linkAction, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the same_pins constraint of '<em>Link Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} linkAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateLinkAction_same_pins(linkAction : uml.LinkAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return linkAction.same_pins(diagnostics, context);
        }

        /**
         * Validates the same_association constraint of '<em>Link Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} linkAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateLinkAction_same_association(linkAction : uml.LinkAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return linkAction.same_association(diagnostics, context);
        }

        /**
         * Validates the not_static constraint of '<em>Link Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} linkAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateLinkAction_not_static(linkAction : uml.LinkAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return linkAction.not_static(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} linkEndData
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateLinkEndData(linkEndData : uml.LinkEndData, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(linkEndData, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(linkEndData, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(linkEndData, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(linkEndData, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(linkEndData, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(linkEndData, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(linkEndData, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(linkEndData, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(linkEndData, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(linkEndData, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(linkEndData, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateLinkEndData_same_type(linkEndData, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateLinkEndData_multiplicity(linkEndData, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateLinkEndData_end_object_input_pin(linkEndData, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateLinkEndData_property_is_association_end(linkEndData, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateLinkEndData_qualifiers(linkEndData, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the same_type constraint of '<em>Link End Data</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} linkEndData
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateLinkEndData_same_type(linkEndData : uml.LinkEndData, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return linkEndData.same_type(diagnostics, context);
        }

        /**
         * Validates the multiplicity constraint of '<em>Link End Data</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} linkEndData
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateLinkEndData_multiplicity(linkEndData : uml.LinkEndData, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return linkEndData.multiplicity(diagnostics, context);
        }

        /**
         * Validates the end_object_input_pin constraint of '<em>Link End Data</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} linkEndData
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateLinkEndData_end_object_input_pin(linkEndData : uml.LinkEndData, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return linkEndData.end_object_input_pin(diagnostics, context);
        }

        /**
         * Validates the property_is_association_end constraint of '<em>Link End Data</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} linkEndData
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateLinkEndData_property_is_association_end(linkEndData : uml.LinkEndData, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return linkEndData.property_is_association_end(diagnostics, context);
        }

        /**
         * Validates the qualifiers constraint of '<em>Link End Data</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} linkEndData
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateLinkEndData_qualifiers(linkEndData : uml.LinkEndData, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return linkEndData.qualifiers(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} qualifierValue
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateQualifierValue(qualifierValue : uml.QualifierValue, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(qualifierValue, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(qualifierValue, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(qualifierValue, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(qualifierValue, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(qualifierValue, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(qualifierValue, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(qualifierValue, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(qualifierValue, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(qualifierValue, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(qualifierValue, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(qualifierValue, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateQualifierValue_multiplicity_of_qualifier(qualifierValue, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateQualifierValue_type_of_qualifier(qualifierValue, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateQualifierValue_qualifier_attribute(qualifierValue, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the multiplicity_of_qualifier constraint of '<em>Qualifier Value</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} qualifierValue
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateQualifierValue_multiplicity_of_qualifier(qualifierValue : uml.QualifierValue, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return qualifierValue.multiplicity_of_qualifier(diagnostics, context);
        }

        /**
         * Validates the type_of_qualifier constraint of '<em>Qualifier Value</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} qualifierValue
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateQualifierValue_type_of_qualifier(qualifierValue : uml.QualifierValue, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return qualifierValue.type_of_qualifier(diagnostics, context);
        }

        /**
         * Validates the qualifier_attribute constraint of '<em>Qualifier Value</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} qualifierValue
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateQualifierValue_qualifier_attribute(qualifierValue : uml.QualifierValue, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return qualifierValue.qualifier_attribute(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} writeStructuralFeatureAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateWriteStructuralFeatureAction(writeStructuralFeatureAction : uml.WriteStructuralFeatureAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(writeStructuralFeatureAction, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(writeStructuralFeatureAction, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(writeStructuralFeatureAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(writeStructuralFeatureAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(writeStructuralFeatureAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(writeStructuralFeatureAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(writeStructuralFeatureAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(writeStructuralFeatureAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(writeStructuralFeatureAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(writeStructuralFeatureAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(writeStructuralFeatureAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(writeStructuralFeatureAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(writeStructuralFeatureAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(writeStructuralFeatureAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(writeStructuralFeatureAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(writeStructuralFeatureAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(writeStructuralFeatureAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateStructuralFeatureAction_multiplicity(writeStructuralFeatureAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateStructuralFeatureAction_object_type(writeStructuralFeatureAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateStructuralFeatureAction_visibility(writeStructuralFeatureAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateStructuralFeatureAction_not_static(writeStructuralFeatureAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateStructuralFeatureAction_one_featuring_classifier(writeStructuralFeatureAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateWriteStructuralFeatureAction_multiplicity_of_result(writeStructuralFeatureAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateWriteStructuralFeatureAction_type_of_value(writeStructuralFeatureAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateWriteStructuralFeatureAction_multiplicity_of_value(writeStructuralFeatureAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateWriteStructuralFeatureAction_type_of_result(writeStructuralFeatureAction, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the multiplicity_of_result constraint of '<em>Write Structural Feature Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} writeStructuralFeatureAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateWriteStructuralFeatureAction_multiplicity_of_result(writeStructuralFeatureAction : uml.WriteStructuralFeatureAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return writeStructuralFeatureAction.multiplicity_of_result(diagnostics, context);
        }

        /**
         * Validates the type_of_value constraint of '<em>Write Structural Feature Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} writeStructuralFeatureAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateWriteStructuralFeatureAction_type_of_value(writeStructuralFeatureAction : uml.WriteStructuralFeatureAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return writeStructuralFeatureAction.type_of_value(diagnostics, context);
        }

        /**
         * Validates the multiplicity_of_value constraint of '<em>Write Structural Feature Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} writeStructuralFeatureAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateWriteStructuralFeatureAction_multiplicity_of_value(writeStructuralFeatureAction : uml.WriteStructuralFeatureAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return writeStructuralFeatureAction.multiplicity_of_value(diagnostics, context);
        }

        /**
         * Validates the type_of_result constraint of '<em>Write Structural Feature Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} writeStructuralFeatureAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateWriteStructuralFeatureAction_type_of_result(writeStructuralFeatureAction : uml.WriteStructuralFeatureAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return writeStructuralFeatureAction.type_of_result(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} structuralFeatureAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateStructuralFeatureAction(structuralFeatureAction : uml.StructuralFeatureAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(structuralFeatureAction, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(structuralFeatureAction, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(structuralFeatureAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(structuralFeatureAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(structuralFeatureAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(structuralFeatureAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(structuralFeatureAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(structuralFeatureAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(structuralFeatureAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(structuralFeatureAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(structuralFeatureAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(structuralFeatureAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(structuralFeatureAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(structuralFeatureAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(structuralFeatureAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(structuralFeatureAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(structuralFeatureAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateStructuralFeatureAction_multiplicity(structuralFeatureAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateStructuralFeatureAction_object_type(structuralFeatureAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateStructuralFeatureAction_visibility(structuralFeatureAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateStructuralFeatureAction_not_static(structuralFeatureAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateStructuralFeatureAction_one_featuring_classifier(structuralFeatureAction, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the multiplicity constraint of '<em>Structural Feature Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} structuralFeatureAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateStructuralFeatureAction_multiplicity(structuralFeatureAction : uml.StructuralFeatureAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return structuralFeatureAction.multiplicity(diagnostics, context);
        }

        /**
         * Validates the object_type constraint of '<em>Structural Feature Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} structuralFeatureAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateStructuralFeatureAction_object_type(structuralFeatureAction : uml.StructuralFeatureAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return structuralFeatureAction.object_type(diagnostics, context);
        }

        /**
         * Validates the visibility constraint of '<em>Structural Feature Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} structuralFeatureAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateStructuralFeatureAction_visibility(structuralFeatureAction : uml.StructuralFeatureAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return structuralFeatureAction.visibility(diagnostics, context);
        }

        /**
         * Validates the not_static constraint of '<em>Structural Feature Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} structuralFeatureAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateStructuralFeatureAction_not_static(structuralFeatureAction : uml.StructuralFeatureAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return structuralFeatureAction.not_static(diagnostics, context);
        }

        /**
         * Validates the one_featuring_classifier constraint of '<em>Structural Feature Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} structuralFeatureAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateStructuralFeatureAction_one_featuring_classifier(structuralFeatureAction : uml.StructuralFeatureAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return structuralFeatureAction.one_featuring_classifier(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} writeVariableAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateWriteVariableAction(writeVariableAction : uml.WriteVariableAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(writeVariableAction, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(writeVariableAction, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(writeVariableAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(writeVariableAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(writeVariableAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(writeVariableAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(writeVariableAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(writeVariableAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(writeVariableAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(writeVariableAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(writeVariableAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(writeVariableAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(writeVariableAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(writeVariableAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(writeVariableAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(writeVariableAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(writeVariableAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateVariableAction_scope_of_variable(writeVariableAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateWriteVariableAction_value_type(writeVariableAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateWriteVariableAction_multiplicity(writeVariableAction, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the value_type constraint of '<em>Write Variable Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} writeVariableAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateWriteVariableAction_value_type(writeVariableAction : uml.WriteVariableAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return writeVariableAction.value_type(diagnostics, context);
        }

        /**
         * Validates the multiplicity constraint of '<em>Write Variable Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} writeVariableAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateWriteVariableAction_multiplicity(writeVariableAction : uml.WriteVariableAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return writeVariableAction.multiplicity(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} acceptCallAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateAcceptCallAction(acceptCallAction : uml.AcceptCallAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(acceptCallAction, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(acceptCallAction, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(acceptCallAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(acceptCallAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(acceptCallAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(acceptCallAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(acceptCallAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(acceptCallAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(acceptCallAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(acceptCallAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(acceptCallAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(acceptCallAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(acceptCallAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(acceptCallAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(acceptCallAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(acceptCallAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(acceptCallAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateAcceptEventAction_one_output_pin(acceptCallAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateAcceptEventAction_no_input_pins(acceptCallAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateAcceptEventAction_no_output_pins(acceptCallAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateAcceptEventAction_unmarshall_signal_events(acceptCallAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateAcceptEventAction_conforming_type(acceptCallAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateAcceptCallAction_result_pins(acceptCallAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateAcceptCallAction_trigger_call_event(acceptCallAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateAcceptCallAction_unmarshall(acceptCallAction, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the result_pins constraint of '<em>Accept Call Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} acceptCallAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateAcceptCallAction_result_pins(acceptCallAction : uml.AcceptCallAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return acceptCallAction.result_pins(diagnostics, context);
        }

        /**
         * Validates the trigger_call_event constraint of '<em>Accept Call Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} acceptCallAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateAcceptCallAction_trigger_call_event(acceptCallAction : uml.AcceptCallAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return acceptCallAction.trigger_call_event(diagnostics, context);
        }

        /**
         * Validates the unmarshall constraint of '<em>Accept Call Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} acceptCallAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateAcceptCallAction_unmarshall(acceptCallAction : uml.AcceptCallAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return acceptCallAction.unmarshall(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} acceptEventAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateAcceptEventAction(acceptEventAction : uml.AcceptEventAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(acceptEventAction, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(acceptEventAction, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(acceptEventAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(acceptEventAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(acceptEventAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(acceptEventAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(acceptEventAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(acceptEventAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(acceptEventAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(acceptEventAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(acceptEventAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(acceptEventAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(acceptEventAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(acceptEventAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(acceptEventAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(acceptEventAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(acceptEventAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateAcceptEventAction_one_output_pin(acceptEventAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateAcceptEventAction_no_input_pins(acceptEventAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateAcceptEventAction_no_output_pins(acceptEventAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateAcceptEventAction_unmarshall_signal_events(acceptEventAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateAcceptEventAction_conforming_type(acceptEventAction, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the one_output_pin constraint of '<em>Accept Event Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} acceptEventAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateAcceptEventAction_one_output_pin(acceptEventAction : uml.AcceptEventAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return acceptEventAction.one_output_pin(diagnostics, context);
        }

        /**
         * Validates the no_input_pins constraint of '<em>Accept Event Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} acceptEventAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateAcceptEventAction_no_input_pins(acceptEventAction : uml.AcceptEventAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return acceptEventAction.no_input_pins(diagnostics, context);
        }

        /**
         * Validates the no_output_pins constraint of '<em>Accept Event Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} acceptEventAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateAcceptEventAction_no_output_pins(acceptEventAction : uml.AcceptEventAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return acceptEventAction.no_output_pins(diagnostics, context);
        }

        /**
         * Validates the unmarshall_signal_events constraint of '<em>Accept Event Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} acceptEventAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateAcceptEventAction_unmarshall_signal_events(acceptEventAction : uml.AcceptEventAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return acceptEventAction.unmarshall_signal_events(diagnostics, context);
        }

        /**
         * Validates the conforming_type constraint of '<em>Accept Event Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} acceptEventAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateAcceptEventAction_conforming_type(acceptEventAction : uml.AcceptEventAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return acceptEventAction.conforming_type(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} actionInputPin
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateActionInputPin(actionInputPin : uml.ActionInputPin, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(actionInputPin, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(actionInputPin, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(actionInputPin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(actionInputPin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(actionInputPin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(actionInputPin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(actionInputPin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(actionInputPin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(actionInputPin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(actionInputPin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(actionInputPin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(actionInputPin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(actionInputPin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(actionInputPin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(actionInputPin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(actionInputPin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(actionInputPin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateObjectNode_input_output_parameter(actionInputPin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateObjectNode_selection_behavior(actionInputPin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateObjectNode_object_flow_edges(actionInputPin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateMultiplicityElement_upper_ge_lower(actionInputPin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateMultiplicityElement_lower_ge_0(actionInputPin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateMultiplicityElement_value_specification_no_side_effects(actionInputPin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateMultiplicityElement_value_specification_constant(actionInputPin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateMultiplicityElement_lower_is_integer(actionInputPin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateMultiplicityElement_upper_is_unlimitedNatural(actionInputPin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePin_control_pins(actionInputPin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePin_not_unique(actionInputPin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateInputPin_outgoing_edges_structured_only(actionInputPin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateActionInputPin_input_pin(actionInputPin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateActionInputPin_one_output_pin(actionInputPin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateActionInputPin_no_control_or_object_flow(actionInputPin, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the input_pin constraint of '<em>Action Input Pin</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} actionInputPin
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateActionInputPin_input_pin(actionInputPin : uml.ActionInputPin, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return actionInputPin.input_pin(diagnostics, context);
        }

        /**
         * Validates the one_output_pin constraint of '<em>Action Input Pin</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} actionInputPin
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateActionInputPin_one_output_pin(actionInputPin : uml.ActionInputPin, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return actionInputPin.one_output_pin(diagnostics, context);
        }

        /**
         * Validates the no_control_or_object_flow constraint of '<em>Action Input Pin</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} actionInputPin
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateActionInputPin_no_control_or_object_flow(actionInputPin : uml.ActionInputPin, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return actionInputPin.no_control_or_object_flow(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} addStructuralFeatureValueAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateAddStructuralFeatureValueAction(addStructuralFeatureValueAction : uml.AddStructuralFeatureValueAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(addStructuralFeatureValueAction, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(addStructuralFeatureValueAction, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(addStructuralFeatureValueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(addStructuralFeatureValueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(addStructuralFeatureValueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(addStructuralFeatureValueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(addStructuralFeatureValueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(addStructuralFeatureValueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(addStructuralFeatureValueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(addStructuralFeatureValueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(addStructuralFeatureValueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(addStructuralFeatureValueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(addStructuralFeatureValueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(addStructuralFeatureValueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(addStructuralFeatureValueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(addStructuralFeatureValueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(addStructuralFeatureValueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateStructuralFeatureAction_multiplicity(addStructuralFeatureValueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateStructuralFeatureAction_object_type(addStructuralFeatureValueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateStructuralFeatureAction_visibility(addStructuralFeatureValueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateStructuralFeatureAction_not_static(addStructuralFeatureValueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateStructuralFeatureAction_one_featuring_classifier(addStructuralFeatureValueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateWriteStructuralFeatureAction_multiplicity_of_result(addStructuralFeatureValueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateWriteStructuralFeatureAction_type_of_value(addStructuralFeatureValueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateWriteStructuralFeatureAction_multiplicity_of_value(addStructuralFeatureValueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateWriteStructuralFeatureAction_type_of_result(addStructuralFeatureValueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateAddStructuralFeatureValueAction_required_value(addStructuralFeatureValueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateAddStructuralFeatureValueAction_insertAt_pin(addStructuralFeatureValueAction, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the required_value constraint of '<em>Add Structural Feature Value Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} addStructuralFeatureValueAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateAddStructuralFeatureValueAction_required_value(addStructuralFeatureValueAction : uml.AddStructuralFeatureValueAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return addStructuralFeatureValueAction.required_value(diagnostics, context);
        }

        /**
         * Validates the insertAt_pin constraint of '<em>Add Structural Feature Value Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} addStructuralFeatureValueAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateAddStructuralFeatureValueAction_insertAt_pin(addStructuralFeatureValueAction : uml.AddStructuralFeatureValueAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return addStructuralFeatureValueAction.insertAt_pin(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} addVariableValueAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateAddVariableValueAction(addVariableValueAction : uml.AddVariableValueAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(addVariableValueAction, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(addVariableValueAction, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(addVariableValueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(addVariableValueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(addVariableValueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(addVariableValueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(addVariableValueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(addVariableValueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(addVariableValueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(addVariableValueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(addVariableValueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(addVariableValueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(addVariableValueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(addVariableValueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(addVariableValueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(addVariableValueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(addVariableValueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateVariableAction_scope_of_variable(addVariableValueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateWriteVariableAction_value_type(addVariableValueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateWriteVariableAction_multiplicity(addVariableValueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateAddVariableValueAction_required_value(addVariableValueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateAddVariableValueAction_insertAt_pin(addVariableValueAction, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the required_value constraint of '<em>Add Variable Value Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} addVariableValueAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateAddVariableValueAction_required_value(addVariableValueAction : uml.AddVariableValueAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return addVariableValueAction.required_value(diagnostics, context);
        }

        /**
         * Validates the insertAt_pin constraint of '<em>Add Variable Value Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} addVariableValueAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateAddVariableValueAction_insertAt_pin(addVariableValueAction : uml.AddVariableValueAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return addVariableValueAction.insertAt_pin(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} broadcastSignalAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateBroadcastSignalAction(broadcastSignalAction : uml.BroadcastSignalAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(broadcastSignalAction, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(broadcastSignalAction, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(broadcastSignalAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(broadcastSignalAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(broadcastSignalAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(broadcastSignalAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(broadcastSignalAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(broadcastSignalAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(broadcastSignalAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(broadcastSignalAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(broadcastSignalAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(broadcastSignalAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(broadcastSignalAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(broadcastSignalAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(broadcastSignalAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(broadcastSignalAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(broadcastSignalAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateBroadcastSignalAction_number_of_arguments(broadcastSignalAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateBroadcastSignalAction_type_ordering_multiplicity(broadcastSignalAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateBroadcastSignalAction_no_onport(broadcastSignalAction, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the number_of_arguments constraint of '<em>Broadcast Signal Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} broadcastSignalAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateBroadcastSignalAction_number_of_arguments(broadcastSignalAction : uml.BroadcastSignalAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return broadcastSignalAction.number_of_arguments(diagnostics, context);
        }

        /**
         * Validates the type_ordering_multiplicity constraint of '<em>Broadcast Signal Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} broadcastSignalAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateBroadcastSignalAction_type_ordering_multiplicity(broadcastSignalAction : uml.BroadcastSignalAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return broadcastSignalAction.type_ordering_multiplicity(diagnostics, context);
        }

        /**
         * Validates the no_onport constraint of '<em>Broadcast Signal Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} broadcastSignalAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateBroadcastSignalAction_no_onport(broadcastSignalAction : uml.BroadcastSignalAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return broadcastSignalAction.no_onport(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} invocationAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateInvocationAction(invocationAction : uml.InvocationAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(invocationAction, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(invocationAction, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(invocationAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(invocationAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(invocationAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(invocationAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(invocationAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(invocationAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(invocationAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(invocationAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(invocationAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(invocationAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(invocationAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(invocationAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(invocationAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(invocationAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(invocationAction, diagnostics, context) && result;
            return result;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} callAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateCallAction(callAction : uml.CallAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(callAction, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(callAction, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(callAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(callAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(callAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(callAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(callAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(callAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(callAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(callAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(callAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(callAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(callAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(callAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(callAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(callAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(callAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateCallAction_argument_pins(callAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateCallAction_result_pins(callAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateCallAction_synchronous_call(callAction, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the argument_pins constraint of '<em>Call Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} callAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateCallAction_argument_pins(callAction : uml.CallAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return callAction.argument_pins(diagnostics, context);
        }

        /**
         * Validates the result_pins constraint of '<em>Call Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} callAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateCallAction_result_pins(callAction : uml.CallAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return callAction.result_pins(diagnostics, context);
        }

        /**
         * Validates the synchronous_call constraint of '<em>Call Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} callAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateCallAction_synchronous_call(callAction : uml.CallAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return callAction.synchronous_call(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} callBehaviorAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateCallBehaviorAction(callBehaviorAction : uml.CallBehaviorAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(callBehaviorAction, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(callBehaviorAction, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(callBehaviorAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(callBehaviorAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(callBehaviorAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(callBehaviorAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(callBehaviorAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(callBehaviorAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(callBehaviorAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(callBehaviorAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(callBehaviorAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(callBehaviorAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(callBehaviorAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(callBehaviorAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(callBehaviorAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(callBehaviorAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(callBehaviorAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateCallAction_argument_pins(callBehaviorAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateCallAction_result_pins(callBehaviorAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateCallAction_synchronous_call(callBehaviorAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateCallBehaviorAction_no_onport(callBehaviorAction, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the no_onport constraint of '<em>Call Behavior Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} callBehaviorAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateCallBehaviorAction_no_onport(callBehaviorAction : uml.CallBehaviorAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return callBehaviorAction.no_onport(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} callOperationAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateCallOperationAction(callOperationAction : uml.CallOperationAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(callOperationAction, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(callOperationAction, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(callOperationAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(callOperationAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(callOperationAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(callOperationAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(callOperationAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(callOperationAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(callOperationAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(callOperationAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(callOperationAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(callOperationAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(callOperationAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(callOperationAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(callOperationAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(callOperationAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(callOperationAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateCallAction_argument_pins(callOperationAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateCallAction_result_pins(callOperationAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateCallAction_synchronous_call(callOperationAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateCallOperationAction_type_target_pin(callOperationAction, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the type_target_pin constraint of '<em>Call Operation Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} callOperationAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateCallOperationAction_type_target_pin(callOperationAction : uml.CallOperationAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return callOperationAction.type_target_pin(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} clause
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateClause(clause : uml.Clause, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(clause, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(clause, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(clause, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(clause, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(clause, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(clause, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(clause, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(clause, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(clause, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(clause, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(clause, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClause_body_output_pins(clause, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClause_decider_output(clause, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClause_test_and_body(clause, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the body_output_pins constraint of '<em>Clause</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} clause
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateClause_body_output_pins(clause : uml.Clause, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return clause.body_output_pins(diagnostics, context);
        }

        /**
         * Validates the decider_output constraint of '<em>Clause</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} clause
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateClause_decider_output(clause : uml.Clause, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return clause.decider_output(diagnostics, context);
        }

        /**
         * Validates the test_and_body constraint of '<em>Clause</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} clause
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateClause_test_and_body(clause : uml.Clause, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return clause.test_and_body(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} clearAssociationAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateClearAssociationAction(clearAssociationAction : uml.ClearAssociationAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(clearAssociationAction, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(clearAssociationAction, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(clearAssociationAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(clearAssociationAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(clearAssociationAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(clearAssociationAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(clearAssociationAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(clearAssociationAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(clearAssociationAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(clearAssociationAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(clearAssociationAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(clearAssociationAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(clearAssociationAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(clearAssociationAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(clearAssociationAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(clearAssociationAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(clearAssociationAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClearAssociationAction_multiplicity(clearAssociationAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClearAssociationAction_same_type(clearAssociationAction, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the multiplicity constraint of '<em>Clear Association Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} clearAssociationAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateClearAssociationAction_multiplicity(clearAssociationAction : uml.ClearAssociationAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return clearAssociationAction.multiplicity(diagnostics, context);
        }

        /**
         * Validates the same_type constraint of '<em>Clear Association Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} clearAssociationAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateClearAssociationAction_same_type(clearAssociationAction : uml.ClearAssociationAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return clearAssociationAction.same_type(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} clearStructuralFeatureAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateClearStructuralFeatureAction(clearStructuralFeatureAction : uml.ClearStructuralFeatureAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(clearStructuralFeatureAction, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(clearStructuralFeatureAction, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(clearStructuralFeatureAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(clearStructuralFeatureAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(clearStructuralFeatureAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(clearStructuralFeatureAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(clearStructuralFeatureAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(clearStructuralFeatureAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(clearStructuralFeatureAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(clearStructuralFeatureAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(clearStructuralFeatureAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(clearStructuralFeatureAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(clearStructuralFeatureAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(clearStructuralFeatureAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(clearStructuralFeatureAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(clearStructuralFeatureAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(clearStructuralFeatureAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateStructuralFeatureAction_multiplicity(clearStructuralFeatureAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateStructuralFeatureAction_object_type(clearStructuralFeatureAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateStructuralFeatureAction_visibility(clearStructuralFeatureAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateStructuralFeatureAction_not_static(clearStructuralFeatureAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateStructuralFeatureAction_one_featuring_classifier(clearStructuralFeatureAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClearStructuralFeatureAction_type_of_result(clearStructuralFeatureAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClearStructuralFeatureAction_multiplicity_of_result(clearStructuralFeatureAction, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the type_of_result constraint of '<em>Clear Structural Feature Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} clearStructuralFeatureAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateClearStructuralFeatureAction_type_of_result(clearStructuralFeatureAction : uml.ClearStructuralFeatureAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return clearStructuralFeatureAction.type_of_result(diagnostics, context);
        }

        /**
         * Validates the multiplicity_of_result constraint of '<em>Clear Structural Feature Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} clearStructuralFeatureAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateClearStructuralFeatureAction_multiplicity_of_result(clearStructuralFeatureAction : uml.ClearStructuralFeatureAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return clearStructuralFeatureAction.multiplicity_of_result(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} clearVariableAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateClearVariableAction(clearVariableAction : uml.ClearVariableAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(clearVariableAction, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(clearVariableAction, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(clearVariableAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(clearVariableAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(clearVariableAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(clearVariableAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(clearVariableAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(clearVariableAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(clearVariableAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(clearVariableAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(clearVariableAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(clearVariableAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(clearVariableAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(clearVariableAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(clearVariableAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(clearVariableAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(clearVariableAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateVariableAction_scope_of_variable(clearVariableAction, diagnostics, context) && result;
            return result;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} conditionalNode
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateConditionalNode(conditionalNode : uml.ConditionalNode, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(conditionalNode, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(conditionalNode, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(conditionalNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(conditionalNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(conditionalNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(conditionalNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(conditionalNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(conditionalNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(conditionalNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(conditionalNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(conditionalNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(conditionalNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(conditionalNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(conditionalNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(conditionalNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(conditionalNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(conditionalNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_members_distinguishable(conditionalNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_self(conditionalNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_ownedMembers(conditionalNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateActivityGroup_nodes_and_edges(conditionalNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateActivityGroup_not_contained(conditionalNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateStructuredActivityNode_output_pin_edges(conditionalNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateStructuredActivityNode_edges(conditionalNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateStructuredActivityNode_input_pin_edges(conditionalNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateConditionalNode_result_no_incoming(conditionalNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateConditionalNode_no_input_pins(conditionalNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateConditionalNode_one_clause_with_executable_node(conditionalNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateConditionalNode_matching_output_pins(conditionalNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateConditionalNode_executable_nodes(conditionalNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateConditionalNode_clause_no_predecessor(conditionalNode, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the result_no_incoming constraint of '<em>Conditional Node</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} conditionalNode
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateConditionalNode_result_no_incoming(conditionalNode : uml.ConditionalNode, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return conditionalNode.result_no_incoming(diagnostics, context);
        }

        /**
         * Validates the no_input_pins constraint of '<em>Conditional Node</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} conditionalNode
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateConditionalNode_no_input_pins(conditionalNode : uml.ConditionalNode, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return conditionalNode.no_input_pins(diagnostics, context);
        }

        /**
         * Validates the one_clause_with_executable_node constraint of '<em>Conditional Node</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} conditionalNode
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateConditionalNode_one_clause_with_executable_node(conditionalNode : uml.ConditionalNode, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return conditionalNode.one_clause_with_executable_node(diagnostics, context);
        }

        /**
         * Validates the matching_output_pins constraint of '<em>Conditional Node</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} conditionalNode
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateConditionalNode_matching_output_pins(conditionalNode : uml.ConditionalNode, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return conditionalNode.matching_output_pins(diagnostics, context);
        }

        /**
         * Validates the executable_nodes constraint of '<em>Conditional Node</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} conditionalNode
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateConditionalNode_executable_nodes(conditionalNode : uml.ConditionalNode, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return conditionalNode.executable_nodes(diagnostics, context);
        }

        /**
         * Validates the clause_no_predecessor constraint of '<em>Conditional Node</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} conditionalNode
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateConditionalNode_clause_no_predecessor(conditionalNode : uml.ConditionalNode, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return conditionalNode.clause_no_predecessor(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} createLinkAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateCreateLinkAction(createLinkAction : uml.CreateLinkAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(createLinkAction, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(createLinkAction, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(createLinkAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(createLinkAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(createLinkAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(createLinkAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(createLinkAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(createLinkAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(createLinkAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(createLinkAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(createLinkAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(createLinkAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(createLinkAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(createLinkAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(createLinkAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(createLinkAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(createLinkAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateLinkAction_same_pins(createLinkAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateLinkAction_same_association(createLinkAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateLinkAction_not_static(createLinkAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateWriteLinkAction_allow_access(createLinkAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateCreateLinkAction_association_not_abstract(createLinkAction, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the association_not_abstract constraint of '<em>Create Link Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} createLinkAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateCreateLinkAction_association_not_abstract(createLinkAction : uml.CreateLinkAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return createLinkAction.association_not_abstract(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} linkEndCreationData
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateLinkEndCreationData(linkEndCreationData : uml.LinkEndCreationData, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(linkEndCreationData, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(linkEndCreationData, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(linkEndCreationData, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(linkEndCreationData, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(linkEndCreationData, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(linkEndCreationData, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(linkEndCreationData, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(linkEndCreationData, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(linkEndCreationData, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(linkEndCreationData, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(linkEndCreationData, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateLinkEndData_same_type(linkEndCreationData, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateLinkEndData_multiplicity(linkEndCreationData, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateLinkEndData_end_object_input_pin(linkEndCreationData, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateLinkEndData_property_is_association_end(linkEndCreationData, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateLinkEndData_qualifiers(linkEndCreationData, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateLinkEndCreationData_insertAt_pin(linkEndCreationData, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the insertAt_pin constraint of '<em>Link End Creation Data</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} linkEndCreationData
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateLinkEndCreationData_insertAt_pin(linkEndCreationData : uml.LinkEndCreationData, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return linkEndCreationData.insertAt_pin(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} createLinkObjectAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateCreateLinkObjectAction(createLinkObjectAction : uml.CreateLinkObjectAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(createLinkObjectAction, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(createLinkObjectAction, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(createLinkObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(createLinkObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(createLinkObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(createLinkObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(createLinkObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(createLinkObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(createLinkObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(createLinkObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(createLinkObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(createLinkObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(createLinkObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(createLinkObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(createLinkObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(createLinkObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(createLinkObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateLinkAction_same_pins(createLinkObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateLinkAction_same_association(createLinkObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateLinkAction_not_static(createLinkObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateWriteLinkAction_allow_access(createLinkObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateCreateLinkAction_association_not_abstract(createLinkObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateCreateLinkObjectAction_multiplicity(createLinkObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateCreateLinkObjectAction_type_of_result(createLinkObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateCreateLinkObjectAction_association_class(createLinkObjectAction, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the multiplicity constraint of '<em>Create Link Object Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} createLinkObjectAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateCreateLinkObjectAction_multiplicity(createLinkObjectAction : uml.CreateLinkObjectAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return createLinkObjectAction.multiplicity(diagnostics, context);
        }

        /**
         * Validates the type_of_result constraint of '<em>Create Link Object Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} createLinkObjectAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateCreateLinkObjectAction_type_of_result(createLinkObjectAction : uml.CreateLinkObjectAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return createLinkObjectAction.type_of_result(diagnostics, context);
        }

        /**
         * Validates the association_class constraint of '<em>Create Link Object Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} createLinkObjectAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateCreateLinkObjectAction_association_class(createLinkObjectAction : uml.CreateLinkObjectAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return createLinkObjectAction.association_class(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} createObjectAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateCreateObjectAction(createObjectAction : uml.CreateObjectAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(createObjectAction, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(createObjectAction, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(createObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(createObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(createObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(createObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(createObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(createObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(createObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(createObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(createObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(createObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(createObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(createObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(createObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(createObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(createObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateCreateObjectAction_classifier_not_abstract(createObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateCreateObjectAction_multiplicity(createObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateCreateObjectAction_classifier_not_association_class(createObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateCreateObjectAction_same_type(createObjectAction, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the classifier_not_abstract constraint of '<em>Create Object Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} createObjectAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateCreateObjectAction_classifier_not_abstract(createObjectAction : uml.CreateObjectAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return createObjectAction.classifier_not_abstract(diagnostics, context);
        }

        /**
         * Validates the multiplicity constraint of '<em>Create Object Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} createObjectAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateCreateObjectAction_multiplicity(createObjectAction : uml.CreateObjectAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return createObjectAction.multiplicity(diagnostics, context);
        }

        /**
         * Validates the classifier_not_association_class constraint of '<em>Create Object Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} createObjectAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateCreateObjectAction_classifier_not_association_class(createObjectAction : uml.CreateObjectAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return createObjectAction.classifier_not_association_class(diagnostics, context);
        }

        /**
         * Validates the same_type constraint of '<em>Create Object Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} createObjectAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateCreateObjectAction_same_type(createObjectAction : uml.CreateObjectAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return createObjectAction.same_type(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} destroyLinkAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateDestroyLinkAction(destroyLinkAction : uml.DestroyLinkAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(destroyLinkAction, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(destroyLinkAction, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(destroyLinkAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(destroyLinkAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(destroyLinkAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(destroyLinkAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(destroyLinkAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(destroyLinkAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(destroyLinkAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(destroyLinkAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(destroyLinkAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(destroyLinkAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(destroyLinkAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(destroyLinkAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(destroyLinkAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(destroyLinkAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(destroyLinkAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateLinkAction_same_pins(destroyLinkAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateLinkAction_same_association(destroyLinkAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateLinkAction_not_static(destroyLinkAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateWriteLinkAction_allow_access(destroyLinkAction, diagnostics, context) && result;
            return result;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} linkEndDestructionData
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateLinkEndDestructionData(linkEndDestructionData : uml.LinkEndDestructionData, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(linkEndDestructionData, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(linkEndDestructionData, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(linkEndDestructionData, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(linkEndDestructionData, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(linkEndDestructionData, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(linkEndDestructionData, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(linkEndDestructionData, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(linkEndDestructionData, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(linkEndDestructionData, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(linkEndDestructionData, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(linkEndDestructionData, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateLinkEndData_same_type(linkEndDestructionData, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateLinkEndData_multiplicity(linkEndDestructionData, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateLinkEndData_end_object_input_pin(linkEndDestructionData, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateLinkEndData_property_is_association_end(linkEndDestructionData, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateLinkEndData_qualifiers(linkEndDestructionData, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateLinkEndDestructionData_destroyAt_pin(linkEndDestructionData, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the destroyAt_pin constraint of '<em>Link End Destruction Data</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} linkEndDestructionData
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateLinkEndDestructionData_destroyAt_pin(linkEndDestructionData : uml.LinkEndDestructionData, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return linkEndDestructionData.destroyAt_pin(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} destroyObjectAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateDestroyObjectAction(destroyObjectAction : uml.DestroyObjectAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(destroyObjectAction, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(destroyObjectAction, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(destroyObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(destroyObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(destroyObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(destroyObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(destroyObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(destroyObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(destroyObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(destroyObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(destroyObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(destroyObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(destroyObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(destroyObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(destroyObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(destroyObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(destroyObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateDestroyObjectAction_multiplicity(destroyObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateDestroyObjectAction_no_type(destroyObjectAction, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the multiplicity constraint of '<em>Destroy Object Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} destroyObjectAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateDestroyObjectAction_multiplicity(destroyObjectAction : uml.DestroyObjectAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return destroyObjectAction.multiplicity(diagnostics, context);
        }

        /**
         * Validates the no_type constraint of '<em>Destroy Object Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} destroyObjectAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateDestroyObjectAction_no_type(destroyObjectAction : uml.DestroyObjectAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return destroyObjectAction.no_type(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} expansionNode
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateExpansionNode(expansionNode : uml.ExpansionNode, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(expansionNode, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(expansionNode, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(expansionNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(expansionNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(expansionNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(expansionNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(expansionNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(expansionNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(expansionNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(expansionNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(expansionNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(expansionNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(expansionNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(expansionNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(expansionNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(expansionNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(expansionNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateObjectNode_input_output_parameter(expansionNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateObjectNode_selection_behavior(expansionNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateObjectNode_object_flow_edges(expansionNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateExpansionNode_region_as_input_or_output(expansionNode, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the region_as_input_or_output constraint of '<em>Expansion Node</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} expansionNode
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateExpansionNode_region_as_input_or_output(expansionNode : uml.ExpansionNode, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return expansionNode.region_as_input_or_output(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} expansionRegion
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateExpansionRegion(expansionRegion : uml.ExpansionRegion, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(expansionRegion, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(expansionRegion, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(expansionRegion, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(expansionRegion, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(expansionRegion, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(expansionRegion, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(expansionRegion, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(expansionRegion, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(expansionRegion, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(expansionRegion, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(expansionRegion, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(expansionRegion, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(expansionRegion, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(expansionRegion, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(expansionRegion, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(expansionRegion, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(expansionRegion, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_members_distinguishable(expansionRegion, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_self(expansionRegion, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_ownedMembers(expansionRegion, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateActivityGroup_nodes_and_edges(expansionRegion, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateActivityGroup_not_contained(expansionRegion, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateStructuredActivityNode_output_pin_edges(expansionRegion, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateStructuredActivityNode_edges(expansionRegion, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateStructuredActivityNode_input_pin_edges(expansionRegion, diagnostics, context) && result;
            return result;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} loopNode
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateLoopNode(loopNode : uml.LoopNode, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(loopNode, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(loopNode, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(loopNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(loopNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(loopNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(loopNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(loopNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(loopNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(loopNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(loopNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(loopNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(loopNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(loopNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(loopNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(loopNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(loopNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(loopNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_members_distinguishable(loopNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_self(loopNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_ownedMembers(loopNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateActivityGroup_nodes_and_edges(loopNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateActivityGroup_not_contained(loopNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateStructuredActivityNode_output_pin_edges(loopNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateStructuredActivityNode_edges(loopNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateStructuredActivityNode_input_pin_edges(loopNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateLoopNode_result_no_incoming(loopNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateLoopNode_input_edges(loopNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateLoopNode_executable_nodes(loopNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateLoopNode_body_output_pins(loopNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateLoopNode_setup_test_and_body(loopNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateLoopNode_matching_output_pins(loopNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateLoopNode_matching_loop_variables(loopNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateLoopNode_matching_result_pins(loopNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateLoopNode_loop_variable_outgoing(loopNode, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the result_no_incoming constraint of '<em>Loop Node</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} loopNode
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateLoopNode_result_no_incoming(loopNode : uml.LoopNode, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return loopNode.result_no_incoming(diagnostics, context);
        }

        /**
         * Validates the input_edges constraint of '<em>Loop Node</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} loopNode
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateLoopNode_input_edges(loopNode : uml.LoopNode, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return loopNode.input_edges(diagnostics, context);
        }

        /**
         * Validates the executable_nodes constraint of '<em>Loop Node</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} loopNode
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateLoopNode_executable_nodes(loopNode : uml.LoopNode, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return loopNode.executable_nodes(diagnostics, context);
        }

        /**
         * Validates the body_output_pins constraint of '<em>Loop Node</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} loopNode
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateLoopNode_body_output_pins(loopNode : uml.LoopNode, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return loopNode.body_output_pins(diagnostics, context);
        }

        /**
         * Validates the setup_test_and_body constraint of '<em>Loop Node</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} loopNode
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateLoopNode_setup_test_and_body(loopNode : uml.LoopNode, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return loopNode.setup_test_and_body(diagnostics, context);
        }

        /**
         * Validates the matching_output_pins constraint of '<em>Loop Node</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} loopNode
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateLoopNode_matching_output_pins(loopNode : uml.LoopNode, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return loopNode.matching_output_pins(diagnostics, context);
        }

        /**
         * Validates the matching_loop_variables constraint of '<em>Loop Node</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} loopNode
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateLoopNode_matching_loop_variables(loopNode : uml.LoopNode, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return loopNode.matching_loop_variables(diagnostics, context);
        }

        /**
         * Validates the matching_result_pins constraint of '<em>Loop Node</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} loopNode
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateLoopNode_matching_result_pins(loopNode : uml.LoopNode, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return loopNode.matching_result_pins(diagnostics, context);
        }

        /**
         * Validates the loop_variable_outgoing constraint of '<em>Loop Node</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} loopNode
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateLoopNode_loop_variable_outgoing(loopNode : uml.LoopNode, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return loopNode.loop_variable_outgoing(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} opaqueAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateOpaqueAction(opaqueAction : uml.OpaqueAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(opaqueAction, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(opaqueAction, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(opaqueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(opaqueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(opaqueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(opaqueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(opaqueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(opaqueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(opaqueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(opaqueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(opaqueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(opaqueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(opaqueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(opaqueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(opaqueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(opaqueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(opaqueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateOpaqueAction_language_body_size(opaqueAction, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the language_body_size constraint of '<em>Opaque Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} opaqueAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateOpaqueAction_language_body_size(opaqueAction : uml.OpaqueAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return opaqueAction.language_body_size(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} raiseExceptionAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateRaiseExceptionAction(raiseExceptionAction : uml.RaiseExceptionAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(raiseExceptionAction, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(raiseExceptionAction, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(raiseExceptionAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(raiseExceptionAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(raiseExceptionAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(raiseExceptionAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(raiseExceptionAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(raiseExceptionAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(raiseExceptionAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(raiseExceptionAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(raiseExceptionAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(raiseExceptionAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(raiseExceptionAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(raiseExceptionAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(raiseExceptionAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(raiseExceptionAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(raiseExceptionAction, diagnostics, context) && result;
            return result;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} readExtentAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateReadExtentAction(readExtentAction : uml.ReadExtentAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(readExtentAction, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(readExtentAction, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(readExtentAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(readExtentAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(readExtentAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(readExtentAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(readExtentAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(readExtentAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(readExtentAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(readExtentAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(readExtentAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(readExtentAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(readExtentAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(readExtentAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(readExtentAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(readExtentAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(readExtentAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateReadExtentAction_type_is_classifier(readExtentAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateReadExtentAction_multiplicity_of_result(readExtentAction, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the type_is_classifier constraint of '<em>Read Extent Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} readExtentAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateReadExtentAction_type_is_classifier(readExtentAction : uml.ReadExtentAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return readExtentAction.type_is_classifier(diagnostics, context);
        }

        /**
         * Validates the multiplicity_of_result constraint of '<em>Read Extent Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} readExtentAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateReadExtentAction_multiplicity_of_result(readExtentAction : uml.ReadExtentAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return readExtentAction.multiplicity_of_result(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} readIsClassifiedObjectAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateReadIsClassifiedObjectAction(readIsClassifiedObjectAction : uml.ReadIsClassifiedObjectAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(readIsClassifiedObjectAction, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(readIsClassifiedObjectAction, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(readIsClassifiedObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(readIsClassifiedObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(readIsClassifiedObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(readIsClassifiedObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(readIsClassifiedObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(readIsClassifiedObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(readIsClassifiedObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(readIsClassifiedObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(readIsClassifiedObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(readIsClassifiedObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(readIsClassifiedObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(readIsClassifiedObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(readIsClassifiedObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(readIsClassifiedObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(readIsClassifiedObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateReadIsClassifiedObjectAction_no_type(readIsClassifiedObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateReadIsClassifiedObjectAction_multiplicity_of_output(readIsClassifiedObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateReadIsClassifiedObjectAction_boolean_result(readIsClassifiedObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateReadIsClassifiedObjectAction_multiplicity_of_input(readIsClassifiedObjectAction, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the no_type constraint of '<em>Read Is Classified Object Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} readIsClassifiedObjectAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateReadIsClassifiedObjectAction_no_type(readIsClassifiedObjectAction : uml.ReadIsClassifiedObjectAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return readIsClassifiedObjectAction.no_type(diagnostics, context);
        }

        /**
         * Validates the multiplicity_of_output constraint of '<em>Read Is Classified Object Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} readIsClassifiedObjectAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateReadIsClassifiedObjectAction_multiplicity_of_output(readIsClassifiedObjectAction : uml.ReadIsClassifiedObjectAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return readIsClassifiedObjectAction.multiplicity_of_output(diagnostics, context);
        }

        /**
         * Validates the boolean_result constraint of '<em>Read Is Classified Object Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} readIsClassifiedObjectAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateReadIsClassifiedObjectAction_boolean_result(readIsClassifiedObjectAction : uml.ReadIsClassifiedObjectAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return readIsClassifiedObjectAction.boolean_result(diagnostics, context);
        }

        /**
         * Validates the multiplicity_of_input constraint of '<em>Read Is Classified Object Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} readIsClassifiedObjectAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateReadIsClassifiedObjectAction_multiplicity_of_input(readIsClassifiedObjectAction : uml.ReadIsClassifiedObjectAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return readIsClassifiedObjectAction.multiplicity_of_input(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} readLinkAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateReadLinkAction(readLinkAction : uml.ReadLinkAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(readLinkAction, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(readLinkAction, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(readLinkAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(readLinkAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(readLinkAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(readLinkAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(readLinkAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(readLinkAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(readLinkAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(readLinkAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(readLinkAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(readLinkAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(readLinkAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(readLinkAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(readLinkAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(readLinkAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(readLinkAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateLinkAction_same_pins(readLinkAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateLinkAction_same_association(readLinkAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateLinkAction_not_static(readLinkAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateReadLinkAction_type_and_ordering(readLinkAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateReadLinkAction_compatible_multiplicity(readLinkAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateReadLinkAction_visibility(readLinkAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateReadLinkAction_one_open_end(readLinkAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateReadLinkAction_navigable_open_end(readLinkAction, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the type_and_ordering constraint of '<em>Read Link Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} readLinkAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateReadLinkAction_type_and_ordering(readLinkAction : uml.ReadLinkAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return readLinkAction.type_and_ordering(diagnostics, context);
        }

        /**
         * Validates the compatible_multiplicity constraint of '<em>Read Link Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} readLinkAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateReadLinkAction_compatible_multiplicity(readLinkAction : uml.ReadLinkAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return readLinkAction.compatible_multiplicity(diagnostics, context);
        }

        /**
         * Validates the visibility constraint of '<em>Read Link Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} readLinkAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateReadLinkAction_visibility(readLinkAction : uml.ReadLinkAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return readLinkAction.visibility(diagnostics, context);
        }

        /**
         * Validates the one_open_end constraint of '<em>Read Link Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} readLinkAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateReadLinkAction_one_open_end(readLinkAction : uml.ReadLinkAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return readLinkAction.one_open_end(diagnostics, context);
        }

        /**
         * Validates the navigable_open_end constraint of '<em>Read Link Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} readLinkAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateReadLinkAction_navigable_open_end(readLinkAction : uml.ReadLinkAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return readLinkAction.navigable_open_end(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} readLinkObjectEndAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateReadLinkObjectEndAction(readLinkObjectEndAction : uml.ReadLinkObjectEndAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(readLinkObjectEndAction, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(readLinkObjectEndAction, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(readLinkObjectEndAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(readLinkObjectEndAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(readLinkObjectEndAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(readLinkObjectEndAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(readLinkObjectEndAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(readLinkObjectEndAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(readLinkObjectEndAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(readLinkObjectEndAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(readLinkObjectEndAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(readLinkObjectEndAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(readLinkObjectEndAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(readLinkObjectEndAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(readLinkObjectEndAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(readLinkObjectEndAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(readLinkObjectEndAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateReadLinkObjectEndAction_property(readLinkObjectEndAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateReadLinkObjectEndAction_multiplicity_of_object(readLinkObjectEndAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateReadLinkObjectEndAction_ends_of_association(readLinkObjectEndAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateReadLinkObjectEndAction_type_of_result(readLinkObjectEndAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateReadLinkObjectEndAction_multiplicity_of_result(readLinkObjectEndAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateReadLinkObjectEndAction_type_of_object(readLinkObjectEndAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateReadLinkObjectEndAction_association_of_association(readLinkObjectEndAction, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the property constraint of '<em>Read Link Object End Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} readLinkObjectEndAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateReadLinkObjectEndAction_property(readLinkObjectEndAction : uml.ReadLinkObjectEndAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return readLinkObjectEndAction.property(diagnostics, context);
        }

        /**
         * Validates the multiplicity_of_object constraint of '<em>Read Link Object End Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} readLinkObjectEndAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateReadLinkObjectEndAction_multiplicity_of_object(readLinkObjectEndAction : uml.ReadLinkObjectEndAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return readLinkObjectEndAction.multiplicity_of_object(diagnostics, context);
        }

        /**
         * Validates the ends_of_association constraint of '<em>Read Link Object End Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} readLinkObjectEndAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateReadLinkObjectEndAction_ends_of_association(readLinkObjectEndAction : uml.ReadLinkObjectEndAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return readLinkObjectEndAction.ends_of_association(diagnostics, context);
        }

        /**
         * Validates the type_of_result constraint of '<em>Read Link Object End Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} readLinkObjectEndAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateReadLinkObjectEndAction_type_of_result(readLinkObjectEndAction : uml.ReadLinkObjectEndAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return readLinkObjectEndAction.type_of_result(diagnostics, context);
        }

        /**
         * Validates the multiplicity_of_result constraint of '<em>Read Link Object End Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} readLinkObjectEndAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateReadLinkObjectEndAction_multiplicity_of_result(readLinkObjectEndAction : uml.ReadLinkObjectEndAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return readLinkObjectEndAction.multiplicity_of_result(diagnostics, context);
        }

        /**
         * Validates the type_of_object constraint of '<em>Read Link Object End Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} readLinkObjectEndAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateReadLinkObjectEndAction_type_of_object(readLinkObjectEndAction : uml.ReadLinkObjectEndAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return readLinkObjectEndAction.type_of_object(diagnostics, context);
        }

        /**
         * Validates the association_of_association constraint of '<em>Read Link Object End Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} readLinkObjectEndAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateReadLinkObjectEndAction_association_of_association(readLinkObjectEndAction : uml.ReadLinkObjectEndAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return readLinkObjectEndAction.association_of_association(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} readLinkObjectEndQualifierAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateReadLinkObjectEndQualifierAction(readLinkObjectEndQualifierAction : uml.ReadLinkObjectEndQualifierAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(readLinkObjectEndQualifierAction, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(readLinkObjectEndQualifierAction, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(readLinkObjectEndQualifierAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(readLinkObjectEndQualifierAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(readLinkObjectEndQualifierAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(readLinkObjectEndQualifierAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(readLinkObjectEndQualifierAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(readLinkObjectEndQualifierAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(readLinkObjectEndQualifierAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(readLinkObjectEndQualifierAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(readLinkObjectEndQualifierAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(readLinkObjectEndQualifierAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(readLinkObjectEndQualifierAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(readLinkObjectEndQualifierAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(readLinkObjectEndQualifierAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(readLinkObjectEndQualifierAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(readLinkObjectEndQualifierAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateReadLinkObjectEndQualifierAction_multiplicity_of_object(readLinkObjectEndQualifierAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateReadLinkObjectEndQualifierAction_type_of_object(readLinkObjectEndQualifierAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateReadLinkObjectEndQualifierAction_multiplicity_of_qualifier(readLinkObjectEndQualifierAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateReadLinkObjectEndQualifierAction_ends_of_association(readLinkObjectEndQualifierAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateReadLinkObjectEndQualifierAction_multiplicity_of_result(readLinkObjectEndQualifierAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateReadLinkObjectEndQualifierAction_same_type(readLinkObjectEndQualifierAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateReadLinkObjectEndQualifierAction_association_of_association(readLinkObjectEndQualifierAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateReadLinkObjectEndQualifierAction_qualifier_attribute(readLinkObjectEndQualifierAction, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the multiplicity_of_object constraint of '<em>Read Link Object End Qualifier Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} readLinkObjectEndQualifierAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateReadLinkObjectEndQualifierAction_multiplicity_of_object(readLinkObjectEndQualifierAction : uml.ReadLinkObjectEndQualifierAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return readLinkObjectEndQualifierAction.multiplicity_of_object(diagnostics, context);
        }

        /**
         * Validates the type_of_object constraint of '<em>Read Link Object End Qualifier Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} readLinkObjectEndQualifierAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateReadLinkObjectEndQualifierAction_type_of_object(readLinkObjectEndQualifierAction : uml.ReadLinkObjectEndQualifierAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return readLinkObjectEndQualifierAction.type_of_object(diagnostics, context);
        }

        /**
         * Validates the multiplicity_of_qualifier constraint of '<em>Read Link Object End Qualifier Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} readLinkObjectEndQualifierAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateReadLinkObjectEndQualifierAction_multiplicity_of_qualifier(readLinkObjectEndQualifierAction : uml.ReadLinkObjectEndQualifierAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return readLinkObjectEndQualifierAction.multiplicity_of_qualifier(diagnostics, context);
        }

        /**
         * Validates the ends_of_association constraint of '<em>Read Link Object End Qualifier Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} readLinkObjectEndQualifierAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateReadLinkObjectEndQualifierAction_ends_of_association(readLinkObjectEndQualifierAction : uml.ReadLinkObjectEndQualifierAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return readLinkObjectEndQualifierAction.ends_of_association(diagnostics, context);
        }

        /**
         * Validates the multiplicity_of_result constraint of '<em>Read Link Object End Qualifier Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} readLinkObjectEndQualifierAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateReadLinkObjectEndQualifierAction_multiplicity_of_result(readLinkObjectEndQualifierAction : uml.ReadLinkObjectEndQualifierAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return readLinkObjectEndQualifierAction.multiplicity_of_result(diagnostics, context);
        }

        /**
         * Validates the same_type constraint of '<em>Read Link Object End Qualifier Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} readLinkObjectEndQualifierAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateReadLinkObjectEndQualifierAction_same_type(readLinkObjectEndQualifierAction : uml.ReadLinkObjectEndQualifierAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return readLinkObjectEndQualifierAction.same_type(diagnostics, context);
        }

        /**
         * Validates the association_of_association constraint of '<em>Read Link Object End Qualifier Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} readLinkObjectEndQualifierAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateReadLinkObjectEndQualifierAction_association_of_association(readLinkObjectEndQualifierAction : uml.ReadLinkObjectEndQualifierAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return readLinkObjectEndQualifierAction.association_of_association(diagnostics, context);
        }

        /**
         * Validates the qualifier_attribute constraint of '<em>Read Link Object End Qualifier Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} readLinkObjectEndQualifierAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateReadLinkObjectEndQualifierAction_qualifier_attribute(readLinkObjectEndQualifierAction : uml.ReadLinkObjectEndQualifierAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return readLinkObjectEndQualifierAction.qualifier_attribute(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} readSelfAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateReadSelfAction(readSelfAction : uml.ReadSelfAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(readSelfAction, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(readSelfAction, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(readSelfAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(readSelfAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(readSelfAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(readSelfAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(readSelfAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(readSelfAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(readSelfAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(readSelfAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(readSelfAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(readSelfAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(readSelfAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(readSelfAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(readSelfAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(readSelfAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(readSelfAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateReadSelfAction_contained(readSelfAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateReadSelfAction_multiplicity(readSelfAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateReadSelfAction_not_static(readSelfAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateReadSelfAction_type(readSelfAction, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the contained constraint of '<em>Read Self Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} readSelfAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateReadSelfAction_contained(readSelfAction : uml.ReadSelfAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return readSelfAction.contained(diagnostics, context);
        }

        /**
         * Validates the multiplicity constraint of '<em>Read Self Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} readSelfAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateReadSelfAction_multiplicity(readSelfAction : uml.ReadSelfAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return readSelfAction.multiplicity(diagnostics, context);
        }

        /**
         * Validates the not_static constraint of '<em>Read Self Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} readSelfAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateReadSelfAction_not_static(readSelfAction : uml.ReadSelfAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return readSelfAction.not_static(diagnostics, context);
        }

        /**
         * Validates the type constraint of '<em>Read Self Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} readSelfAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateReadSelfAction_type(readSelfAction : uml.ReadSelfAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return readSelfAction.type(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} readStructuralFeatureAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateReadStructuralFeatureAction(readStructuralFeatureAction : uml.ReadStructuralFeatureAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(readStructuralFeatureAction, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(readStructuralFeatureAction, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(readStructuralFeatureAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(readStructuralFeatureAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(readStructuralFeatureAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(readStructuralFeatureAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(readStructuralFeatureAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(readStructuralFeatureAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(readStructuralFeatureAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(readStructuralFeatureAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(readStructuralFeatureAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(readStructuralFeatureAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(readStructuralFeatureAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(readStructuralFeatureAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(readStructuralFeatureAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(readStructuralFeatureAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(readStructuralFeatureAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateStructuralFeatureAction_multiplicity(readStructuralFeatureAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateStructuralFeatureAction_object_type(readStructuralFeatureAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateStructuralFeatureAction_visibility(readStructuralFeatureAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateStructuralFeatureAction_not_static(readStructuralFeatureAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateStructuralFeatureAction_one_featuring_classifier(readStructuralFeatureAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateReadStructuralFeatureAction_type_and_ordering(readStructuralFeatureAction, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the type_and_ordering constraint of '<em>Read Structural Feature Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} readStructuralFeatureAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateReadStructuralFeatureAction_type_and_ordering(readStructuralFeatureAction : uml.ReadStructuralFeatureAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return readStructuralFeatureAction.type_and_ordering(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} readVariableAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateReadVariableAction(readVariableAction : uml.ReadVariableAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(readVariableAction, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(readVariableAction, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(readVariableAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(readVariableAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(readVariableAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(readVariableAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(readVariableAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(readVariableAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(readVariableAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(readVariableAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(readVariableAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(readVariableAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(readVariableAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(readVariableAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(readVariableAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(readVariableAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(readVariableAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateVariableAction_scope_of_variable(readVariableAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateReadVariableAction_type_and_ordering(readVariableAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateReadVariableAction_compatible_multiplicity(readVariableAction, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the type_and_ordering constraint of '<em>Read Variable Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} readVariableAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateReadVariableAction_type_and_ordering(readVariableAction : uml.ReadVariableAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return readVariableAction.type_and_ordering(diagnostics, context);
        }

        /**
         * Validates the compatible_multiplicity constraint of '<em>Read Variable Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} readVariableAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateReadVariableAction_compatible_multiplicity(readVariableAction : uml.ReadVariableAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return readVariableAction.compatible_multiplicity(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} reclassifyObjectAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateReclassifyObjectAction(reclassifyObjectAction : uml.ReclassifyObjectAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(reclassifyObjectAction, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(reclassifyObjectAction, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(reclassifyObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(reclassifyObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(reclassifyObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(reclassifyObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(reclassifyObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(reclassifyObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(reclassifyObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(reclassifyObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(reclassifyObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(reclassifyObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(reclassifyObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(reclassifyObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(reclassifyObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(reclassifyObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(reclassifyObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateReclassifyObjectAction_input_pin(reclassifyObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateReclassifyObjectAction_classifier_not_abstract(reclassifyObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateReclassifyObjectAction_multiplicity(reclassifyObjectAction, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the input_pin constraint of '<em>Reclassify Object Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} reclassifyObjectAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateReclassifyObjectAction_input_pin(reclassifyObjectAction : uml.ReclassifyObjectAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return reclassifyObjectAction.input_pin(diagnostics, context);
        }

        /**
         * Validates the classifier_not_abstract constraint of '<em>Reclassify Object Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} reclassifyObjectAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateReclassifyObjectAction_classifier_not_abstract(reclassifyObjectAction : uml.ReclassifyObjectAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return reclassifyObjectAction.classifier_not_abstract(diagnostics, context);
        }

        /**
         * Validates the multiplicity constraint of '<em>Reclassify Object Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} reclassifyObjectAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateReclassifyObjectAction_multiplicity(reclassifyObjectAction : uml.ReclassifyObjectAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return reclassifyObjectAction.multiplicity(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} reduceAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateReduceAction(reduceAction : uml.ReduceAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(reduceAction, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(reduceAction, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(reduceAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(reduceAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(reduceAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(reduceAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(reduceAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(reduceAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(reduceAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(reduceAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(reduceAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(reduceAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(reduceAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(reduceAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(reduceAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(reduceAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(reduceAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateReduceAction_reducer_inputs_output(reduceAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateReduceAction_input_type_is_collection(reduceAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateReduceAction_output_types_are_compatible(reduceAction, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the reducer_inputs_output constraint of '<em>Reduce Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} reduceAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateReduceAction_reducer_inputs_output(reduceAction : uml.ReduceAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return reduceAction.reducer_inputs_output(diagnostics, context);
        }

        /**
         * Validates the input_type_is_collection constraint of '<em>Reduce Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} reduceAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateReduceAction_input_type_is_collection(reduceAction : uml.ReduceAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return reduceAction.input_type_is_collection(diagnostics, context);
        }

        /**
         * Validates the output_types_are_compatible constraint of '<em>Reduce Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} reduceAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateReduceAction_output_types_are_compatible(reduceAction : uml.ReduceAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return reduceAction.output_types_are_compatible(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} removeStructuralFeatureValueAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateRemoveStructuralFeatureValueAction(removeStructuralFeatureValueAction : uml.RemoveStructuralFeatureValueAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(removeStructuralFeatureValueAction, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(removeStructuralFeatureValueAction, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(removeStructuralFeatureValueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(removeStructuralFeatureValueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(removeStructuralFeatureValueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(removeStructuralFeatureValueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(removeStructuralFeatureValueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(removeStructuralFeatureValueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(removeStructuralFeatureValueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(removeStructuralFeatureValueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(removeStructuralFeatureValueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(removeStructuralFeatureValueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(removeStructuralFeatureValueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(removeStructuralFeatureValueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(removeStructuralFeatureValueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(removeStructuralFeatureValueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(removeStructuralFeatureValueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateStructuralFeatureAction_multiplicity(removeStructuralFeatureValueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateStructuralFeatureAction_object_type(removeStructuralFeatureValueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateStructuralFeatureAction_visibility(removeStructuralFeatureValueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateStructuralFeatureAction_not_static(removeStructuralFeatureValueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateStructuralFeatureAction_one_featuring_classifier(removeStructuralFeatureValueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateWriteStructuralFeatureAction_multiplicity_of_result(removeStructuralFeatureValueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateWriteStructuralFeatureAction_type_of_value(removeStructuralFeatureValueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateWriteStructuralFeatureAction_multiplicity_of_value(removeStructuralFeatureValueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateWriteStructuralFeatureAction_type_of_result(removeStructuralFeatureValueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRemoveStructuralFeatureValueAction_removeAt_and_value(removeStructuralFeatureValueAction, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the removeAt_and_value constraint of '<em>Remove Structural Feature Value Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} removeStructuralFeatureValueAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateRemoveStructuralFeatureValueAction_removeAt_and_value(removeStructuralFeatureValueAction : uml.RemoveStructuralFeatureValueAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return removeStructuralFeatureValueAction.removeAt_and_value(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} removeVariableValueAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateRemoveVariableValueAction(removeVariableValueAction : uml.RemoveVariableValueAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(removeVariableValueAction, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(removeVariableValueAction, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(removeVariableValueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(removeVariableValueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(removeVariableValueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(removeVariableValueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(removeVariableValueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(removeVariableValueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(removeVariableValueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(removeVariableValueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(removeVariableValueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(removeVariableValueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(removeVariableValueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(removeVariableValueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(removeVariableValueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(removeVariableValueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(removeVariableValueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateVariableAction_scope_of_variable(removeVariableValueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateWriteVariableAction_value_type(removeVariableValueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateWriteVariableAction_multiplicity(removeVariableValueAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRemoveVariableValueAction_removeAt_and_value(removeVariableValueAction, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the removeAt_and_value constraint of '<em>Remove Variable Value Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} removeVariableValueAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateRemoveVariableValueAction_removeAt_and_value(removeVariableValueAction : uml.RemoveVariableValueAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return removeVariableValueAction.removeAt_and_value(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} replyAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateReplyAction(replyAction : uml.ReplyAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(replyAction, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(replyAction, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(replyAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(replyAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(replyAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(replyAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(replyAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(replyAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(replyAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(replyAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(replyAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(replyAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(replyAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(replyAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(replyAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(replyAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(replyAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateReplyAction_pins_match_parameter(replyAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateReplyAction_event_on_reply_to_call_trigger(replyAction, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the pins_match_parameter constraint of '<em>Reply Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} replyAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateReplyAction_pins_match_parameter(replyAction : uml.ReplyAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return replyAction.pins_match_parameter(diagnostics, context);
        }

        /**
         * Validates the event_on_reply_to_call_trigger constraint of '<em>Reply Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} replyAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateReplyAction_event_on_reply_to_call_trigger(replyAction : uml.ReplyAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return replyAction.event_on_reply_to_call_trigger(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} sendObjectAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateSendObjectAction(sendObjectAction : uml.SendObjectAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(sendObjectAction, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(sendObjectAction, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(sendObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(sendObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(sendObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(sendObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(sendObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(sendObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(sendObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(sendObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(sendObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(sendObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(sendObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(sendObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(sendObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(sendObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(sendObjectAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateSendObjectAction_type_target_pin(sendObjectAction, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the type_target_pin constraint of '<em>Send Object Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} sendObjectAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateSendObjectAction_type_target_pin(sendObjectAction : uml.SendObjectAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return sendObjectAction.type_target_pin(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} sendSignalAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateSendSignalAction(sendSignalAction : uml.SendSignalAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(sendSignalAction, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(sendSignalAction, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(sendSignalAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(sendSignalAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(sendSignalAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(sendSignalAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(sendSignalAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(sendSignalAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(sendSignalAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(sendSignalAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(sendSignalAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(sendSignalAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(sendSignalAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(sendSignalAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(sendSignalAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(sendSignalAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(sendSignalAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateSendSignalAction_type_ordering_multiplicity(sendSignalAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateSendSignalAction_number_order(sendSignalAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateSendSignalAction_type_target_pin(sendSignalAction, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the type_ordering_multiplicity constraint of '<em>Send Signal Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} sendSignalAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateSendSignalAction_type_ordering_multiplicity(sendSignalAction : uml.SendSignalAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return sendSignalAction.type_ordering_multiplicity(diagnostics, context);
        }

        /**
         * Validates the number_order constraint of '<em>Send Signal Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} sendSignalAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateSendSignalAction_number_order(sendSignalAction : uml.SendSignalAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return sendSignalAction.number_order(diagnostics, context);
        }

        /**
         * Validates the type_target_pin constraint of '<em>Send Signal Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} sendSignalAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateSendSignalAction_type_target_pin(sendSignalAction : uml.SendSignalAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return sendSignalAction.type_target_pin(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} sequenceNode
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateSequenceNode(sequenceNode : uml.SequenceNode, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(sequenceNode, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(sequenceNode, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(sequenceNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(sequenceNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(sequenceNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(sequenceNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(sequenceNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(sequenceNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(sequenceNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(sequenceNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(sequenceNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(sequenceNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(sequenceNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(sequenceNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(sequenceNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(sequenceNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(sequenceNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_members_distinguishable(sequenceNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_self(sequenceNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_ownedMembers(sequenceNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateActivityGroup_nodes_and_edges(sequenceNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateActivityGroup_not_contained(sequenceNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateStructuredActivityNode_output_pin_edges(sequenceNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateStructuredActivityNode_edges(sequenceNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateStructuredActivityNode_input_pin_edges(sequenceNode, diagnostics, context) && result;
            return result;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} startClassifierBehaviorAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateStartClassifierBehaviorAction(startClassifierBehaviorAction : uml.StartClassifierBehaviorAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(startClassifierBehaviorAction, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(startClassifierBehaviorAction, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(startClassifierBehaviorAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(startClassifierBehaviorAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(startClassifierBehaviorAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(startClassifierBehaviorAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(startClassifierBehaviorAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(startClassifierBehaviorAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(startClassifierBehaviorAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(startClassifierBehaviorAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(startClassifierBehaviorAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(startClassifierBehaviorAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(startClassifierBehaviorAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(startClassifierBehaviorAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(startClassifierBehaviorAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(startClassifierBehaviorAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(startClassifierBehaviorAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateStartClassifierBehaviorAction_multiplicity(startClassifierBehaviorAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateStartClassifierBehaviorAction_type_has_classifier(startClassifierBehaviorAction, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the multiplicity constraint of '<em>Start Classifier Behavior Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} startClassifierBehaviorAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateStartClassifierBehaviorAction_multiplicity(startClassifierBehaviorAction : uml.StartClassifierBehaviorAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return startClassifierBehaviorAction.multiplicity(diagnostics, context);
        }

        /**
         * Validates the type_has_classifier constraint of '<em>Start Classifier Behavior Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} startClassifierBehaviorAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateStartClassifierBehaviorAction_type_has_classifier(startClassifierBehaviorAction : uml.StartClassifierBehaviorAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return startClassifierBehaviorAction.type_has_classifier(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} startObjectBehaviorAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateStartObjectBehaviorAction(startObjectBehaviorAction : uml.StartObjectBehaviorAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(startObjectBehaviorAction, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(startObjectBehaviorAction, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(startObjectBehaviorAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(startObjectBehaviorAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(startObjectBehaviorAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(startObjectBehaviorAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(startObjectBehaviorAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(startObjectBehaviorAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(startObjectBehaviorAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(startObjectBehaviorAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(startObjectBehaviorAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(startObjectBehaviorAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(startObjectBehaviorAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(startObjectBehaviorAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(startObjectBehaviorAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(startObjectBehaviorAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(startObjectBehaviorAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateCallAction_argument_pins(startObjectBehaviorAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateCallAction_result_pins(startObjectBehaviorAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateCallAction_synchronous_call(startObjectBehaviorAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateStartObjectBehaviorAction_multiplicity_of_object(startObjectBehaviorAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateStartObjectBehaviorAction_type_of_object(startObjectBehaviorAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateStartObjectBehaviorAction_no_onport(startObjectBehaviorAction, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the multiplicity_of_object constraint of '<em>Start Object Behavior Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} startObjectBehaviorAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateStartObjectBehaviorAction_multiplicity_of_object(startObjectBehaviorAction : uml.StartObjectBehaviorAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return startObjectBehaviorAction.multiplicity_of_object(diagnostics, context);
        }

        /**
         * Validates the type_of_object constraint of '<em>Start Object Behavior Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} startObjectBehaviorAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateStartObjectBehaviorAction_type_of_object(startObjectBehaviorAction : uml.StartObjectBehaviorAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return startObjectBehaviorAction.type_of_object(diagnostics, context);
        }

        /**
         * Validates the no_onport constraint of '<em>Start Object Behavior Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} startObjectBehaviorAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateStartObjectBehaviorAction_no_onport(startObjectBehaviorAction : uml.StartObjectBehaviorAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return startObjectBehaviorAction.no_onport(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} testIdentityAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateTestIdentityAction(testIdentityAction : uml.TestIdentityAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(testIdentityAction, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(testIdentityAction, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(testIdentityAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(testIdentityAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(testIdentityAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(testIdentityAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(testIdentityAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(testIdentityAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(testIdentityAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(testIdentityAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(testIdentityAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(testIdentityAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(testIdentityAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(testIdentityAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(testIdentityAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(testIdentityAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(testIdentityAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateTestIdentityAction_multiplicity(testIdentityAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateTestIdentityAction_no_type(testIdentityAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateTestIdentityAction_result_is_boolean(testIdentityAction, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the multiplicity constraint of '<em>Test Identity Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} testIdentityAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateTestIdentityAction_multiplicity(testIdentityAction : uml.TestIdentityAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return testIdentityAction.multiplicity(diagnostics, context);
        }

        /**
         * Validates the no_type constraint of '<em>Test Identity Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} testIdentityAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateTestIdentityAction_no_type(testIdentityAction : uml.TestIdentityAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return testIdentityAction.no_type(diagnostics, context);
        }

        /**
         * Validates the result_is_boolean constraint of '<em>Test Identity Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} testIdentityAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateTestIdentityAction_result_is_boolean(testIdentityAction : uml.TestIdentityAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return testIdentityAction.result_is_boolean(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} unmarshallAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateUnmarshallAction(unmarshallAction : uml.UnmarshallAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(unmarshallAction, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(unmarshallAction, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(unmarshallAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(unmarshallAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(unmarshallAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(unmarshallAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(unmarshallAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(unmarshallAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(unmarshallAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(unmarshallAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(unmarshallAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(unmarshallAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(unmarshallAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(unmarshallAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(unmarshallAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(unmarshallAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(unmarshallAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateUnmarshallAction_structural_feature(unmarshallAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateUnmarshallAction_number_of_result(unmarshallAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateUnmarshallAction_type_ordering_and_multiplicity(unmarshallAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateUnmarshallAction_multiplicity_of_object(unmarshallAction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateUnmarshallAction_object_type(unmarshallAction, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the structural_feature constraint of '<em>Unmarshall Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} unmarshallAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateUnmarshallAction_structural_feature(unmarshallAction : uml.UnmarshallAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return unmarshallAction.structural_feature(diagnostics, context);
        }

        /**
         * Validates the number_of_result constraint of '<em>Unmarshall Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} unmarshallAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateUnmarshallAction_number_of_result(unmarshallAction : uml.UnmarshallAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return unmarshallAction.number_of_result(diagnostics, context);
        }

        /**
         * Validates the type_ordering_and_multiplicity constraint of '<em>Unmarshall Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} unmarshallAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateUnmarshallAction_type_ordering_and_multiplicity(unmarshallAction : uml.UnmarshallAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return unmarshallAction.type_ordering_and_multiplicity(diagnostics, context);
        }

        /**
         * Validates the multiplicity_of_object constraint of '<em>Unmarshall Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} unmarshallAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateUnmarshallAction_multiplicity_of_object(unmarshallAction : uml.UnmarshallAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return unmarshallAction.multiplicity_of_object(diagnostics, context);
        }

        /**
         * Validates the object_type constraint of '<em>Unmarshall Action</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} unmarshallAction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateUnmarshallAction_object_type(unmarshallAction : uml.UnmarshallAction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return unmarshallAction.object_type(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} valuePin
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateValuePin(valuePin : uml.ValuePin, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(valuePin, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(valuePin, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(valuePin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(valuePin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(valuePin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(valuePin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(valuePin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(valuePin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(valuePin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(valuePin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(valuePin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(valuePin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(valuePin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(valuePin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(valuePin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(valuePin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(valuePin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateObjectNode_input_output_parameter(valuePin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateObjectNode_selection_behavior(valuePin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateObjectNode_object_flow_edges(valuePin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateMultiplicityElement_upper_ge_lower(valuePin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateMultiplicityElement_lower_ge_0(valuePin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateMultiplicityElement_value_specification_no_side_effects(valuePin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateMultiplicityElement_value_specification_constant(valuePin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateMultiplicityElement_lower_is_integer(valuePin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateMultiplicityElement_upper_is_unlimitedNatural(valuePin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePin_control_pins(valuePin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePin_not_unique(valuePin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateInputPin_outgoing_edges_structured_only(valuePin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateValuePin_no_incoming_edges(valuePin, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateValuePin_compatible_type(valuePin, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the no_incoming_edges constraint of '<em>Value Pin</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} valuePin
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateValuePin_no_incoming_edges(valuePin : uml.ValuePin, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return valuePin.no_incoming_edges(diagnostics, context);
        }

        /**
         * Validates the compatible_type constraint of '<em>Value Pin</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} valuePin
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateValuePin_compatible_type(valuePin : uml.ValuePin, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return valuePin.compatible_type(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} activityFinalNode
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateActivityFinalNode(activityFinalNode : uml.ActivityFinalNode, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(activityFinalNode, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(activityFinalNode, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(activityFinalNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(activityFinalNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(activityFinalNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(activityFinalNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(activityFinalNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(activityFinalNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(activityFinalNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(activityFinalNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(activityFinalNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(activityFinalNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(activityFinalNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(activityFinalNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(activityFinalNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(activityFinalNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(activityFinalNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateFinalNode_no_outgoing_edges(activityFinalNode, diagnostics, context) && result;
            return result;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} finalNode
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateFinalNode(finalNode : uml.FinalNode, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(finalNode, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(finalNode, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(finalNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(finalNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(finalNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(finalNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(finalNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(finalNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(finalNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(finalNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(finalNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(finalNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(finalNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(finalNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(finalNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(finalNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(finalNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateFinalNode_no_outgoing_edges(finalNode, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the no_outgoing_edges constraint of '<em>Final Node</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} finalNode
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateFinalNode_no_outgoing_edges(finalNode : uml.FinalNode, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return finalNode.no_outgoing_edges(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} controlNode
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateControlNode(controlNode : uml.ControlNode, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(controlNode, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(controlNode, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(controlNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(controlNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(controlNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(controlNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(controlNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(controlNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(controlNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(controlNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(controlNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(controlNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(controlNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(controlNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(controlNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(controlNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(controlNode, diagnostics, context) && result;
            return result;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} activityParameterNode
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateActivityParameterNode(activityParameterNode : uml.ActivityParameterNode, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(activityParameterNode, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(activityParameterNode, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(activityParameterNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(activityParameterNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(activityParameterNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(activityParameterNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(activityParameterNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(activityParameterNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(activityParameterNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(activityParameterNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(activityParameterNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(activityParameterNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(activityParameterNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(activityParameterNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(activityParameterNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(activityParameterNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(activityParameterNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateObjectNode_input_output_parameter(activityParameterNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateObjectNode_selection_behavior(activityParameterNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateObjectNode_object_flow_edges(activityParameterNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateActivityParameterNode_no_outgoing_edges(activityParameterNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateActivityParameterNode_has_parameters(activityParameterNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateActivityParameterNode_same_type(activityParameterNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateActivityParameterNode_no_incoming_edges(activityParameterNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateActivityParameterNode_no_edges(activityParameterNode, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the no_outgoing_edges constraint of '<em>Activity Parameter Node</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} activityParameterNode
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateActivityParameterNode_no_outgoing_edges(activityParameterNode : uml.ActivityParameterNode, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return activityParameterNode.no_outgoing_edges(diagnostics, context);
        }

        /**
         * Validates the has_parameters constraint of '<em>Activity Parameter Node</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} activityParameterNode
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateActivityParameterNode_has_parameters(activityParameterNode : uml.ActivityParameterNode, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return activityParameterNode.has_parameters(diagnostics, context);
        }

        /**
         * Validates the same_type constraint of '<em>Activity Parameter Node</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} activityParameterNode
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateActivityParameterNode_same_type(activityParameterNode : uml.ActivityParameterNode, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return activityParameterNode.same_type(diagnostics, context);
        }

        /**
         * Validates the no_incoming_edges constraint of '<em>Activity Parameter Node</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} activityParameterNode
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateActivityParameterNode_no_incoming_edges(activityParameterNode : uml.ActivityParameterNode, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return activityParameterNode.no_incoming_edges(diagnostics, context);
        }

        /**
         * Validates the no_edges constraint of '<em>Activity Parameter Node</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} activityParameterNode
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateActivityParameterNode_no_edges(activityParameterNode : uml.ActivityParameterNode, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return activityParameterNode.no_edges(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} centralBufferNode
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateCentralBufferNode(centralBufferNode : uml.CentralBufferNode, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(centralBufferNode, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(centralBufferNode, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(centralBufferNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(centralBufferNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(centralBufferNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(centralBufferNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(centralBufferNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(centralBufferNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(centralBufferNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(centralBufferNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(centralBufferNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(centralBufferNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(centralBufferNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(centralBufferNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(centralBufferNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(centralBufferNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(centralBufferNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateObjectNode_input_output_parameter(centralBufferNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateObjectNode_selection_behavior(centralBufferNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateObjectNode_object_flow_edges(centralBufferNode, diagnostics, context) && result;
            return result;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} controlFlow
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateControlFlow(controlFlow : uml.ControlFlow, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(controlFlow, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(controlFlow, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(controlFlow, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(controlFlow, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(controlFlow, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(controlFlow, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(controlFlow, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(controlFlow, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(controlFlow, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(controlFlow, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(controlFlow, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(controlFlow, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(controlFlow, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(controlFlow, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(controlFlow, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(controlFlow, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(controlFlow, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateActivityEdge_source_and_target(controlFlow, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateControlFlow_object_nodes(controlFlow, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the object_nodes constraint of '<em>Control Flow</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} controlFlow
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateControlFlow_object_nodes(controlFlow : uml.ControlFlow, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return controlFlow.object_nodes(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} dataStoreNode
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateDataStoreNode(dataStoreNode : uml.DataStoreNode, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(dataStoreNode, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(dataStoreNode, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(dataStoreNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(dataStoreNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(dataStoreNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(dataStoreNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(dataStoreNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(dataStoreNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(dataStoreNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(dataStoreNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(dataStoreNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(dataStoreNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(dataStoreNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(dataStoreNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(dataStoreNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(dataStoreNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(dataStoreNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateObjectNode_input_output_parameter(dataStoreNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateObjectNode_selection_behavior(dataStoreNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateObjectNode_object_flow_edges(dataStoreNode, diagnostics, context) && result;
            return result;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} decisionNode
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateDecisionNode(decisionNode : uml.DecisionNode, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(decisionNode, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(decisionNode, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(decisionNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(decisionNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(decisionNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(decisionNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(decisionNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(decisionNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(decisionNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(decisionNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(decisionNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(decisionNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(decisionNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(decisionNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(decisionNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(decisionNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(decisionNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateDecisionNode_zero_input_parameters(decisionNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateDecisionNode_edges(decisionNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateDecisionNode_decision_input_flow_incoming(decisionNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateDecisionNode_two_input_parameters(decisionNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateDecisionNode_incoming_outgoing_edges(decisionNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateDecisionNode_incoming_control_one_input_parameter(decisionNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateDecisionNode_parameters(decisionNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateDecisionNode_incoming_object_one_input_parameter(decisionNode, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the zero_input_parameters constraint of '<em>Decision Node</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} decisionNode
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateDecisionNode_zero_input_parameters(decisionNode : uml.DecisionNode, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return decisionNode.zero_input_parameters(diagnostics, context);
        }

        /**
         * Validates the edges constraint of '<em>Decision Node</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} decisionNode
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateDecisionNode_edges(decisionNode : uml.DecisionNode, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return decisionNode.edges(diagnostics, context);
        }

        /**
         * Validates the decision_input_flow_incoming constraint of '<em>Decision Node</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} decisionNode
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateDecisionNode_decision_input_flow_incoming(decisionNode : uml.DecisionNode, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return decisionNode.decision_input_flow_incoming(diagnostics, context);
        }

        /**
         * Validates the two_input_parameters constraint of '<em>Decision Node</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} decisionNode
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateDecisionNode_two_input_parameters(decisionNode : uml.DecisionNode, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return decisionNode.two_input_parameters(diagnostics, context);
        }

        /**
         * Validates the incoming_outgoing_edges constraint of '<em>Decision Node</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} decisionNode
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateDecisionNode_incoming_outgoing_edges(decisionNode : uml.DecisionNode, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return decisionNode.incoming_outgoing_edges(diagnostics, context);
        }

        /**
         * Validates the incoming_control_one_input_parameter constraint of '<em>Decision Node</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} decisionNode
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateDecisionNode_incoming_control_one_input_parameter(decisionNode : uml.DecisionNode, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return decisionNode.incoming_control_one_input_parameter(diagnostics, context);
        }

        /**
         * Validates the parameters constraint of '<em>Decision Node</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} decisionNode
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateDecisionNode_parameters(decisionNode : uml.DecisionNode, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return decisionNode.parameters(diagnostics, context);
        }

        /**
         * Validates the incoming_object_one_input_parameter constraint of '<em>Decision Node</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} decisionNode
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateDecisionNode_incoming_object_one_input_parameter(decisionNode : uml.DecisionNode, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return decisionNode.incoming_object_one_input_parameter(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} objectFlow
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateObjectFlow(objectFlow : uml.ObjectFlow, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(objectFlow, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(objectFlow, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(objectFlow, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(objectFlow, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(objectFlow, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(objectFlow, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(objectFlow, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(objectFlow, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(objectFlow, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(objectFlow, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(objectFlow, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(objectFlow, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(objectFlow, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(objectFlow, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(objectFlow, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(objectFlow, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(objectFlow, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateActivityEdge_source_and_target(objectFlow, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateObjectFlow_input_and_output_parameter(objectFlow, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateObjectFlow_no_executable_nodes(objectFlow, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateObjectFlow_transformation_behavior(objectFlow, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateObjectFlow_selection_behavior(objectFlow, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateObjectFlow_compatible_types(objectFlow, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateObjectFlow_same_upper_bounds(objectFlow, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateObjectFlow_target(objectFlow, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateObjectFlow_is_multicast_or_is_multireceive(objectFlow, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the input_and_output_parameter constraint of '<em>Object Flow</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} objectFlow
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateObjectFlow_input_and_output_parameter(objectFlow : uml.ObjectFlow, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return objectFlow.input_and_output_parameter(diagnostics, context);
        }

        /**
         * Validates the no_executable_nodes constraint of '<em>Object Flow</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} objectFlow
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateObjectFlow_no_executable_nodes(objectFlow : uml.ObjectFlow, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return objectFlow.no_executable_nodes(diagnostics, context);
        }

        /**
         * Validates the transformation_behavior constraint of '<em>Object Flow</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} objectFlow
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateObjectFlow_transformation_behavior(objectFlow : uml.ObjectFlow, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return objectFlow.transformation_behavior(diagnostics, context);
        }

        /**
         * Validates the selection_behavior constraint of '<em>Object Flow</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} objectFlow
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateObjectFlow_selection_behavior(objectFlow : uml.ObjectFlow, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return objectFlow.selection_behavior(diagnostics, context);
        }

        /**
         * Validates the compatible_types constraint of '<em>Object Flow</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} objectFlow
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateObjectFlow_compatible_types(objectFlow : uml.ObjectFlow, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return objectFlow.compatible_types(diagnostics, context);
        }

        /**
         * Validates the same_upper_bounds constraint of '<em>Object Flow</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} objectFlow
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateObjectFlow_same_upper_bounds(objectFlow : uml.ObjectFlow, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return objectFlow.same_upper_bounds(diagnostics, context);
        }

        /**
         * Validates the target constraint of '<em>Object Flow</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} objectFlow
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateObjectFlow_target(objectFlow : uml.ObjectFlow, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return objectFlow.target(diagnostics, context);
        }

        /**
         * Validates the is_multicast_or_is_multireceive constraint of '<em>Object Flow</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} objectFlow
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateObjectFlow_is_multicast_or_is_multireceive(objectFlow : uml.ObjectFlow, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return objectFlow.is_multicast_or_is_multireceive(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} flowFinalNode
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateFlowFinalNode(flowFinalNode : uml.FlowFinalNode, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(flowFinalNode, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(flowFinalNode, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(flowFinalNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(flowFinalNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(flowFinalNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(flowFinalNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(flowFinalNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(flowFinalNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(flowFinalNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(flowFinalNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(flowFinalNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(flowFinalNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(flowFinalNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(flowFinalNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(flowFinalNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(flowFinalNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(flowFinalNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateFinalNode_no_outgoing_edges(flowFinalNode, diagnostics, context) && result;
            return result;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} forkNode
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateForkNode(forkNode : uml.ForkNode, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(forkNode, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(forkNode, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(forkNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(forkNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(forkNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(forkNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(forkNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(forkNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(forkNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(forkNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(forkNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(forkNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(forkNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(forkNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(forkNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(forkNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(forkNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateForkNode_edges(forkNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateForkNode_one_incoming_edge(forkNode, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the edges constraint of '<em>Fork Node</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} forkNode
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateForkNode_edges(forkNode : uml.ForkNode, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return forkNode.edges(diagnostics, context);
        }

        /**
         * Validates the one_incoming_edge constraint of '<em>Fork Node</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} forkNode
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateForkNode_one_incoming_edge(forkNode : uml.ForkNode, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return forkNode.one_incoming_edge(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} initialNode
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateInitialNode(initialNode : uml.InitialNode, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(initialNode, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(initialNode, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(initialNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(initialNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(initialNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(initialNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(initialNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(initialNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(initialNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(initialNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(initialNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(initialNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(initialNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(initialNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(initialNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(initialNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(initialNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateInitialNode_no_incoming_edges(initialNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateInitialNode_control_edges(initialNode, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the no_incoming_edges constraint of '<em>Initial Node</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} initialNode
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateInitialNode_no_incoming_edges(initialNode : uml.InitialNode, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return initialNode.no_incoming_edges(diagnostics, context);
        }

        /**
         * Validates the control_edges constraint of '<em>Initial Node</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} initialNode
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateInitialNode_control_edges(initialNode : uml.InitialNode, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return initialNode.control_edges(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} joinNode
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateJoinNode(joinNode : uml.JoinNode, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(joinNode, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(joinNode, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(joinNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(joinNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(joinNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(joinNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(joinNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(joinNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(joinNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(joinNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(joinNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(joinNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(joinNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(joinNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(joinNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(joinNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(joinNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateJoinNode_one_outgoing_edge(joinNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateJoinNode_incoming_object_flow(joinNode, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the one_outgoing_edge constraint of '<em>Join Node</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} joinNode
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateJoinNode_one_outgoing_edge(joinNode : uml.JoinNode, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return joinNode.one_outgoing_edge(diagnostics, context);
        }

        /**
         * Validates the incoming_object_flow constraint of '<em>Join Node</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} joinNode
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateJoinNode_incoming_object_flow(joinNode : uml.JoinNode, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return joinNode.incoming_object_flow(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} mergeNode
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateMergeNode(mergeNode : uml.MergeNode, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(mergeNode, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(mergeNode, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(mergeNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(mergeNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(mergeNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(mergeNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(mergeNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(mergeNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(mergeNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(mergeNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(mergeNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(mergeNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(mergeNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(mergeNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(mergeNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(mergeNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(mergeNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateMergeNode_one_outgoing_edge(mergeNode, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateMergeNode_edges(mergeNode, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the one_outgoing_edge constraint of '<em>Merge Node</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} mergeNode
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateMergeNode_one_outgoing_edge(mergeNode : uml.MergeNode, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return mergeNode.one_outgoing_edge(diagnostics, context);
        }

        /**
         * Validates the edges constraint of '<em>Merge Node</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} mergeNode
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateMergeNode_edges(mergeNode : uml.MergeNode, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return mergeNode.edges(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} instanceValue
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateInstanceValue(instanceValue : uml.InstanceValue, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(instanceValue, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(instanceValue, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(instanceValue, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(instanceValue, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(instanceValue, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(instanceValue, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(instanceValue, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(instanceValue, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(instanceValue, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(instanceValue, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(instanceValue, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(instanceValue, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(instanceValue, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(instanceValue, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePackageableElement_namespace_needs_visibility(instanceValue, diagnostics, context) && result;
            return result;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} anyReceiveEvent
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateAnyReceiveEvent(anyReceiveEvent : uml.AnyReceiveEvent, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(anyReceiveEvent, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(anyReceiveEvent, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(anyReceiveEvent, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(anyReceiveEvent, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(anyReceiveEvent, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(anyReceiveEvent, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(anyReceiveEvent, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(anyReceiveEvent, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(anyReceiveEvent, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(anyReceiveEvent, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(anyReceiveEvent, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(anyReceiveEvent, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(anyReceiveEvent, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(anyReceiveEvent, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePackageableElement_namespace_needs_visibility(anyReceiveEvent, diagnostics, context) && result;
            return result;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} messageEvent
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateMessageEvent(messageEvent : uml.MessageEvent, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(messageEvent, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(messageEvent, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(messageEvent, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(messageEvent, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(messageEvent, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(messageEvent, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(messageEvent, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(messageEvent, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(messageEvent, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(messageEvent, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(messageEvent, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(messageEvent, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(messageEvent, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(messageEvent, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePackageableElement_namespace_needs_visibility(messageEvent, diagnostics, context) && result;
            return result;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} callEvent
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateCallEvent(callEvent : uml.CallEvent, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(callEvent, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(callEvent, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(callEvent, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(callEvent, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(callEvent, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(callEvent, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(callEvent, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(callEvent, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(callEvent, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(callEvent, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(callEvent, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(callEvent, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(callEvent, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(callEvent, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePackageableElement_namespace_needs_visibility(callEvent, diagnostics, context) && result;
            return result;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} changeEvent
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateChangeEvent(changeEvent : uml.ChangeEvent, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(changeEvent, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(changeEvent, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(changeEvent, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(changeEvent, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(changeEvent, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(changeEvent, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(changeEvent, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(changeEvent, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(changeEvent, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(changeEvent, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(changeEvent, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(changeEvent, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(changeEvent, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(changeEvent, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePackageableElement_namespace_needs_visibility(changeEvent, diagnostics, context) && result;
            return result;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} functionBehavior
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateFunctionBehavior(functionBehavior : uml.FunctionBehavior, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(functionBehavior, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(functionBehavior, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(functionBehavior, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(functionBehavior, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(functionBehavior, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(functionBehavior, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(functionBehavior, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(functionBehavior, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(functionBehavior, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(functionBehavior, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(functionBehavior, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(functionBehavior, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(functionBehavior, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(functionBehavior, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_members_distinguishable(functionBehavior, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_self(functionBehavior, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_ownedMembers(functionBehavior, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(functionBehavior, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(functionBehavior, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(functionBehavior, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePackageableElement_namespace_needs_visibility(functionBehavior, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_specialize_type(functionBehavior, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_maps_to_generalization_set(functionBehavior, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_non_final_parents(functionBehavior, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_no_cycles_in_generalization(functionBehavior, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateBehavioredClassifier_class_behavior(functionBehavior, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClass_passive_class(functionBehavior, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateBehavior_most_one_behavior(functionBehavior, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateBehavior_parameters_match(functionBehavior, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateBehavior_feature_of_context_classifier(functionBehavior, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateFunctionBehavior_one_output_parameter(functionBehavior, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateFunctionBehavior_types_of_parameters(functionBehavior, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the one_output_parameter constraint of '<em>Function Behavior</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} functionBehavior
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateFunctionBehavior_one_output_parameter(functionBehavior : uml.FunctionBehavior, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return functionBehavior.one_output_parameter(diagnostics, context);
        }

        /**
         * Validates the types_of_parameters constraint of '<em>Function Behavior</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} functionBehavior
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateFunctionBehavior_types_of_parameters(functionBehavior : uml.FunctionBehavior, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return functionBehavior.types_of_parameters(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} opaqueBehavior
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateOpaqueBehavior(opaqueBehavior : uml.OpaqueBehavior, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(opaqueBehavior, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(opaqueBehavior, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(opaqueBehavior, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(opaqueBehavior, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(opaqueBehavior, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(opaqueBehavior, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(opaqueBehavior, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(opaqueBehavior, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(opaqueBehavior, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(opaqueBehavior, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(opaqueBehavior, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(opaqueBehavior, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(opaqueBehavior, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(opaqueBehavior, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_members_distinguishable(opaqueBehavior, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_self(opaqueBehavior, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_ownedMembers(opaqueBehavior, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(opaqueBehavior, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(opaqueBehavior, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(opaqueBehavior, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePackageableElement_namespace_needs_visibility(opaqueBehavior, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_specialize_type(opaqueBehavior, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_maps_to_generalization_set(opaqueBehavior, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_non_final_parents(opaqueBehavior, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_no_cycles_in_generalization(opaqueBehavior, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateBehavioredClassifier_class_behavior(opaqueBehavior, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClass_passive_class(opaqueBehavior, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateBehavior_most_one_behavior(opaqueBehavior, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateBehavior_parameters_match(opaqueBehavior, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateBehavior_feature_of_context_classifier(opaqueBehavior, diagnostics, context) && result;
            return result;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} signalEvent
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateSignalEvent(signalEvent : uml.SignalEvent, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(signalEvent, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(signalEvent, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(signalEvent, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(signalEvent, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(signalEvent, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(signalEvent, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(signalEvent, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(signalEvent, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(signalEvent, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(signalEvent, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(signalEvent, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(signalEvent, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(signalEvent, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(signalEvent, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePackageableElement_namespace_needs_visibility(signalEvent, diagnostics, context) && result;
            return result;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} timeEvent
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateTimeEvent(timeEvent : uml.TimeEvent, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(timeEvent, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(timeEvent, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(timeEvent, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(timeEvent, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(timeEvent, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(timeEvent, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(timeEvent, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(timeEvent, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(timeEvent, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(timeEvent, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(timeEvent, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(timeEvent, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(timeEvent, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(timeEvent, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePackageableElement_namespace_needs_visibility(timeEvent, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateTimeEvent_when_non_negative(timeEvent, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the when_non_negative constraint of '<em>Time Event</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} timeEvent
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateTimeEvent_when_non_negative(timeEvent : uml.TimeEvent, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return timeEvent.when_non_negative(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} timeExpression
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateTimeExpression(timeExpression : uml.TimeExpression, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(timeExpression, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(timeExpression, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(timeExpression, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(timeExpression, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(timeExpression, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(timeExpression, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(timeExpression, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(timeExpression, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(timeExpression, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(timeExpression, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(timeExpression, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(timeExpression, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(timeExpression, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(timeExpression, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePackageableElement_namespace_needs_visibility(timeExpression, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateTimeExpression_no_expr_requires_observation(timeExpression, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the no_expr_requires_observation constraint of '<em>Time Expression</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} timeExpression
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateTimeExpression_no_expr_requires_observation(timeExpression : uml.TimeExpression, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return timeExpression.no_expr_requires_observation(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} observation
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateObservation(observation : uml.Observation, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(observation, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(observation, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(observation, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(observation, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(observation, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(observation, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(observation, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(observation, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(observation, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(observation, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(observation, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(observation, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(observation, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(observation, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePackageableElement_namespace_needs_visibility(observation, diagnostics, context) && result;
            return result;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} communicationPath
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateCommunicationPath(communicationPath : uml.CommunicationPath, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(communicationPath, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(communicationPath, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(communicationPath, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(communicationPath, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(communicationPath, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(communicationPath, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(communicationPath, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(communicationPath, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(communicationPath, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(communicationPath, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(communicationPath, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(communicationPath, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(communicationPath, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(communicationPath, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_members_distinguishable(communicationPath, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_self(communicationPath, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_ownedMembers(communicationPath, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(communicationPath, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(communicationPath, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(communicationPath, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePackageableElement_namespace_needs_visibility(communicationPath, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_specialize_type(communicationPath, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_maps_to_generalization_set(communicationPath, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_non_final_parents(communicationPath, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_no_cycles_in_generalization(communicationPath, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateAssociation_specialized_end_number(communicationPath, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateAssociation_specialized_end_types(communicationPath, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateAssociation_binary_associations(communicationPath, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateAssociation_association_ends(communicationPath, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateAssociation_ends_must_be_typed(communicationPath, diagnostics, context) && result;
            return result;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} device
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateDevice(device : uml.Device, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(device, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(device, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(device, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(device, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(device, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(device, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(device, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(device, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(device, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(device, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(device, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(device, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(device, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(device, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_members_distinguishable(device, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_self(device, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_ownedMembers(device, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(device, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(device, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(device, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePackageableElement_namespace_needs_visibility(device, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_specialize_type(device, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_maps_to_generalization_set(device, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_non_final_parents(device, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_no_cycles_in_generalization(device, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateBehavioredClassifier_class_behavior(device, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClass_passive_class(device, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNode_internal_structure(device, diagnostics, context) && result;
            return result;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} node
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateNode(node : uml.Node, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(node, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(node, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(node, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(node, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(node, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(node, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(node, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(node, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(node, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(node, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(node, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(node, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(node, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(node, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_members_distinguishable(node, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_self(node, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_ownedMembers(node, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(node, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(node, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(node, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePackageableElement_namespace_needs_visibility(node, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_specialize_type(node, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_maps_to_generalization_set(node, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_non_final_parents(node, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_no_cycles_in_generalization(node, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateBehavioredClassifier_class_behavior(node, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClass_passive_class(node, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNode_internal_structure(node, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the internal_structure constraint of '<em>Node</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} node
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateNode_internal_structure(node : uml.Node, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return node.internal_structure(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} executionEnvironment
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateExecutionEnvironment(executionEnvironment : uml.ExecutionEnvironment, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(executionEnvironment, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(executionEnvironment, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(executionEnvironment, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(executionEnvironment, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(executionEnvironment, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(executionEnvironment, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(executionEnvironment, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(executionEnvironment, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(executionEnvironment, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(executionEnvironment, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(executionEnvironment, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(executionEnvironment, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(executionEnvironment, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(executionEnvironment, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_members_distinguishable(executionEnvironment, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_self(executionEnvironment, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_ownedMembers(executionEnvironment, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(executionEnvironment, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(executionEnvironment, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(executionEnvironment, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePackageableElement_namespace_needs_visibility(executionEnvironment, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_specialize_type(executionEnvironment, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_maps_to_generalization_set(executionEnvironment, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_non_final_parents(executionEnvironment, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_no_cycles_in_generalization(executionEnvironment, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateBehavioredClassifier_class_behavior(executionEnvironment, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClass_passive_class(executionEnvironment, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNode_internal_structure(executionEnvironment, diagnostics, context) && result;
            return result;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} informationFlow
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateInformationFlow(informationFlow : uml.InformationFlow, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(informationFlow, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(informationFlow, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(informationFlow, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(informationFlow, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(informationFlow, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(informationFlow, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(informationFlow, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(informationFlow, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(informationFlow, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(informationFlow, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(informationFlow, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(informationFlow, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(informationFlow, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(informationFlow, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePackageableElement_namespace_needs_visibility(informationFlow, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateInformationFlow_must_conform(informationFlow, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateInformationFlow_sources_and_targets_kind(informationFlow, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateInformationFlow_convey_classifiers(informationFlow, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the must_conform constraint of '<em>Information Flow</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} informationFlow
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateInformationFlow_must_conform(informationFlow : uml.InformationFlow, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return informationFlow.must_conform(diagnostics, context);
        }

        /**
         * Validates the sources_and_targets_kind constraint of '<em>Information Flow</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} informationFlow
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateInformationFlow_sources_and_targets_kind(informationFlow : uml.InformationFlow, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return informationFlow.sources_and_targets_kind(diagnostics, context);
        }

        /**
         * Validates the convey_classifiers constraint of '<em>Information Flow</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} informationFlow
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateInformationFlow_convey_classifiers(informationFlow : uml.InformationFlow, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return informationFlow.convey_classifiers(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} message
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateMessage(message : uml.Message, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(message, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(message, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(message, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(message, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(message, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(message, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(message, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(message, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(message, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(message, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(message, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(message, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(message, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(message, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateMessage_sending_receiving_message_event(message, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateMessage_arguments(message, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateMessage_cannot_cross_boundaries(message, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateMessage_signature_is_signal(message, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateMessage_occurrence_specifications(message, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateMessage_signature_refer_to(message, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateMessage_signature_is_operation_request(message, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateMessage_signature_is_operation_reply(message, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the sending_receiving_message_event constraint of '<em>Message</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} message
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateMessage_sending_receiving_message_event(message : uml.Message, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return message.sending_receiving_message_event(diagnostics, context);
        }

        /**
         * Validates the arguments constraint of '<em>Message</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} message
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateMessage_arguments(message : uml.Message, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return message.arguments(diagnostics, context);
        }

        /**
         * Validates the cannot_cross_boundaries constraint of '<em>Message</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} message
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateMessage_cannot_cross_boundaries(message : uml.Message, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return message.cannot_cross_boundaries(diagnostics, context);
        }

        /**
         * Validates the signature_is_signal constraint of '<em>Message</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} message
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateMessage_signature_is_signal(message : uml.Message, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return message.signature_is_signal(diagnostics, context);
        }

        /**
         * Validates the occurrence_specifications constraint of '<em>Message</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} message
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateMessage_occurrence_specifications(message : uml.Message, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return message.occurrence_specifications(diagnostics, context);
        }

        /**
         * Validates the signature_refer_to constraint of '<em>Message</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} message
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateMessage_signature_refer_to(message : uml.Message, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return message.signature_refer_to(diagnostics, context);
        }

        /**
         * Validates the signature_is_operation_request constraint of '<em>Message</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} message
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateMessage_signature_is_operation_request(message : uml.Message, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return message.signature_is_operation_request(diagnostics, context);
        }

        /**
         * Validates the signature_is_operation_reply constraint of '<em>Message</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} message
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateMessage_signature_is_operation_reply(message : uml.Message, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return message.signature_is_operation_reply(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} interaction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateInteraction(interaction : uml.Interaction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(interaction, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(interaction, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(interaction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(interaction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(interaction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(interaction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(interaction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(interaction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(interaction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(interaction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(interaction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(interaction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(interaction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(interaction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_members_distinguishable(interaction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_self(interaction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_ownedMembers(interaction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(interaction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(interaction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(interaction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePackageableElement_namespace_needs_visibility(interaction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_specialize_type(interaction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_maps_to_generalization_set(interaction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_non_final_parents(interaction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_no_cycles_in_generalization(interaction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateBehavioredClassifier_class_behavior(interaction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClass_passive_class(interaction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateBehavior_most_one_behavior(interaction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateBehavior_parameters_match(interaction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateBehavior_feature_of_context_classifier(interaction, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateInteraction_not_contained(interaction, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the not_contained constraint of '<em>Interaction</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} interaction
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateInteraction_not_contained(interaction : uml.Interaction, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return interaction.not_contained(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} interactionFragment
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateInteractionFragment(interactionFragment : uml.InteractionFragment, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(interactionFragment, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(interactionFragment, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(interactionFragment, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(interactionFragment, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(interactionFragment, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(interactionFragment, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(interactionFragment, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(interactionFragment, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(interactionFragment, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(interactionFragment, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(interactionFragment, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(interactionFragment, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(interactionFragment, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(interactionFragment, diagnostics, context) && result;
            return result;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} lifeline
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateLifeline(lifeline : uml.Lifeline, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(lifeline, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(lifeline, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(lifeline, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(lifeline, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(lifeline, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(lifeline, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(lifeline, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(lifeline, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(lifeline, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(lifeline, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(lifeline, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(lifeline, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(lifeline, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(lifeline, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateLifeline_selector_specified(lifeline, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateLifeline_interaction_uses_share_lifeline(lifeline, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateLifeline_same_classifier(lifeline, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateLifeline_selector_int_or_string(lifeline, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the selector_specified constraint of '<em>Lifeline</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} lifeline
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateLifeline_selector_specified(lifeline : uml.Lifeline, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return lifeline.selector_specified(diagnostics, context);
        }

        /**
         * Validates the interaction_uses_share_lifeline constraint of '<em>Lifeline</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} lifeline
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateLifeline_interaction_uses_share_lifeline(lifeline : uml.Lifeline, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return lifeline.interaction_uses_share_lifeline(diagnostics, context);
        }

        /**
         * Validates the same_classifier constraint of '<em>Lifeline</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} lifeline
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateLifeline_same_classifier(lifeline : uml.Lifeline, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return lifeline.same_classifier(diagnostics, context);
        }

        /**
         * Validates the selector_int_or_string constraint of '<em>Lifeline</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} lifeline
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateLifeline_selector_int_or_string(lifeline : uml.Lifeline, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return lifeline.selector_int_or_string(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} partDecomposition
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validatePartDecomposition(partDecomposition : uml.PartDecomposition, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(partDecomposition, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(partDecomposition, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(partDecomposition, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(partDecomposition, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(partDecomposition, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(partDecomposition, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(partDecomposition, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(partDecomposition, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(partDecomposition, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(partDecomposition, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(partDecomposition, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(partDecomposition, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(partDecomposition, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(partDecomposition, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateInteractionUse_gates_match(partDecomposition, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateInteractionUse_arguments_are_constants(partDecomposition, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateInteractionUse_returnValueRecipient_coverage(partDecomposition, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateInteractionUse_arguments_correspond_to_parameters(partDecomposition, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateInteractionUse_returnValue_type_recipient_correspondence(partDecomposition, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateInteractionUse_all_lifelines(partDecomposition, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePartDecomposition_commutativity_of_decomposition(partDecomposition, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePartDecomposition_assume(partDecomposition, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePartDecomposition_parts_of_internal_structures(partDecomposition, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the commutativity_of_decomposition constraint of '<em>Part Decomposition</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} partDecomposition
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validatePartDecomposition_commutativity_of_decomposition(partDecomposition : uml.PartDecomposition, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return partDecomposition.commutativity_of_decomposition(diagnostics, context);
        }

        /**
         * Validates the assume constraint of '<em>Part Decomposition</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} partDecomposition
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validatePartDecomposition_assume(partDecomposition : uml.PartDecomposition, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return partDecomposition.assume(diagnostics, context);
        }

        /**
         * Validates the parts_of_internal_structures constraint of '<em>Part Decomposition</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} partDecomposition
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validatePartDecomposition_parts_of_internal_structures(partDecomposition : uml.PartDecomposition, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return partDecomposition.parts_of_internal_structures(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} interactionUse
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateInteractionUse(interactionUse : uml.InteractionUse, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(interactionUse, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(interactionUse, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(interactionUse, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(interactionUse, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(interactionUse, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(interactionUse, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(interactionUse, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(interactionUse, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(interactionUse, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(interactionUse, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(interactionUse, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(interactionUse, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(interactionUse, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(interactionUse, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateInteractionUse_gates_match(interactionUse, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateInteractionUse_arguments_are_constants(interactionUse, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateInteractionUse_returnValueRecipient_coverage(interactionUse, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateInteractionUse_arguments_correspond_to_parameters(interactionUse, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateInteractionUse_returnValue_type_recipient_correspondence(interactionUse, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateInteractionUse_all_lifelines(interactionUse, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the gates_match constraint of '<em>Interaction Use</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} interactionUse
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateInteractionUse_gates_match(interactionUse : uml.InteractionUse, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return interactionUse.gates_match(diagnostics, context);
        }

        /**
         * Validates the arguments_are_constants constraint of '<em>Interaction Use</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} interactionUse
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateInteractionUse_arguments_are_constants(interactionUse : uml.InteractionUse, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return interactionUse.arguments_are_constants(diagnostics, context);
        }

        /**
         * Validates the returnValueRecipient_coverage constraint of '<em>Interaction Use</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} interactionUse
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateInteractionUse_returnValueRecipient_coverage(interactionUse : uml.InteractionUse, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return interactionUse.returnValueRecipient_coverage(diagnostics, context);
        }

        /**
         * Validates the arguments_correspond_to_parameters constraint of '<em>Interaction Use</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} interactionUse
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateInteractionUse_arguments_correspond_to_parameters(interactionUse : uml.InteractionUse, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return interactionUse.arguments_correspond_to_parameters(diagnostics, context);
        }

        /**
         * Validates the returnValue_type_recipient_correspondence constraint of '<em>Interaction Use</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} interactionUse
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateInteractionUse_returnValue_type_recipient_correspondence(interactionUse : uml.InteractionUse, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return interactionUse.returnValue_type_recipient_correspondence(diagnostics, context);
        }

        /**
         * Validates the all_lifelines constraint of '<em>Interaction Use</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} interactionUse
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateInteractionUse_all_lifelines(interactionUse : uml.InteractionUse, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return interactionUse.all_lifelines(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} gate
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateGate(gate : uml.Gate, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(gate, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(gate, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(gate, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(gate, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(gate, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(gate, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(gate, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(gate, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(gate, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(gate, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(gate, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(gate, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(gate, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(gate, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateGate_actual_gate_matched(gate, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateGate_inside_cf_matched(gate, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateGate_outside_cf_matched(gate, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateGate_formal_gate_distinguishable(gate, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateGate_actual_gate_distinguishable(gate, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateGate_outside_cf_gate_distinguishable(gate, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateGate_inside_cf_gate_distinguishable(gate, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the actual_gate_matched constraint of '<em>Gate</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} gate
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateGate_actual_gate_matched(gate : uml.Gate, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return gate.actual_gate_matched(diagnostics, context);
        }

        /**
         * Validates the inside_cf_matched constraint of '<em>Gate</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} gate
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateGate_inside_cf_matched(gate : uml.Gate, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return gate.inside_cf_matched(diagnostics, context);
        }

        /**
         * Validates the outside_cf_matched constraint of '<em>Gate</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} gate
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateGate_outside_cf_matched(gate : uml.Gate, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return gate.outside_cf_matched(diagnostics, context);
        }

        /**
         * Validates the formal_gate_distinguishable constraint of '<em>Gate</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} gate
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateGate_formal_gate_distinguishable(gate : uml.Gate, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return gate.formal_gate_distinguishable(diagnostics, context);
        }

        /**
         * Validates the actual_gate_distinguishable constraint of '<em>Gate</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} gate
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateGate_actual_gate_distinguishable(gate : uml.Gate, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return gate.actual_gate_distinguishable(diagnostics, context);
        }

        /**
         * Validates the outside_cf_gate_distinguishable constraint of '<em>Gate</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} gate
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateGate_outside_cf_gate_distinguishable(gate : uml.Gate, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return gate.outside_cf_gate_distinguishable(diagnostics, context);
        }

        /**
         * Validates the inside_cf_gate_distinguishable constraint of '<em>Gate</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} gate
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateGate_inside_cf_gate_distinguishable(gate : uml.Gate, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return gate.inside_cf_gate_distinguishable(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} messageEnd
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateMessageEnd(messageEnd : uml.MessageEnd, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(messageEnd, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(messageEnd, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(messageEnd, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(messageEnd, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(messageEnd, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(messageEnd, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(messageEnd, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(messageEnd, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(messageEnd, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(messageEnd, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(messageEnd, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(messageEnd, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(messageEnd, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(messageEnd, diagnostics, context) && result;
            return result;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} interactionOperand
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateInteractionOperand(interactionOperand : uml.InteractionOperand, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(interactionOperand, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(interactionOperand, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(interactionOperand, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(interactionOperand, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(interactionOperand, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(interactionOperand, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(interactionOperand, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(interactionOperand, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(interactionOperand, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(interactionOperand, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(interactionOperand, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(interactionOperand, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(interactionOperand, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(interactionOperand, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_members_distinguishable(interactionOperand, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_self(interactionOperand, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_ownedMembers(interactionOperand, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateInteractionOperand_guard_contain_references(interactionOperand, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateInteractionOperand_guard_directly_prior(interactionOperand, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the guard_contain_references constraint of '<em>Interaction Operand</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} interactionOperand
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateInteractionOperand_guard_contain_references(interactionOperand : uml.InteractionOperand, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return interactionOperand.guard_contain_references(diagnostics, context);
        }

        /**
         * Validates the guard_directly_prior constraint of '<em>Interaction Operand</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} interactionOperand
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateInteractionOperand_guard_directly_prior(interactionOperand : uml.InteractionOperand, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return interactionOperand.guard_directly_prior(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} interactionConstraint
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateInteractionConstraint(interactionConstraint : uml.InteractionConstraint, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(interactionConstraint, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(interactionConstraint, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(interactionConstraint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(interactionConstraint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(interactionConstraint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(interactionConstraint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(interactionConstraint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(interactionConstraint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(interactionConstraint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(interactionConstraint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(interactionConstraint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(interactionConstraint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(interactionConstraint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(interactionConstraint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePackageableElement_namespace_needs_visibility(interactionConstraint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateConstraint_boolean_value(interactionConstraint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateConstraint_no_side_effects(interactionConstraint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateConstraint_not_apply_to_self(interactionConstraint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateInteractionConstraint_minint_maxint(interactionConstraint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateInteractionConstraint_minint_non_negative(interactionConstraint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateInteractionConstraint_maxint_positive(interactionConstraint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateInteractionConstraint_dynamic_variables(interactionConstraint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateInteractionConstraint_global_data(interactionConstraint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateInteractionConstraint_maxint_greater_equal_minint(interactionConstraint, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the minint_maxint constraint of '<em>Interaction Constraint</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} interactionConstraint
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateInteractionConstraint_minint_maxint(interactionConstraint : uml.InteractionConstraint, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return interactionConstraint.minint_maxint(diagnostics, context);
        }

        /**
         * Validates the minint_non_negative constraint of '<em>Interaction Constraint</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} interactionConstraint
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateInteractionConstraint_minint_non_negative(interactionConstraint : uml.InteractionConstraint, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return interactionConstraint.minint_non_negative(diagnostics, context);
        }

        /**
         * Validates the maxint_positive constraint of '<em>Interaction Constraint</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} interactionConstraint
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateInteractionConstraint_maxint_positive(interactionConstraint : uml.InteractionConstraint, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return interactionConstraint.maxint_positive(diagnostics, context);
        }

        /**
         * Validates the dynamic_variables constraint of '<em>Interaction Constraint</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} interactionConstraint
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateInteractionConstraint_dynamic_variables(interactionConstraint : uml.InteractionConstraint, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return interactionConstraint.dynamic_variables(diagnostics, context);
        }

        /**
         * Validates the global_data constraint of '<em>Interaction Constraint</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} interactionConstraint
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateInteractionConstraint_global_data(interactionConstraint : uml.InteractionConstraint, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return interactionConstraint.global_data(diagnostics, context);
        }

        /**
         * Validates the maxint_greater_equal_minint constraint of '<em>Interaction Constraint</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} interactionConstraint
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateInteractionConstraint_maxint_greater_equal_minint(interactionConstraint : uml.InteractionConstraint, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return interactionConstraint.maxint_greater_equal_minint(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} generalOrdering
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateGeneralOrdering(generalOrdering : uml.GeneralOrdering, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(generalOrdering, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(generalOrdering, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(generalOrdering, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(generalOrdering, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(generalOrdering, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(generalOrdering, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(generalOrdering, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(generalOrdering, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(generalOrdering, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(generalOrdering, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(generalOrdering, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(generalOrdering, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(generalOrdering, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(generalOrdering, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateGeneralOrdering_irreflexive_transitive_closure(generalOrdering, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the irreflexive_transitive_closure constraint of '<em>General Ordering</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} generalOrdering
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateGeneralOrdering_irreflexive_transitive_closure(generalOrdering : uml.GeneralOrdering, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return generalOrdering.irreflexive_transitive_closure(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} occurrenceSpecification
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateOccurrenceSpecification(occurrenceSpecification : uml.OccurrenceSpecification, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(occurrenceSpecification, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(occurrenceSpecification, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(occurrenceSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(occurrenceSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(occurrenceSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(occurrenceSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(occurrenceSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(occurrenceSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(occurrenceSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(occurrenceSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(occurrenceSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(occurrenceSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(occurrenceSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(occurrenceSpecification, diagnostics, context) && result;
            return result;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} informationItem
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateInformationItem(informationItem : uml.InformationItem, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(informationItem, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(informationItem, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(informationItem, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(informationItem, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(informationItem, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(informationItem, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(informationItem, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(informationItem, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(informationItem, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(informationItem, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(informationItem, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(informationItem, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(informationItem, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(informationItem, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_members_distinguishable(informationItem, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_self(informationItem, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_ownedMembers(informationItem, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(informationItem, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(informationItem, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(informationItem, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePackageableElement_namespace_needs_visibility(informationItem, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_specialize_type(informationItem, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_maps_to_generalization_set(informationItem, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_non_final_parents(informationItem, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_no_cycles_in_generalization(informationItem, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateInformationItem_sources_and_targets(informationItem, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateInformationItem_has_no(informationItem, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateInformationItem_not_instantiable(informationItem, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the sources_and_targets constraint of '<em>Information Item</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} informationItem
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateInformationItem_sources_and_targets(informationItem : uml.InformationItem, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return informationItem.sources_and_targets(diagnostics, context);
        }

        /**
         * Validates the has_no constraint of '<em>Information Item</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} informationItem
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateInformationItem_has_no(informationItem : uml.InformationItem, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return informationItem.has_no(diagnostics, context);
        }

        /**
         * Validates the not_instantiable constraint of '<em>Information Item</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} informationItem
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateInformationItem_not_instantiable(informationItem : uml.InformationItem, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return informationItem.not_instantiable(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} actionExecutionSpecification
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateActionExecutionSpecification(actionExecutionSpecification : uml.ActionExecutionSpecification, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(actionExecutionSpecification, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(actionExecutionSpecification, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(actionExecutionSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(actionExecutionSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(actionExecutionSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(actionExecutionSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(actionExecutionSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(actionExecutionSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(actionExecutionSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(actionExecutionSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(actionExecutionSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(actionExecutionSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(actionExecutionSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(actionExecutionSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateExecutionSpecification_same_lifeline(actionExecutionSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateActionExecutionSpecification_action_referenced(actionExecutionSpecification, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the action_referenced constraint of '<em>Action Execution Specification</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} actionExecutionSpecification
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateActionExecutionSpecification_action_referenced(actionExecutionSpecification : uml.ActionExecutionSpecification, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return actionExecutionSpecification.action_referenced(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} executionSpecification
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateExecutionSpecification(executionSpecification : uml.ExecutionSpecification, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(executionSpecification, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(executionSpecification, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(executionSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(executionSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(executionSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(executionSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(executionSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(executionSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(executionSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(executionSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(executionSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(executionSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(executionSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(executionSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateExecutionSpecification_same_lifeline(executionSpecification, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the same_lifeline constraint of '<em>Execution Specification</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} executionSpecification
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateExecutionSpecification_same_lifeline(executionSpecification : uml.ExecutionSpecification, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return executionSpecification.same_lifeline(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} behaviorExecutionSpecification
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateBehaviorExecutionSpecification(behaviorExecutionSpecification : uml.BehaviorExecutionSpecification, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(behaviorExecutionSpecification, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(behaviorExecutionSpecification, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(behaviorExecutionSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(behaviorExecutionSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(behaviorExecutionSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(behaviorExecutionSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(behaviorExecutionSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(behaviorExecutionSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(behaviorExecutionSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(behaviorExecutionSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(behaviorExecutionSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(behaviorExecutionSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(behaviorExecutionSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(behaviorExecutionSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateExecutionSpecification_same_lifeline(behaviorExecutionSpecification, diagnostics, context) && result;
            return result;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} combinedFragment
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateCombinedFragment(combinedFragment : uml.CombinedFragment, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(combinedFragment, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(combinedFragment, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(combinedFragment, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(combinedFragment, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(combinedFragment, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(combinedFragment, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(combinedFragment, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(combinedFragment, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(combinedFragment, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(combinedFragment, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(combinedFragment, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(combinedFragment, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(combinedFragment, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(combinedFragment, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateCombinedFragment_break_(combinedFragment, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateCombinedFragment_consider_and_ignore(combinedFragment, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateCombinedFragment_opt_loop_break_neg(combinedFragment, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the break_ constraint of '<em>Combined Fragment</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} combinedFragment
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateCombinedFragment_break_(combinedFragment : uml.CombinedFragment, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return combinedFragment.break_(diagnostics, context);
        }

        /**
         * Validates the consider_and_ignore constraint of '<em>Combined Fragment</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} combinedFragment
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateCombinedFragment_consider_and_ignore(combinedFragment : uml.CombinedFragment, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return combinedFragment.consider_and_ignore(diagnostics, context);
        }

        /**
         * Validates the opt_loop_break_neg constraint of '<em>Combined Fragment</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} combinedFragment
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateCombinedFragment_opt_loop_break_neg(combinedFragment : uml.CombinedFragment, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return combinedFragment.opt_loop_break_neg(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} considerIgnoreFragment
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateConsiderIgnoreFragment(considerIgnoreFragment : uml.ConsiderIgnoreFragment, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(considerIgnoreFragment, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(considerIgnoreFragment, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(considerIgnoreFragment, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(considerIgnoreFragment, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(considerIgnoreFragment, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(considerIgnoreFragment, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(considerIgnoreFragment, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(considerIgnoreFragment, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(considerIgnoreFragment, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(considerIgnoreFragment, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(considerIgnoreFragment, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(considerIgnoreFragment, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(considerIgnoreFragment, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(considerIgnoreFragment, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateCombinedFragment_break_(considerIgnoreFragment, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateCombinedFragment_consider_and_ignore(considerIgnoreFragment, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateCombinedFragment_opt_loop_break_neg(considerIgnoreFragment, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateConsiderIgnoreFragment_consider_or_ignore(considerIgnoreFragment, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateConsiderIgnoreFragment_type(considerIgnoreFragment, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the consider_or_ignore constraint of '<em>Consider Ignore Fragment</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} considerIgnoreFragment
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateConsiderIgnoreFragment_consider_or_ignore(considerIgnoreFragment : uml.ConsiderIgnoreFragment, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return considerIgnoreFragment.consider_or_ignore(diagnostics, context);
        }

        /**
         * Validates the type constraint of '<em>Consider Ignore Fragment</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} considerIgnoreFragment
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateConsiderIgnoreFragment_type(considerIgnoreFragment : uml.ConsiderIgnoreFragment, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return considerIgnoreFragment.type(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} continuation
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateContinuation(continuation : uml.Continuation, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(continuation, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(continuation, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(continuation, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(continuation, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(continuation, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(continuation, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(continuation, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(continuation, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(continuation, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(continuation, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(continuation, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(continuation, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(continuation, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(continuation, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateContinuation_first_or_last_interaction_fragment(continuation, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateContinuation_same_name(continuation, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateContinuation_global(continuation, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the first_or_last_interaction_fragment constraint of '<em>Continuation</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} continuation
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateContinuation_first_or_last_interaction_fragment(continuation : uml.Continuation, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return continuation.first_or_last_interaction_fragment(diagnostics, context);
        }

        /**
         * Validates the same_name constraint of '<em>Continuation</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} continuation
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateContinuation_same_name(continuation : uml.Continuation, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return continuation.same_name(diagnostics, context);
        }

        /**
         * Validates the global constraint of '<em>Continuation</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} continuation
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateContinuation_global(continuation : uml.Continuation, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return continuation.global(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} destructionOccurrenceSpecification
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateDestructionOccurrenceSpecification(destructionOccurrenceSpecification : uml.DestructionOccurrenceSpecification, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(destructionOccurrenceSpecification, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(destructionOccurrenceSpecification, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(destructionOccurrenceSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(destructionOccurrenceSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(destructionOccurrenceSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(destructionOccurrenceSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(destructionOccurrenceSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(destructionOccurrenceSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(destructionOccurrenceSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(destructionOccurrenceSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(destructionOccurrenceSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(destructionOccurrenceSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(destructionOccurrenceSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(destructionOccurrenceSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateDestructionOccurrenceSpecification_no_occurrence_specifications_below(destructionOccurrenceSpecification, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the no_occurrence_specifications_below constraint of '<em>Destruction Occurrence Specification</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} destructionOccurrenceSpecification
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateDestructionOccurrenceSpecification_no_occurrence_specifications_below(destructionOccurrenceSpecification : uml.DestructionOccurrenceSpecification, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return destructionOccurrenceSpecification.no_occurrence_specifications_below(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} messageOccurrenceSpecification
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateMessageOccurrenceSpecification(messageOccurrenceSpecification : uml.MessageOccurrenceSpecification, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(messageOccurrenceSpecification, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(messageOccurrenceSpecification, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(messageOccurrenceSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(messageOccurrenceSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(messageOccurrenceSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(messageOccurrenceSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(messageOccurrenceSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(messageOccurrenceSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(messageOccurrenceSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(messageOccurrenceSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(messageOccurrenceSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(messageOccurrenceSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(messageOccurrenceSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(messageOccurrenceSpecification, diagnostics, context) && result;
            return result;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} executionOccurrenceSpecification
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateExecutionOccurrenceSpecification(executionOccurrenceSpecification : uml.ExecutionOccurrenceSpecification, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(executionOccurrenceSpecification, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(executionOccurrenceSpecification, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(executionOccurrenceSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(executionOccurrenceSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(executionOccurrenceSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(executionOccurrenceSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(executionOccurrenceSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(executionOccurrenceSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(executionOccurrenceSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(executionOccurrenceSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(executionOccurrenceSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(executionOccurrenceSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(executionOccurrenceSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(executionOccurrenceSpecification, diagnostics, context) && result;
            return result;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} stateInvariant
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateStateInvariant(stateInvariant : uml.StateInvariant, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(stateInvariant, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(stateInvariant, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(stateInvariant, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(stateInvariant, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(stateInvariant, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(stateInvariant, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(stateInvariant, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(stateInvariant, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(stateInvariant, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(stateInvariant, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(stateInvariant, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(stateInvariant, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(stateInvariant, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(stateInvariant, diagnostics, context) && result;
            return result;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} finalState
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateFinalState(finalState : uml.FinalState, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(finalState, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(finalState, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(finalState, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(finalState, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(finalState, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(finalState, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(finalState, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(finalState, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(finalState, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(finalState, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(finalState, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(finalState, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(finalState, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(finalState, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_members_distinguishable(finalState, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_self(finalState, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_ownedMembers(finalState, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(finalState, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(finalState, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(finalState, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateState_entry_or_exit(finalState, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateState_submachine_states(finalState, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateState_composite_states(finalState, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateState_destinations_or_sources_of_transitions(finalState, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateState_submachine_or_regions(finalState, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateFinalState_no_exit_behavior(finalState, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateFinalState_no_outgoing_transitions(finalState, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateFinalState_no_regions(finalState, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateFinalState_cannot_reference_submachine(finalState, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateFinalState_no_entry_behavior(finalState, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateFinalState_no_state_behavior(finalState, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the no_exit_behavior constraint of '<em>Final State</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} finalState
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateFinalState_no_exit_behavior(finalState : uml.FinalState, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return finalState.no_exit_behavior(diagnostics, context);
        }

        /**
         * Validates the no_outgoing_transitions constraint of '<em>Final State</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} finalState
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateFinalState_no_outgoing_transitions(finalState : uml.FinalState, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return finalState.no_outgoing_transitions(diagnostics, context);
        }

        /**
         * Validates the no_regions constraint of '<em>Final State</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} finalState
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateFinalState_no_regions(finalState : uml.FinalState, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return finalState.no_regions(diagnostics, context);
        }

        /**
         * Validates the cannot_reference_submachine constraint of '<em>Final State</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} finalState
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateFinalState_cannot_reference_submachine(finalState : uml.FinalState, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return finalState.cannot_reference_submachine(diagnostics, context);
        }

        /**
         * Validates the no_entry_behavior constraint of '<em>Final State</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} finalState
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateFinalState_no_entry_behavior(finalState : uml.FinalState, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return finalState.no_entry_behavior(diagnostics, context);
        }

        /**
         * Validates the no_state_behavior constraint of '<em>Final State</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} finalState
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateFinalState_no_state_behavior(finalState : uml.FinalState, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return finalState.no_state_behavior(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} protocolTransition
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateProtocolTransition(protocolTransition : uml.ProtocolTransition, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(protocolTransition, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(protocolTransition, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(protocolTransition, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(protocolTransition, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(protocolTransition, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(protocolTransition, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(protocolTransition, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(protocolTransition, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(protocolTransition, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(protocolTransition, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(protocolTransition, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(protocolTransition, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(protocolTransition, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(protocolTransition, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_members_distinguishable(protocolTransition, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_self(protocolTransition, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_ownedMembers(protocolTransition, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(protocolTransition, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(protocolTransition, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(protocolTransition, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateTransition_state_is_external(protocolTransition, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateTransition_join_segment_guards(protocolTransition, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateTransition_state_is_internal(protocolTransition, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateTransition_outgoing_pseudostates(protocolTransition, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateTransition_join_segment_state(protocolTransition, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateTransition_fork_segment_state(protocolTransition, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateTransition_state_is_local(protocolTransition, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateTransition_initial_transition(protocolTransition, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateTransition_fork_segment_guards(protocolTransition, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateProtocolTransition_refers_to_operation(protocolTransition, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateProtocolTransition_associated_actions(protocolTransition, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateProtocolTransition_belongs_to_psm(protocolTransition, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the refers_to_operation constraint of '<em>Protocol Transition</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} protocolTransition
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateProtocolTransition_refers_to_operation(protocolTransition : uml.ProtocolTransition, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return protocolTransition.refers_to_operation(diagnostics, context);
        }

        /**
         * Validates the associated_actions constraint of '<em>Protocol Transition</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} protocolTransition
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateProtocolTransition_associated_actions(protocolTransition : uml.ProtocolTransition, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return protocolTransition.associated_actions(diagnostics, context);
        }

        /**
         * Validates the belongs_to_psm constraint of '<em>Protocol Transition</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} protocolTransition
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateProtocolTransition_belongs_to_psm(protocolTransition : uml.ProtocolTransition, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return protocolTransition.belongs_to_psm(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} associationClass
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateAssociationClass(associationClass : uml.AssociationClass, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(associationClass, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(associationClass, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(associationClass, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(associationClass, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(associationClass, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(associationClass, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(associationClass, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(associationClass, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(associationClass, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(associationClass, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(associationClass, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(associationClass, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(associationClass, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(associationClass, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_members_distinguishable(associationClass, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_self(associationClass, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_ownedMembers(associationClass, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(associationClass, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(associationClass, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(associationClass, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePackageableElement_namespace_needs_visibility(associationClass, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_specialize_type(associationClass, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_maps_to_generalization_set(associationClass, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_non_final_parents(associationClass, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_no_cycles_in_generalization(associationClass, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateBehavioredClassifier_class_behavior(associationClass, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClass_passive_class(associationClass, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateAssociation_specialized_end_number(associationClass, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateAssociation_specialized_end_types(associationClass, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateAssociation_binary_associations(associationClass, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateAssociation_association_ends(associationClass, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateAssociation_ends_must_be_typed(associationClass, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateAssociationClass_cannot_be_defined(associationClass, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateAssociationClass_disjoint_attributes_ends(associationClass, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the cannot_be_defined constraint of '<em>Association Class</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} associationClass
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateAssociationClass_cannot_be_defined(associationClass : uml.AssociationClass, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return associationClass.cannot_be_defined(diagnostics, context);
        }

        /**
         * Validates the disjoint_attributes_ends constraint of '<em>Association Class</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} associationClass
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateAssociationClass_disjoint_attributes_ends(associationClass : uml.AssociationClass, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return associationClass.disjoint_attributes_ends(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} component
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateComponent(component : uml.Component, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(component, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(component, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(component, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(component, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(component, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(component, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(component, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(component, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(component, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(component, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(component, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(component, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(component, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(component, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_members_distinguishable(component, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_self(component, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_ownedMembers(component, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(component, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(component, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(component, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePackageableElement_namespace_needs_visibility(component, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_specialize_type(component, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_maps_to_generalization_set(component, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_non_final_parents(component, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_no_cycles_in_generalization(component, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateBehavioredClassifier_class_behavior(component, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClass_passive_class(component, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateComponent_no_nested_classifiers(component, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateComponent_no_packaged_elements(component, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the no_nested_classifiers constraint of '<em>Component</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} component
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateComponent_no_nested_classifiers(component : uml.Component, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return component.no_nested_classifiers(diagnostics, context);
        }

        /**
         * Validates the no_packaged_elements constraint of '<em>Component</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} component
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateComponent_no_packaged_elements(component : uml.Component, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return component.no_packaged_elements(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} componentRealization
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateComponentRealization(componentRealization : uml.ComponentRealization, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(componentRealization, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(componentRealization, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(componentRealization, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(componentRealization, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(componentRealization, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(componentRealization, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(componentRealization, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(componentRealization, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(componentRealization, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(componentRealization, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(componentRealization, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(componentRealization, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(componentRealization, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(componentRealization, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePackageableElement_namespace_needs_visibility(componentRealization, diagnostics, context) && result;
            return result;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} actor
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateActor(actor : uml.Actor, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(actor, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(actor, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(actor, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(actor, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(actor, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(actor, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(actor, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(actor, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(actor, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(actor, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(actor, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(actor, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(actor, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(actor, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_members_distinguishable(actor, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_self(actor, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamespace_cannot_import_ownedMembers(actor, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_consistent(actor, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_non_leaf_redefinition(actor, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateRedefinableElement_redefinition_context_valid(actor, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePackageableElement_namespace_needs_visibility(actor, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_specialize_type(actor, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_maps_to_generalization_set(actor, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_non_final_parents(actor, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateClassifier_no_cycles_in_generalization(actor, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateBehavioredClassifier_class_behavior(actor, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateActor_associations(actor, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateActor_must_have_name(actor, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the associations constraint of '<em>Actor</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} actor
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateActor_associations(actor : uml.Actor, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return actor.associations(diagnostics, context);
        }

        /**
         * Validates the must_have_name constraint of '<em>Actor</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} actor
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateActor_must_have_name(actor : uml.Actor, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return actor.must_have_name(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} duration
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateDuration(duration : uml.Duration, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(duration, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(duration, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(duration, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(duration, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(duration, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(duration, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(duration, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(duration, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(duration, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(duration, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(duration, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(duration, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(duration, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(duration, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePackageableElement_namespace_needs_visibility(duration, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateDuration_no_expr_requires_observation(duration, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the no_expr_requires_observation constraint of '<em>Duration</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} duration
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateDuration_no_expr_requires_observation(duration : uml.Duration, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return duration.no_expr_requires_observation(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} durationConstraint
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateDurationConstraint(durationConstraint : uml.DurationConstraint, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(durationConstraint, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(durationConstraint, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(durationConstraint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(durationConstraint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(durationConstraint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(durationConstraint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(durationConstraint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(durationConstraint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(durationConstraint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(durationConstraint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(durationConstraint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(durationConstraint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(durationConstraint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(durationConstraint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePackageableElement_namespace_needs_visibility(durationConstraint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateConstraint_boolean_value(durationConstraint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateConstraint_no_side_effects(durationConstraint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateConstraint_not_apply_to_self(durationConstraint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateDurationConstraint_first_event_multiplicity(durationConstraint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateDurationConstraint_has_one_or_two_constrainedElements(durationConstraint, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the first_event_multiplicity constraint of '<em>Duration Constraint</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} durationConstraint
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateDurationConstraint_first_event_multiplicity(durationConstraint : uml.DurationConstraint, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return durationConstraint.first_event_multiplicity(diagnostics, context);
        }

        /**
         * Validates the has_one_or_two_constrainedElements constraint of '<em>Duration Constraint</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} durationConstraint
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateDurationConstraint_has_one_or_two_constrainedElements(durationConstraint : uml.DurationConstraint, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return durationConstraint.has_one_or_two_constrainedElements(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} intervalConstraint
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateIntervalConstraint(intervalConstraint : uml.IntervalConstraint, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(intervalConstraint, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(intervalConstraint, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(intervalConstraint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(intervalConstraint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(intervalConstraint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(intervalConstraint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(intervalConstraint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(intervalConstraint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(intervalConstraint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(intervalConstraint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(intervalConstraint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(intervalConstraint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(intervalConstraint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(intervalConstraint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePackageableElement_namespace_needs_visibility(intervalConstraint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateConstraint_boolean_value(intervalConstraint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateConstraint_no_side_effects(intervalConstraint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateConstraint_not_apply_to_self(intervalConstraint, diagnostics, context) && result;
            return result;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} interval
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateInterval(interval : uml.Interval, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(interval, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(interval, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(interval, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(interval, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(interval, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(interval, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(interval, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(interval, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(interval, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(interval, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(interval, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(interval, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(interval, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(interval, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePackageableElement_namespace_needs_visibility(interval, diagnostics, context) && result;
            return result;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} durationInterval
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateDurationInterval(durationInterval : uml.DurationInterval, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(durationInterval, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(durationInterval, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(durationInterval, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(durationInterval, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(durationInterval, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(durationInterval, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(durationInterval, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(durationInterval, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(durationInterval, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(durationInterval, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(durationInterval, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(durationInterval, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(durationInterval, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(durationInterval, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePackageableElement_namespace_needs_visibility(durationInterval, diagnostics, context) && result;
            return result;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} durationObservation
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateDurationObservation(durationObservation : uml.DurationObservation, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(durationObservation, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(durationObservation, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(durationObservation, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(durationObservation, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(durationObservation, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(durationObservation, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(durationObservation, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(durationObservation, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(durationObservation, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(durationObservation, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(durationObservation, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(durationObservation, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(durationObservation, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(durationObservation, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePackageableElement_namespace_needs_visibility(durationObservation, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateDurationObservation_first_event_multiplicity(durationObservation, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the first_event_multiplicity constraint of '<em>Duration Observation</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} durationObservation
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateDurationObservation_first_event_multiplicity(durationObservation : uml.DurationObservation, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return durationObservation.first_event_multiplicity(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} literalBoolean
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateLiteralBoolean(literalBoolean : uml.LiteralBoolean, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(literalBoolean, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(literalBoolean, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(literalBoolean, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(literalBoolean, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(literalBoolean, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(literalBoolean, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(literalBoolean, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(literalBoolean, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(literalBoolean, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(literalBoolean, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(literalBoolean, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(literalBoolean, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(literalBoolean, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(literalBoolean, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePackageableElement_namespace_needs_visibility(literalBoolean, diagnostics, context) && result;
            return result;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} literalSpecification
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateLiteralSpecification(literalSpecification : uml.LiteralSpecification, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(literalSpecification, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(literalSpecification, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(literalSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(literalSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(literalSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(literalSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(literalSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(literalSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(literalSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(literalSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(literalSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(literalSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(literalSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(literalSpecification, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePackageableElement_namespace_needs_visibility(literalSpecification, diagnostics, context) && result;
            return result;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} literalInteger
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateLiteralInteger(literalInteger : uml.LiteralInteger, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(literalInteger, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(literalInteger, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(literalInteger, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(literalInteger, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(literalInteger, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(literalInteger, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(literalInteger, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(literalInteger, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(literalInteger, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(literalInteger, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(literalInteger, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(literalInteger, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(literalInteger, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(literalInteger, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePackageableElement_namespace_needs_visibility(literalInteger, diagnostics, context) && result;
            return result;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} literalNull
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateLiteralNull(literalNull : uml.LiteralNull, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(literalNull, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(literalNull, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(literalNull, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(literalNull, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(literalNull, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(literalNull, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(literalNull, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(literalNull, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(literalNull, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(literalNull, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(literalNull, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(literalNull, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(literalNull, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(literalNull, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePackageableElement_namespace_needs_visibility(literalNull, diagnostics, context) && result;
            return result;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} literalReal
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateLiteralReal(literalReal : uml.LiteralReal, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(literalReal, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(literalReal, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(literalReal, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(literalReal, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(literalReal, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(literalReal, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(literalReal, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(literalReal, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(literalReal, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(literalReal, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(literalReal, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(literalReal, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(literalReal, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(literalReal, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePackageableElement_namespace_needs_visibility(literalReal, diagnostics, context) && result;
            return result;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} literalString
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateLiteralString(literalString : uml.LiteralString, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(literalString, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(literalString, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(literalString, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(literalString, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(literalString, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(literalString, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(literalString, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(literalString, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(literalString, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(literalString, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(literalString, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(literalString, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(literalString, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(literalString, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePackageableElement_namespace_needs_visibility(literalString, diagnostics, context) && result;
            return result;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} literalUnlimitedNatural
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateLiteralUnlimitedNatural(literalUnlimitedNatural : uml.LiteralUnlimitedNatural, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(literalUnlimitedNatural, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(literalUnlimitedNatural, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(literalUnlimitedNatural, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(literalUnlimitedNatural, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(literalUnlimitedNatural, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(literalUnlimitedNatural, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(literalUnlimitedNatural, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(literalUnlimitedNatural, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(literalUnlimitedNatural, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(literalUnlimitedNatural, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(literalUnlimitedNatural, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(literalUnlimitedNatural, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(literalUnlimitedNatural, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(literalUnlimitedNatural, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePackageableElement_namespace_needs_visibility(literalUnlimitedNatural, diagnostics, context) && result;
            return result;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} timeConstraint
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateTimeConstraint(timeConstraint : uml.TimeConstraint, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(timeConstraint, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(timeConstraint, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(timeConstraint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(timeConstraint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(timeConstraint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(timeConstraint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(timeConstraint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(timeConstraint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(timeConstraint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(timeConstraint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(timeConstraint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(timeConstraint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(timeConstraint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(timeConstraint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePackageableElement_namespace_needs_visibility(timeConstraint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateConstraint_boolean_value(timeConstraint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateConstraint_no_side_effects(timeConstraint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateConstraint_not_apply_to_self(timeConstraint, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateTimeConstraint_has_one_constrainedElement(timeConstraint, diagnostics, context) && result;
            return result;
        }

        /**
         * Validates the has_one_constrainedElement constraint of '<em>Time Constraint</em>'.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} timeConstraint
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateTimeConstraint_has_one_constrainedElement(timeConstraint : uml.TimeConstraint, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return timeConstraint.has_one_constrainedElement(diagnostics, context);
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} timeInterval
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateTimeInterval(timeInterval : uml.TimeInterval, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(timeInterval, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(timeInterval, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(timeInterval, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(timeInterval, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(timeInterval, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(timeInterval, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(timeInterval, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(timeInterval, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(timeInterval, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(timeInterval, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(timeInterval, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(timeInterval, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(timeInterval, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(timeInterval, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePackageableElement_namespace_needs_visibility(timeInterval, diagnostics, context) && result;
            return result;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {*} timeObservation
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateTimeObservation(timeObservation : uml.TimeObservation, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            if(!this.validate_NoCircularContainment(timeObservation, diagnostics, context)) return false;
            let result : boolean = this.validate_EveryMultiplicityConforms(timeObservation, diagnostics, context);
            if(result || diagnostics != null) result = this.validate_EveryDataValueConforms(timeObservation, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryReferenceIsContained(timeObservation, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryBidirectionalReferenceIsPaired(timeObservation, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryProxyResolves(timeObservation, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_UniqueID(timeObservation, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryKeyUnique(timeObservation, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validate_EveryMapEntryUnique(timeObservation, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_has_owner(timeObservation, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateElement_not_own_self(timeObservation, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_visibility_needs_ownership(timeObservation, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_qualified_name(timeObservation, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validateNamedElement_has_no_qualified_name(timeObservation, diagnostics, context) && result;
            if(result || diagnostics != null) result = this.validatePackageableElement_namespace_needs_visibility(timeObservation, diagnostics, context) && result;
            return result;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {uml.VisibilityKind} visibilityKind
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateVisibilityKind(visibilityKind : uml.VisibilityKind, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return true;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {uml.ParameterDirectionKind} parameterDirectionKind
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateParameterDirectionKind(parameterDirectionKind : uml.ParameterDirectionKind, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return true;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {uml.ParameterEffectKind} parameterEffectKind
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateParameterEffectKind(parameterEffectKind : uml.ParameterEffectKind, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return true;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {uml.CallConcurrencyKind} callConcurrencyKind
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateCallConcurrencyKind(callConcurrencyKind : uml.CallConcurrencyKind, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return true;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {uml.TransitionKind} transitionKind
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateTransitionKind(transitionKind : uml.TransitionKind, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return true;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {uml.PseudostateKind} pseudostateKind
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validatePseudostateKind(pseudostateKind : uml.PseudostateKind, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return true;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {uml.AggregationKind} aggregationKind
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateAggregationKind(aggregationKind : uml.AggregationKind, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return true;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {uml.ConnectorKind} connectorKind
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateConnectorKind(connectorKind : uml.ConnectorKind, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return true;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {uml.ObjectNodeOrderingKind} objectNodeOrderingKind
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateObjectNodeOrderingKind(objectNodeOrderingKind : uml.ObjectNodeOrderingKind, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return true;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {uml.ExpansionKind} expansionKind
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateExpansionKind(expansionKind : uml.ExpansionKind, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return true;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {uml.MessageKind} messageKind
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateMessageKind(messageKind : uml.MessageKind, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return true;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {uml.MessageSort} messageSort
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateMessageSort(messageSort : uml.MessageSort, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return true;
        }

        /**
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @param {uml.InteractionOperatorKind} interactionOperatorKind
         * @param {*} diagnostics
         * @param {*} context
         * @return {boolean}
         */
        public validateInteractionOperatorKind(interactionOperatorKind : uml.InteractionOperatorKind, diagnostics : org.eclipse.emf.common.util.DiagnosticChain, context : any) : boolean {
            return true;
        }

        /**
         * Returns the resource locator that will be used to fetch messages for this validator's diagnostics.
         * <!-- begin-user-doc -->
         * <!-- end-user-doc -->
         * @generated
         * @return {*}
         */
        public getResourceLocator() : org.eclipse.emf.common.util.ResourceLocator {
            return super.getResourceLocator();
        }
    }
    UmlValidator["__class"] = "uml.util.UmlValidator";
    UmlValidator["__interfaces"] = ["org.eclipse.emf.ecore.EValidator"];


}


uml.util.UmlValidator.DIAGNOSTIC_CODE_COUNT_$LI$();

uml.util.UmlValidator.INSTANCE_$LI$();
